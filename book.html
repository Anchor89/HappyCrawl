<html>
 <head> 
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /> 
  <link href="http://chuansongme.com/static/css/inspector.css" rel="stylesheet" type="text/css" /> 
  <link href="http://chuansongme.com/static/css/main.css" rel="stylesheet" type="text/css" /> 
  <link href="http://chuansongme.com/static/css/base.css" rel="stylesheet" type="text/css" /> 
  <!--[if IE]>
<link href="http://chuansongme.com/static/css/ie.css" rel="stylesheet" type="text/css">
<![endif]--> 
  <!-- Le fav and touch icons --> 
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://chuansongme.com/static/img/ico/apple-touch-icon-ipad3.png" /> 
  <link rel="apple-touch-icon-precomposed" sizes="114x114" href="http://chuansongme.com/static/img/ico/apple-touch-icon-iphone4.png" /> 
  <link rel="apple-touch-icon-precomposed" sizes="72x72" href="http://chuansongme.com/static/img/ico/apple-touch-icon-ipad.png" /> 
  <link rel="apple-touch-icon-precomposed" href="http://chuansongme.com/static/img/ico/apple-touch-icon-iphone.png" /> 
  <link rel="shortcut icon" href="http://chuansongme.com/static/favicon.ico" /> 
  <style type="text/css" media="screen">#__w2_ixyeIom_flash {
visibility: hidden
}</style> 
  <title>待字闺中合集</title> 
  <meta name="keywords" content="今日面试题：数对数目；及LIS问题分析,待字闺中,传送门" /> 
  <meta name="description" content="20号的周日，参加了马拉松，第一次参加，跑完之后非常疲惫，故耽误了几天的分享。" /> 
  <style type="text/css">
.essay-header{
text-align:center
}
#essay-body,#position-bar{
max-width: 800px;
margin: 0 auto;
font-size: 16px;
}
.page-imform{
display: none;
}
img{
display: block;
margin-left: auto;
margin-right: auto;
max-width: 500px;
max-height: 500px;
margin: 0 auto ;
}
</style> 
 </head> 
 <body> 
  <div id="essay-body">
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">面试游戏题：海枯石烂</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-06-28</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-88520-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>两个玩家，一堆石头，假设多于100块，两人依次拿，最后拿光者赢，规则是：1. 第一个人不能一次拿光所有的；2. 第一次拿了之后， 每人每次最多只能拿对方前一次拿的数目的两倍。求先拿者必胜策略, 如果有的话。怎么证明必胜。有的面试，考察的是过程，比如，思考的方式，交流的畅通，等。大家先想想，讨论，参考方案以后揭晓。<br /></p> 
      <p><span style="color:#33463f;font-family:arial, helvetica, sans-serif;font-size:12px;line-height:19px;background-color:#f2f2f2;"><br /></span></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">面试编程题：单链表和之恋；和海枯石烂题之分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-06-29</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-88519-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>两个单链表（singly linked list），每一个节点里面一个0-9的数字，输入就相当于两个大数了。然后返回这两个数的和（一个新list）。这两个输入的list长度相等。 要求是：1. 不用递归。2. 要求算法在最好的情况下，只遍历两个list一次 ，最差的情况下两遍。<br /></p> 
      <p><br /></p> 
      <p>＝＝＝＝＝＝＝＝＝＝</p> 
      <p><strong>关于海枯石烂的分析：</strong></p> 
      <p><br /></p> 
      <p>原题：两个玩家，一堆石头，假设多于100块，两人依次拿，最后拿光者赢，规则是：1. 第一个人不能一次拿光所有的；2. 第一次拿了之后， 每人每次最多只能拿对方前一次拿的数目的两倍。求先拿者必胜策略, 如果有的话。怎么证明必胜。<br /></p> 
      <p><br /></p> 
      <p>分析：这是斐波那契博弈，当且仅当石头个数是斐波那契数的时候先手必败。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"><br /></p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">让我们用第二数学归纳法证明：<br /></p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">为了方便，我们将n记为f[i]。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">1、当　i=2　时，因为不能全部去完，先手只能取1颗，显然必败，结论成立。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">2、假设当　i&lt;=k　时，结论成立。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp; 则当　i=k+1　时，f[i] = f[k]+f[k-1]。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp; 则我们可以把这一堆石子看成两堆，简称k堆和k-1堆。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp;（一定可以看成两堆，因为假如先手第一次取的石子数大于或等于f[k-1]，则后手可以直接取完f[k]，因为　f[k] &lt; 2*f[k-1]　）</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp; 对于k-1堆，由假设可知，不论先手怎样取，后手总能取到最后一颗。下面我们分析一下后手最后取的石子数x的情况。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp; 如果先手第一次取的石子数　y&gt;=f[k-1]/3　，则这小堆所剩的石子数小于2y，即后手可以直接取完，此时　x=f[k-1]-y　，则　x&lt;=2/3*f[k-1]　。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp; 我们来比较一下　2/3*f[k-1]　与　1/2*f[k]　的大小。即　4*f[k-1]与　3*f[k]　的大小，对两值作差后不难得出，后者大。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp; 所以我们得到，x&lt;1/2*f[k]　。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp; 即后手取完k-1堆后，先手不能一下取完k堆，所以游戏规则没有改变，则由假设可知，对于k堆，后手仍能取到最后一颗，所以后手必胜。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;"> &nbsp; &nbsp; 即i=k+1时，结论依然成立。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">那么，当n不是Fibonacci数的时候，情况又是怎样的呢？</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">这里需要借助“Zeckendorf定理”（齐肯多夫定理）：<span style="text-decoration:initial;">任何正整数可以表示为若干个不连续的Fibonacci数之</span><span style="text-decoration:initial;">和。</span></p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">关于这个定理的证明，感兴趣的同学可以在网上搜索相关资料，这里不再详述。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">分解的时候，要取尽量大的Fibonacci数。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">比如分解85：85在55和89之间，于是可以写成85=55+30，然后继续分解30,30在21和34之间，所以可以写成30=21+9，</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">依此类推，最后分解成85=55+21+8+1。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">则我们可以把n写成 &nbsp;n = f[a1]+f[a2]+……+f[ap]。（a1&gt;a2&gt;……&gt;ap）</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">我们令先手先取完f[ap]，即最小的这一堆。由于各个f之间不连续，则a(p-1) &gt; ap &nbsp;+ 1，则有f[a(p-1)] &gt; 2*f[ap]。即后手只能取f[a(p-1)]这一堆，且不能一次取完。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">此时后手相当于面临这个子游戏（只有f[a(p-1)]这一堆石子，且后手先取）的必败态，即先手一定可以取到这一堆的最后一颗石子。</p> 
      <p style="margin:0px auto 18px;padding:0px;font-size:14px;background-color:#ffffff;border:medium none;line-height:19px;font-family:verdana, arial, helvetica, sans-serif;list-style-type:none;">同理可知，对于以后的每一堆，先手都可以取到这一堆的最后一颗石子，从而获得游戏的胜利。</p> 
      <p>参考：http://blog.csdn.net/dgq8211/article/details/7602807</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">面试思考题：最多连续数的子集；及单链表和之恋分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-06-30</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-89263-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>给一个整数数组， 找到其中包含最多连续数的子集，比如给：15, 7, 12, 6, 14, 13, 9, 11，则返回: 5:[11, 12, 13, 14, 15] 。最简单的方法是sort然后scan一遍，但是要o(nlgn). 有什么O(n)的方法吗？<br /></p> 
      <p><br /></p> 
      <p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p> 
      <p>单链表和之恋分析：</p> 
      <p><br /></p> 
      <p>原题：两个单链表（singly linked list），每一个节点里面一个0-9的数字，输入就相当于两个大数了。然后返回这两个数的和（一个新list）。这两个输入的list长度相等。 要求是：1. 不用递归。2. 要求算法在最好的情况下，只遍历两个list一次 ，最差的情况下两遍。<br /></p> 
      <p><br /></p> 
      <p>分析：遇到一个面试题，首先，<strong><span style="color:#e36c09;">要澄清和理解题意，确保你的理解和面试官的本意一致</span></strong>。题中的单链表，可不可以原地修改？是从高位到低位，还是低位到高位？如果是从低位到高位，那么问题很简单，是不是？只要两个指针移动（因为是等长的），对应位置相加，同时记录是否有进位，产生的结果存入新的链表中。</p> 
      <p><br /></p> 
      <p>如果是从高到低，问题就复杂了，进位是万恶之源。这时，也许我们会想到reverse两个单链表（其实，这也是一道很好的面试题，如何做？考虑递归和递推两种算法），但这样做，是不是最好最坏情形都得遍历两次？好像不合题意。</p> 
      <p><br /></p> 
      <p>如果新的链表的节点可以存一个或两个数字，那么，第一遍，将相应节点的数字相加，存入新的链表，并用一个flag标志整个操作中是否有进位。如果没有，结了；否则，再扫描一遍新的链表，将有两个数字的进位存到上一个节点。如果新的链表是双的，问题比较简单；如果新的链表还是单的，这一步也会很复杂，比如，１０－〉９－〉９－〉１２，如何转成１－〉１－〉０－〉０－〉２，本身也是一个很好的面试题。这时可能需要reverse链表再操作。</p> 
      <p><br /></p> 
      <p>如果新的链表的节点只能存一个数字，那么能有什么办法？</p> 
      <p><br /></p> 
      <p>也许你有更好的解决办法？期待。</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">面试题单链表和之恋精美解答</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-01</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-92111-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>本期<span style="color:#C00000;">推荐Hawstein （新浪微博@Hawstein）对于面试题求两个单链表的和的精美分析和解答</span>。如果你对我们的面试题有不同的更优的解答，请回复我们。对于耳目一新的深思熟虑的分析和解答，我们将在此推荐。</p> 
      <p><br /></p> 
      <p>另外，推荐大家关注<span style="color:#C00000;">梁斌主持的微信公众账号pennyjob</span>，是个大型职场安全栏目，你将看到每日的职场信息更新。</p> 
      <p><br /></p> 
      <p><strong><span style="color:#000000;">今天的 Bonus 面试题：一个单链表head，和一个指向表中某个节点的指针p，怎么以最快的速度删除指针p所指的节点？</span></strong></p> 
      <p><br /></p> 
      <h2 style="">题目</h2> 
      <p style="">两个单链表（singly linked list），每一个节点里面一个0-9的数字， 输入就相当于两个大数了。然后返回这两个数的和（一个新list）。这两个输入的list 长度相等。 要求是：1. 不用递归。2. 要求算法在最好的情况下，只遍历两个list一次， 最差的情况下两遍。</p> 
      <h2 style="">解答</h2> 
      <p style="">这是陈利人同学今天发在待字闺中的面试编程题目，看了一下解答， 发现要么需要遍历链表两次，要么需要额外的存储空间，难道就没有更优的解法了吗？ 想了一下，发现还是有的。</p> 
      <p style="">顺便推荐一下陈利人同学的微博：@陈利人 和他的公众平台：待字闺中。一看这同学的名字就值得关注，利人，你值得拥有。</p> 
      <p style="">OK，我们把这个问题具体化一下吧：(这里就不再考虑从低到高存等blabla情况)</p> 
      <blockquote style=""> 
       <blockquote style="padding:0px 0px 0px 15px;margin:0px 0px 18px;border-left-width:5px;border-left-style:solid;border-left-color:#eeeeee;"> 
        <p style="font-size:16px;line-height:22.5px;margin-top:0px;margin-bottom:0px;">两个单链表，每个节点存储一个0-9的数字，那么一个单链表就表示一个大数。 从高位到低位存，即表头对应的是这个大数的最高位。两个链表的长度相等， 我们要返回一个新的单链表，是这两个输入链表代表的数的和。我们不能使用递归， 不能使用额外的存储空间，即空间复杂度是O(1)。只遍历输入链表一次， 输出链表也是单链表(没有前向指针)。</p> 
       </blockquote> 
      </blockquote> 
      <p style="">既然只能遍历两个输入链表一次，那我们就从高位加起呗。在这种限制条件下， 这是唯一的出路。然后呢？进位咋整？先加高位，再加低位， 低位产生的进位怎么加到高位去？我们可没有前向指针哦亲。既然没有前向指针， 我们就让一个临时指针指向高位，当低位相加产生进位时，我们就可以操作高位了。 让我们看看图示：</p> 
      <p><code style=""><br /></code></p> 
      <p><code style="">输入链表1： 1 2 3 </code></p> 
      <p><code style="">输入链表2： 1 2 8 </code></p> 
      <p><code style="">输出链表： &nbsp;2 4 &nbsp;</code></p> 
      <p><code style="">两个指针： &nbsp; &nbsp;p q</code></p> 
      <p><code style=""> </code></p> 
      <p style="">当指向输出链表当前结点的指针q发现3+8=11，产生进位，指向高位的p就将结点值加1。 <strong>注意，两个0-9的数相加，要么不进位，要么进位为1，只有两种情况</strong>。因此， 我们不用考虑进位是其它数，这一点很重要，后面会看到的。</p> 
      <p style="">这样就OK了吗？当然不是，如果你遇上连续进位，怎么破？请看下面的情况：</p> 
      <p><code style=""><br /></code></p> 
      <p><code style="">输入链表1： 1 2 3 4 5 </code></p> 
      <p><code style="">输入链表2： 1 7 6 5 9</code></p> 
      <p><code style=""> </code></p> 
      <p style="">显然，指向高位的指针p总是紧跟着指向当前结点的指针q是不行的， 这样当遇上连续进位时，比p更高位的位也需要改变。既然p不能紧跟着q， 我们就不让它们紧挨着，给它们产生点距离。考虑一下，什么情况下会产生连续进位？ 9! 嗯，遇上9的时候。它要连续进位到哪一位？不为9的那一位。因此，指针p 要停留在和不为9的那一位上，看图示：</p> 
      <p><code style=""><br /></code></p> 
      <p><code style="">输入链表1： 1 2 3 4 5 </code></p> 
      <p><code style="">输入链表2： 1 7 6 5 9 </code></p> 
      <p><code style="">输出链表： &nbsp;2 9 9 9 </code></p> 
      <p><code style="">两个指针： &nbsp;p &nbsp; &nbsp; &nbsp; q </code></p> 
      <p style=""><br /></p> 
      <p style="">这回当q发现，需要进位了，只需要把p所指结点加1，然后把p，q间的结点都置0即可。 为什么都置0了呢，<strong>因为进位只可能是1</strong>，9+1=10，留在该位的自然是0了。</p> 
      <p style="">分析完毕，这种方法在任何时候都只需要遍历输入链表一次，空间复杂度O(1)。</p> 
      <p style="">参考代码实现：http://hawstein.com/posts/add-singly-linked-list.html</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">Google面试题：搜索之星；最多连续数的子集答案</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-02</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-93910-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>这是一道Google面试题，暂且叫它“搜索之星”吧。</p> 
      <p><br /></p> 
      <p>给你一天的Google搜索日志，你怎么设计算法找出是否有一个搜索词，它出现的频率占所有搜索的一半以上？如果肯定有一个搜索词占大多数，你能怎么提高你的算法找到它？再假定搜索日志就是内存中的一个数组，能否有O(1)空间，O(n)时间的算法？<br /></p> 
      <p><br /></p> 
      <p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p> 
      <p>最多连续数的子集之参考答案<br /></p> 
      <p><br /></p> 
      <p>题目：</p> 
      <p><br /></p> 
      <p>给一个整数数组， 找到其中包含最多连续数的子集，比如给：15, 7, 12, 6, 14, 13, 9, 11，则返回: 5:[11, 12, 13, 14, 15] 。最简单的方法是sort然后scan一遍，但是要o(nlgn). 有什么O(n)的方法吗？</p> 
      <p><br /></p> 
      <p>分析：</p> 
      <p><br /></p> 
      <p>我们先来学习一种叫做并查集的数据结构。</p> 
      <p><br /></p> 
      <p>并查集（Disjoint set或者Union-find set）是一种简单的用途广泛的算法和数据结构。并查集是若干个不相交集合，能够实现较快的合并和判断元素所在集合的操作，应用很多，如其求无向图的连通分量个数等。<br /></p> 
      <p><br /></p> 
      <p><strong><span style="text-decoration:underline;">并查集可以方便地进行以下三种操作：</span></strong><br /></p> 
      <p><br /></p> 
      <p><strong>1、Make_Set(x) 把每一个元素初始化为一个集合</strong></p> 
      <p><br /></p> 
      <p>初始化后每一个元素的父亲节点是它本身，每一个元素的祖先节点也是它本身（也可以根据情况而变）。</p> 
      <p><br /></p> 
      <p><strong>2、Find_Set(x) 查找一个元素所在的集合</strong></p> 
      <p><br /></p> 
      <p>查找一个元素所在的集合，其精髓是找到这个元素所在集合的祖先。这个才是并查集判断和合并的最终依据。</p> 
      <p><br />判断两个元素是否属于同一集合，只要看他们所在集合的祖先是否相同即可。<br /><br /></p> 
      <p>合并两个集合，也是使一个集合的祖先成为另一个集合的祖先，具体见示意图</p> 
      <p><br /></p> 
      <p><strong>3、Union(x,y) 合并x,y所在的两个集合</strong></p> 
      <p><br /></p> 
      <p>合并两个不相交集合操作很简单：<br /><br /></p> 
      <p>利用Find_Set找到其中两个集合的祖先，将一个集合的祖先指向另一个集合的祖先。如图</p> 
      <p><img src="pics/689-93910-1.jpg" width="433" height="163" border="0" data-pinit="registered" style="border:0px;max-width:600px;" onerror="" /></p> 
      <p><br /></p> 
      <p><br /></p> 
      <p><strong><span style="text-decoration:underline;">并查集的优化：</span></strong><br /></p> 
      <p><strong><span style="text-decoration:underline;"><br /></span></strong></p> 
      <p><strong>1、Find_Set(x)时 路径压缩</strong><br /><br /></p> 
      <p>寻找祖先时我们一般采用递归查找，但是当元素很多亦或是整棵树变为一条链时，每次Find_Set(x)都是O(n)的复杂度，有没有办法减小这个复杂度呢？<br /><br /></p> 
      <p>答案是肯定的，这就是路径压缩，即当我们经过&quot;递推&quot;找到祖先节点后，&quot;回溯&quot;的时候顺便将它的子孙节点都直接指向祖先，这样以后再次Find_Set(x)时复杂度就变成O(1)了，如下图所示；可见，路径压缩方便了以后的查找。</p> 
      <p><br /></p> 
      <p><strong>2、Union(x,y)时 按秩合并</strong><br /><br /></p> 
      <p>即合并的时候将元素少的集合合并到元素多的集合中，这样合并之后树的高度会相对较小。</p> 
      <p><img src="pics/689-93910-2.jpg" width="458" height="203" border="0" data-pinit="registered" style="border:0px;max-width:600px;" onerror="" /></p> 
      <p><br />有了背景知识，我们来看如何利用它来解决这个问题。</p> 
      <p><br /></p> 
      <p>首先，Make_Set(x)将每个元素变成一个并查集，然后扫描，Union(x-1, x)，Union(x, x+1)。</p> 
      <p><br /></p> 
      <p>接下来的问题是怎么快速找到x-1,x+1的位置？那么需要引入查找为常数复杂度的哈希表。</p> 
      <p><br /></p> 
      <p>其他网友建议的解决方案：</p> 
      <p><br /></p> 
      <p><br /></p> 
      <p><span style="text-decoration:underline;">网友Mike建议</span>：</p> 
      <p><br /></p> 
      <p>用一个map&lt;int, int&gt;，它的key是一个起始的数字，value是这个起始数字起连续的个数。这样这个数组遍历一遍下来，只要map维护好了，自然就能得到最长的连续子串了，并且算法复杂度应该是O(n)。（不考虑map函数实现的复杂度）</p> 
      <p><br />前面说了维护好map就可以了，那么怎么来维护这个map呢？<br style="font-family:verdana;font-size:13px;line-height:18px;" /></p> 
      <ol style="font-family:verdana;font-size:13px;line-height:18px;"> 
       <li><p>取出当前的整数，在map里看一下是否已经存在，若存在则直接取下一个，不存在转2 (为什么要看是否已经存在，因为题目没有说不会有重复的数字。)</p></li> 
       <li><p>查看下map里面当前数字的前一个是否存在，如果存在，当前的最长长度就是前一个最长长度+1</p></li> 
       <li><p>查看下map里面当前数字的后一个是否存在，如果存在，那么就将以下一个数字开始的子串的最后一个更新下，因为本来没有连上的2个子串，因为当前数字的出现连起来了</p></li> 
       <li><p>接着再看下前面数字是否存在，如果存在，就更新以这个数字结尾的子串的第一个数字的连续子串长度，原因同上</p></li> 
      </ol> 
      <p>算法就是如上所示了，我们拿例子演练一遍<br style="font-family:verdana;font-size:13px;line-height:18px;" /><br /></p> 
      <p>1) &nbsp; 首先给定15，这个时候map里面没有15也没有14和16，那么这个执行完了之后map是map[15] = 1;<br style="font-family:verdana;font-size:13px;line-height:18px;" /><br /></p> 
      <p>2) &nbsp; 然后遇到7，同上，也没有6，7和8，所以执行玩了之后变成map[7]=1, map[15]=1;<br style="font-family:verdana;font-size:13px;line-height:18px;" /><br /></p> 
      <p>3) &nbsp; 12同上，map[7]=1, map[12]=1, map[15]=1;<br style="font-family:verdana;font-size:13px;line-height:18px;" /><br /></p> 
      <p>4) &nbsp; 接下来是6，6就不一样了，因为7存在的，所以执行上面第3步之后，map[6]=2,map[7]=2,map[12]=1,map[15]=1;<br style="font-family:verdana;font-size:13px;line-height:18px;" /><br /></p> 
      <p>5) &nbsp; 14的情况跟6一样，结果是map[6]=2,map[7]=2,map[12]=1,map[14]=2,map[15]=2;<br style="font-family:verdana;font-size:13px;line-height:18px;" /><br /></p> 
      <p>6) &nbsp; 13的情况相对复杂一些，因为12和14都存在了 ，所以它会执行以上1，2，3，4的所有4步：首先12存在，所以13的最长子串是2，14存在，所以会更新到14起始的最后一个数字的最长长度，这里就是15的长度=它自己的加上13的长度，也就是4，同时我们把13的长度也改成4，最后因为12存在，我们要更新以12结尾的连续子串的开始处，本例中就是12自己，12对应更新成4<br style="font-family:verdana;font-size:13px;line-height:18px;" /><br /></p> 
      <p>7) &nbsp; 最后是11，11的前面一个数字不存在，后一个数字存在，也就是要执行以上1，3，第3步结束的时候已经是11和15都更新成5了。最后的结果也就是5，并且是从11起始的。</p> 
      <p><br /></p> 
      <p>代码参考　http://www.cppblog.com/everyday/articles/201439.html<br /></p> 
      <p><span style="text-decoration:underline;"><br /></span></p> 
      <p><span style="text-decoration:underline;">网友xd_jackfeng建议</span>：</p> 
      <p><br /></p> 
      <p>设置一个bitmap，初始值为0，如果出现则设置为1，这样看有多少个1连续就可以了。<br /></p> 
      <p><br /></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">经典面试题：蓄水池抽样；及Google搜索之星分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-03</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-95556-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题，<span style="color:#c00000;">蓄水池抽样</span>，又称<span style="color:#c00000;">随机抽样问题</span></strong>，表示如下：</p> 
      <p><br /></p> 
      <p>要求从N个元素中随机的抽取k个元素，其中N无法确定。</p> 
      <p><br /></p> 
      <p>这种应用的场景一般是数据流的情况下，由于数据只能被读取一次，而且数据量很大，并不能全部保存，因此数据量N是无法在抽样开始时确定的；但又要保持随机性，于是有了这个问题。所以搜索网站有时候会问这样的问题。</p> 
      <p><br /></p> 
      <p>这里的核心问题就是“随机”，怎么才能是随机的抽取元素呢？我们设想，买彩票的时候，由于所有彩票的中奖概率都是一样的，所以我们才是“随机的”买彩票。那么要使抽取数据也随机，必须使每一个数据被抽样出来的概率都一样。</p> 
      <p><br /></p> 
      <p>＝＝＝＝＝＝＝＝＝＝＝＝＝</p> 
      <p><strong>Google 搜索之星分析</strong></p> 
      <p><br /></p> 
      <p>题目：</p> 
      <p><br /></p> 
      <p>给你一天的Google搜索日志，你怎么设计算法找出是否有一个搜索词，它出现的频率占所有搜索的一半以上？如果肯定有一个搜索词占大多数，你能怎么提高你的算法找到它？再假定搜索日志就是内存中的一个数组，能否有O(1)空间，O(n)时间的算法？<br /></p> 
      <p><br /></p> 
      <p>分析：</p> 
      <p><br /></p> 
      <p>首先要看清题目，说的是“一半以上”，“大多数”，&quot;majority&quot;，也就是大于５０％。<br /></p> 
      <p><br /></p> 
      <p>很多情形下，尤其在面试比较紧张的情形下，经常会下意识的很快得出一个如下的方法（这个没有错，能有解决方案胜于完全没想法）。定义一个哈希表，里面存放数组里面的每个元素以及出现的次数。可以通过两个过程来做。</p> 
      <p><br /></p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp;第一步是映射，将每个元素放进去，存在加一，不存在置一。同时统计元素个数。</p> 
      <p><br /></p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp;第二步是遍历整个哈希表，判断是否找到出现次数大于数组长度一半的。如果有，找到。否则没有。<br /></p> 
      <p><br /></p> 
      <p>显然，这个要求O(n)的空间在存储哈希表，并不理想。</p> 
      <p><br /></p> 
      <p>另外的下意识的方法， 比如说，先将元素排序，然后再进行判断。因为如果有大多数的话，取数组中间点的那个元素即为所要找的那个。不过这种方法首先排序就需要O(NlogN)的时间复杂度，并不是很理想。</p> 
      <p><br /></p> 
      <p>题中说到肯定有一个搜索词是大多数，这个条件可能蕴藏着提高的空间。</p> 
      <p><br /></p> 
      <p>面试时，我们会经常写下一个例子，手工做些运算，也许能找到好的方案。</p> 
      <p><br /></p> 
      <p>比如，1，2，2，3，2，2，3 &nbsp;显然2是多数元素</p> 
      <p>去除1，2，在2，3，2，2，3中2仍是多数元素<br /></p> 
      <p>去除1，3，在2，3，2，2，3中2更是多数元素<br /><br /></p> 
      <p>再比如，1，3，2，3，2，2，3 &nbsp;显然没有多数元素</p> 
      <p>去除1，3，在2，3，2，2，3中2成了多数</p> 
      <p><br /></p> 
      <p>观察结论：在原序列中去除两个不同的元素后，那么在原序列中的多数元素在新序列中还是多数元素。但新序列中的多数元素在原序列不一定是多数，所以需要验证。但原题说是肯定有多数，所以我们可以忽略验证。<br /></p> 
      <p><br /></p> 
      <p>基于这个观察，假设我们一开始从数组的开头，碰到某个元素的时候，就设置该元素为当前元素。当前出现的次数为1，后面，如果接着碰到的元素和该元素相同，则当前次数加1，否则减1。如果当前出现的次数为0，则表示当前元素不确定。如果结合我们有大多数元素这个前提的话，必然最后的结果是大于0的，而且最终获取到的值就是大多数元素。<br /></p> 
      <p><br /></p> 
      <p>对于这个大多数算法（Majority Algorithm）, 国外有教授有研究并发表论文：《MJRTY - A Fast Majority Vote Algorithm》 http://www.cs.utexas.edu/~moore/best-ideas/mjrty/index.html </p> 
      <p><br /></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">面试题：忘我之乘积；及蓄水池抽样精妙解法</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-04</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-96391-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><span style="color:#333333;font-family:arial;"><span style="font-size:14.44444465637207px;line-height:25.981481552124023px;">今日面试题：忘我之乘积</span></span></p> 
      <p><br /></p> 
      <p>给你一个数组A[1..n]，请你在O(n)的时间里构造一个新的数组B[1..n]，使得B[i]=A[1]*A[2]*...*A[n]/A[i]。你不能使用除法运算。</p> 
      <p><br /></p> 
      <p>=====================================</p> 
      <p>蓄水池抽样（Reservoir Sampling)问题分析</p> 
      <p><br /></p> 
      <p>问题：</p> 
      <p><br /></p> 
      <p>要求从N个元素中随机的抽取k个元素，其中N无法确定。</p> 
      <p><br /></p> 
      <p>这种应用的场景一般是数据流的情况下，由于数据只能被读取一次，而且数据量很大，并不能全部保存，因此数据量N是无法在抽样开始时确定的；但又要保持随机性，于是有了这个问题。所以搜索网站有时候会问这样的问题。</p> 
      <p><br /></p> 
      <p>这里的核心问题就是“随机”，怎么才能是随机的抽取元素呢？我们设想，买彩票的时候，由于所有彩票的中奖概率都是一样的，所以我们才是“随机的”买彩票。那么要使抽取数据也随机，必须使每一个数据被抽样出来的概率都一样。</p> 
      <p><br /></p> 
      <p>分析：</p> 
      <p><br /></p> 
      <p>由于N无法确定，数据只能读取一次，并且要求随机，就是每个元素抽出的概率一样，都是k/N。</p> 
      <p><br /></p> 
      <p>面试的时候，经常会在纸上通过一个小的例子来找到好的解决方案。比如先让你从100个元素中等概率抽取出10个元素。后来又向集合中添加了20个元素，变成了120个元素等概率抽取10个，怎么样才能随着N的动态改变而让N无论等于多少时这N个元素都等概率被抽取呢？</p> 
      <p><br /></p> 
      <p>解法一：最小k个指纹</p> 
      <p><br /></p> 
      <p>找到一个哈希函数能产生随机数，同时用一个k个元素的堆用来保存最小的k个元素。那么过一遍所有的元素，计算每个的哈希值，通过堆来选择k个元素。</p> 
      <p><br /></p> 
      <p>这个算法看起来很精妙，会有什么问题吗？（思考）</p> 
      <p><br /></p> 
      <p>解法二：数学计算</p> 
      <p><br /></p> 
      <p>先选中前k个， 从第k+1个元素到最后一个元素为止， 以1/i &nbsp;(i=k+1, k+2,...,N) 的概率选中第i个元素， 并且随机替换掉一个原先选中的元素， 这样遍历一次得到k个元素， 可以保证完全随机选取。<br /></p> 
      <p><br /></p> 
      <p>看来简单的算法，怎么能确保每个元素被选中的概率是k/N？</p> 
      <p><br /></p> 
      <p>任意元素G在i轮留下来的概率：</p> 
      <p><br /></p> 
      <p>P(G留下) = P(G已经存在) * P(G没有被替换)<br /></p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; = P(G已经存在) * (1 - P(G被替换))</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; = P(G已经存在) * (1 - P(第i个元素要替换某个元素) * P(某个元素是G))</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; = (k/i) * (1 - (k/(i+1)) * (1/k))</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; = (k/i) * (1 - (1/(i+1)))</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; = (k/i) * (i/(i+1))</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; = (k/(i+1))</p> 
      <p><br /></p> 
      <p>证毕！</p> 
      <p><br /></p> 
      <p>这个题有很多的变种，比如，</p> 
      <p><br /></p> 
      <p>给你一个长度为N的链表。N很大，但你不知道N有多大。你的任务是从这N个元素中随机取出k个元素。你只能遍历这个链表一次。你的算法必须保证取出的元素恰好有k个，且它们是完全随机的（出现概率均等）。<br /></p> 
      <p><br /></p> 
      <p>从一个不知长度的文件中随机抽出k行。<br /></p> 
      <p><br /></p> 
      <p>从实时的搜索词中随机抽出k个词。</p> 
      <p><span style="color:#454545;font-family:tahoma, helvetica, arial;font-size:14px;line-height:21px;background-color:#ffffff;"><br /></span></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：颠倒乾坤；及忘我之乘积题的分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-05</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-97180-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </p> 
      <p><strong>今日面<span style="font-family:宋体">试题</span>：<span style="font-family:宋体">颠</span>倒乾坤</strong></p> 
      <p><br /></p> 
      <p>在一棵二叉搜索<span style="font-family:宋体">树</span>中，有两个<span style="font-family:宋体">节</span>点<span style="font-family:宋体">颠</span>倒了<span style="font-family:宋体">顺</span>序。要求<span style="font-family:宋体">实现</span>一个算法，在不改<span style="font-family:宋体">变树结</span>构的前提下，恢复正确的二叉搜索<span style="font-family:宋体">树</span>。<span style="font-family:宋体">给</span>出一个空<span style="font-family:宋体">间为</span>O(n)的<span style="font-family:宋体">实现</span>很容易，那<span style="font-family:宋体">该</span>如何<span style="font-family:宋体">给</span>出一个空<span style="font-family:宋体">间</span>O(1)的<span style="font-family:宋体">实现呢？</span></p> 
      <p><span style="font-family:宋体"><br /></span></p> 
      <p><span style="font-family:宋体">============================ </span></p> 
      <p><strong><span style="font-family:宋体">忘我之乘积分析</span></strong></p> 
      <p><span style="font-family:宋体"> </span></p> 
      <p><span style="font-family:宋体">题目：</span></p> 
      <p><span style="font-family:宋体"><br /></span></p> 
      <p>给你一个数组A[1..n]，请你在O(n)的时间里构造一个新的数组B[1..n]，使得B[i]=A[1]*A[2]*...*A[n]/A[i]。你不能使用除法运算。</p> 
      <p><br /></p> 
      <p>分析：</p> 
      <p><br /></p> 
      <p>看到题目，不要紧张，要头脑清晰，看穿面试官的本意，实际上，他是用除法公式，但又要求不用除法来迷惑你。</p> 
      <p><br /></p> 
      <p><span style="font-family:宋体">要求在不使用除法的情况下计算B[i]=A[0]*…*A[n]/A[i]，简单变换一下形式，即可得到B[i]=A[0]*…*A[i-1]*A[i+1]*…*A[n]，一共n-1次乘法。每一个B[i]计算一遍，总的时间复杂度为O(n^2)。不符合题目要求，必须减少乘法的次数。如何减少乘法的次数呢？</span></p> 
      <p><span style="font-family:宋体"> </span></p> 
      <p><span style="font-family:宋体">继续分析，通过上面的变换，我们可以得到B[i]是由两部分相乘得到的：</span></p> 
      <ol style="list-style-type:decimal;"> 
       <li><p>A[0]*…*A[i-1]</p></li> 
       <li><p>A[i+1]*…*A[n]</p></li> 
      </ol> 
      <p>先看第一部分，在<span style="font-family:宋体">计</span>算B[i+1]的<span style="font-family:宋体">时</span>候，是可以利用B[i]的第一部分<span style="font-family:宋体">结</span>果的，只需要<span style="font-family:宋体">乘以A[i]即得到B[i+1]的第一部分。</span></p> 
      <p><span style="font-family:宋体">第二部分同理，计算完A[i+1]*…*A[n]，再计算A[i]*A[i+1]*…*A[n]，只需要乘以A[i]即可。A[i]*A[i+1]*…*A[n]是B[i-1]的第二部分。</span></p> 
      <p><span style="font-family:宋体">由此分析，构建两个新的数组：C和D（为了方便解释，用了两个数组），</span></p> 
      <ol style="list-style-type:decimal;"> 
       <li><p> C[i] = A[0]*…*A[i-1] = C[i-1]*A[i-1]</p></li> 
       <li><p> D[i] = A[i+1]*…*A[n] = D[i+1]*A[i+1}</p></li> 
      </ol> 
      <p>构建C和D都是O(n)的<span style="font-family:宋体">时间</span>复<span style="font-family:宋体">杂</span>度（C从前到后遍<span style="font-family:宋体">历</span>一<span style="font-family:宋体">遍数组，D从后到前遍历一边数组</span>），然后，B[i] = C[i]*D[i]也是O(n)的<span style="font-family:宋体">时间</span>复<span style="font-family:宋体">杂</span>度。整体算法的<span style="font-family:宋体">时间</span>复<span style="font-family:宋体">杂</span>度是O(n)。</p> 
      <p><span style="font-family:宋体"><br /></span></p> 
      <p><span style="font-family:宋体">题</span>目到<span style="font-family:宋体">这</span>解答完<span style="font-family:宋体">毕</span>。</p> 
      <p><br /></p> 
      <p>但是面<span style="font-family:宋体">试</span>官的<span style="font-family:宋体">问题还</span>没有完，他<span style="font-family:宋体">们</span>会<span style="font-family:宋体">继续问</span>，<span style="font-family:宋体">这</span>个解法的空<span style="font-family:宋体">间</span>是O(n)的，能<span style="font-family:宋体">够空间</span>O(1)的情况下<span style="font-family:宋体">实现</span>么？</p> 
      <p><br /></p> 
      <p>首先看看一个只有5个数的数组，A[1]，A[2]，A[3]，A[4]，A[5]。</p> 
      <p><br /></p> 
      <p>首先从头到尾遍历：</p> 
      <p><br /></p> 
      <p>B[1] = A[1]</p> 
      <p>B[2] = B[1]*A[2]</p> 
      <p>B[3] = B[2]*A[3]</p> 
      <p>B[4] = B[3]*A[4]</p> 
      <p>B[5] = B[4], 临时变量 C=A[5]</p> 
      <p><br /></p> 
      <p>然后从尾到头遍历：</p> 
      <p><br /></p> 
      <p>B[4] = B[3]*C, C=C*A[4]</p> 
      <p>B[3] = B[2]*C, C=C*A[3]</p> 
      <p>B[2] = B[1]*C, C=C*A[2]</p> 
      <p>B[1] = C</p> 
      <p><br /></p> 
      <p>通过这个小的例子，我们得到了算法，然后可以推广到任意多的元素。这个是面试中常用的技巧。 </p> 
      <p><br /></p> 
      <p>大家可以自己<span style="font-family:宋体">尝试把算法变成代码。</span></p> 
      <p><br /></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">精妙的Morris二叉树遍历算法</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-06</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-100461-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>今天介绍一种精妙的无堆栈，O(1)空间的二叉树遍历算法：<strong><span style="color:#c00000;">Morris遍历</span></strong>，它是Morris发明的。</p> 
      <p><br /></p> 
      <p>大家都很熟悉用递归和堆栈来实现二叉树的遍历，比如，前序遍历，中序遍历，后序遍历。但Morris 遍历，使用无堆栈，O(1) 空间进行二叉树遍历。它的原理很简单，利用所有叶子结点的右指针，指向其后继结点，组成一个环，在第二次遍历到这个结点时，由于其左子树已经遍历完了，则访问该结点。</p> 
      <p><br /></p> 
      <p><strong><span style="text-decoration:underline;">算法伪码：</span></strong></p> 
      <p><span style="color:#333333;font-family:arial;font-size:14px;line-height:26px;background-color:#ffffff;"><br /></span></p> 
      <p>MorrisInOrder()：</p> 
      <p> &nbsp;while 没有结束</p> 
      <p> &nbsp; &nbsp;如果当前节点没有左后代</p> 
      <p> &nbsp; &nbsp; &nbsp;访问该节点</p> 
      <p> &nbsp; &nbsp; &nbsp;转向右节点</p> 
      <p> &nbsp; &nbsp;否则 </p> 
      <p> &nbsp; &nbsp; &nbsp;找到左后代的最右节点，且使最右节点的右指针指向当前节点</p> 
      <p> &nbsp; &nbsp; &nbsp;转向左后代节点</p> 
      <p><br /></p> 
      <p><strong><span style="text-decoration:underline;">C++实现：</span></strong></p> 
      <p><span style="margin:0px;padding:0px;border:none;color:black;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:#006699;background-color:inherit;font-weight:bold;"><br /></span></span></p> 
      <p><span style="margin:0px;padding:0px;border:none;color:black;background-color:inherit;"><span class="keyword" style="margin:0px;padding:0px;border:none;color:#006699;background-color:inherit;font-weight:bold;">void</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> bst_morris_inorder(</span><span class="keyword" style="margin:0px;padding:0px;border:none;color:#006699;background-color:inherit;font-weight:bold;">struct</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> bst_node *root) &nbsp;</span></span>{ &nbsp;</p> 
      <p><span style="margin:0px;padding:0px;border:none;color:black;background-color:inherit;"> &nbsp; &nbsp;<span class="keyword" style="margin:0px;padding:0px;border:none;color:#006699;background-color:inherit;font-weight:bold;">struct</span><span style="margin:0px;padding:0px;border:none;background-color:inherit;"> bst_node *p = root, *tmp; </span></span></p> 
      <p> &nbsp; &nbsp;while (p) { &nbsp;<br /></p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp;if (p-&gt;left == NULL) { &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;%d &quot;, p-&gt;key); &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p = p-&gt;right; &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp;else { &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmp = p-&gt;left; &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (tmp-&gt;right != NULL &amp;&amp; tmp-&gt;right != p) &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmp = tmp-&gt;right; &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (tmp-&gt;right == NULL) { &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmp-&gt;right = p; &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p = p-&gt;left; &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;else { &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;printf(&quot;%d &quot;, p-&gt;key); &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tmp-&gt;right = NULL; &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;p = p-&gt;right; &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp;</p> 
      <p> &nbsp; &nbsp; &nbsp; &nbsp;} &nbsp;</p> 
      <p> &nbsp; &nbsp;} &nbsp;</p> 
      <p>} &nbsp;</p> 
      <p><br /></p> 
      <p><strong><span style="text-decoration:underline;">Template实现：</span></strong></p> 
      <p><br /></p> 
      <p><img src="pics/689-100461-1.jpg" onerror="" /><br /></p> 
      <p style="color:#333333;font-family:arial;font-size:14px;line-height:26px;background-color:#ffffff;"><strong><span style="text-decoration:underline;"><br /></span></strong></p> 
      <p style="color:#333333;font-family:arial;font-size:14px;line-height:26px;background-color:#ffffff;"><strong><span style="text-decoration:underline;">算法示例：</span></strong></p> 
      <p style="color:#333333;font-family:arial;font-size:14px;line-height:26px;background-color:#ffffff;"><br /></p> 
      <p style="color:#333333;font-family:arial;font-size:14px;line-height:26px;background-color:#ffffff;"><img src="pics/689-100461-2.jpg" style="border:none;max-width:100%;" onerror="" /></p> 
      <p><strong><span style="text-decoration:underline;"><br /></span></strong></p> 
      <p><strong><span style="text-decoration:underline;">思考题：</span></strong></p> 
      <p><br /></p> 
      <p>怎么实现Morris前序遍历？后序遍历？</p> 
      <p><br /></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：乾坤大挪移；及颠倒乾坤的分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-07</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-100810-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面<span style="font-family:宋体">试题</span>：乾坤大挪移</strong><br /></p> 
      <p><span style="font-family:宋体"><br /></span></p> 
      <p><span style="font-family:宋体">给</span>定一个<span style="font-family:宋体">单</span>向<span style="font-family:宋体">链</span>表，<span style="font-family:宋体">设计</span>一个算法<span style="font-family:宋体">实现链</span>表向右旋<span style="font-family:宋体">转</span>k个位置。K是非<span style="font-family:宋体">负</span>的整数。这题看起来简单，可真编程实现有陷阱啰。</p> 
      <p><span style="font-family:宋体"><br /></span></p> 
      <p><span style="font-family:宋体">举</span>例：</p> 
      <p><span style="font-family:宋体">给</span>定：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null 并且k=3，</p> 
      <p><span style="font-family:宋体">则有：4-&gt;5-&gt;6-&gt;1-&gt;2-&gt;3-&gt;null</span></p> 
      <p><span style="font-family:宋体"> </span></p> 
      <p><strong><span style="font-family:宋体">颠倒乾坤分析：</span></strong></p> 
      <p><span style="font-family:宋体"> </span></p> 
      <p><span style="font-family:宋体">题目：</span></p> 
      <p><span style="font-family:宋体"><br /></span></p> 
      <p><span style="font-family:宋体">在一棵二叉搜索树中，有两个节点颠倒了顺序。要求实现一个算法，在不改变树结构的前提下，恢复正确的二叉搜索树。给出一个空间为O(n)的实现很容易，那该如何给出一个空间O(1)的实现呢？</span></p> 
      <p><span style="font-family:宋体"> </span></p> 
      <p><span style="font-family:宋体">分析：</span></p> 
      <p><span style="font-family:宋体"><br /></span></p> 
      <p><span style="font-family:宋体">首席，从一个实例来看，如果两个节点颠倒顺序，会发生什么。</span></p> 
      <p><span style="font-family:宋体"><br /></span></p> 
      <p><span style="font-family:宋体;">这是一颗正常的BST</span></p> 
      <p><span style="font-family:宋体;"><br /></span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 7</span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ \</span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 4 &nbsp; 10</span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ \ &nbsp; &nbsp;\</span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2 &nbsp; 6 &nbsp; 13</span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ \</span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; &nbsp; 1 &nbsp; 3</span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; &nbsp;/</span></p> 
      <p><span style="font-family:宋体;"> &nbsp; &nbsp; &nbsp; 0</span></p> 
      <p><span style="font-family:宋体;"><br /></span></p> 
      <p><span style="font-family:宋体;">看看几种情况：</span></p> 
      <p><span style="font-family:宋体;"><br /></span></p> 
      <p><strong><span style="font-family:宋体;text-decoration:underline;">假设同一枝上的两个节点相邻颠倒了</span></strong><span style="font-family:宋体;">，比如0和1，那么中序遍历后的结果变成</span></p> 
      <p><span style="font-family:宋体;"><br /></span></p> 
      <p><span style="font-family:宋体;"> &nbsp;1，0，2，3，4，6，7，10，13</span></p> 
      <p><span style="font-family:宋体;"><br /></span></p> 
      <p><span style="font-family:宋体;">在这种情况下，显然1和0的顺序不对，那么要交互他们的顺序。</span></p> 
      <p><span style="font-family:宋体;"><br /></span></p> 
      <p><strong><span style="text-decoration:underline;">如果同一枝上不相邻的两个节点</span></strong>，比如，1和4呢？</p> 
      <p><br /></p> 
      <p> &nbsp;0，4，2，3，1，6，7，10，13</p> 
      <p><br /></p> 
      <p>在此情形下，4和2，3和1的顺序不对，这时，需要将前面不对的4，和后面不对的1，交换顺序。</p> 
      <p><br /></p> 
      <p><strong><span style="text-decoration:underline;">如果是左右枝中的元素呢</span></strong>，比如，2和10</p> 
      <p><br /></p> 
      <p> &nbsp;0，1，10，3，4，6，7，2，13</p> 
      <p><br /></p> 
      <p>这时，10和3，7和2的顺序不符，这时，需将前面不符的10，和后面不符的2，交换。</p> 
      <p><br /></p> 
      <p><strong><span style="text-decoration:underline;">再看，如果是根节点参与呢</span></strong>，比如7，和0，</p> 
      <p><br /></p> 
      <p> &nbsp;7，1，2，3，4，6，0，10，13</p> 
      <p><br /></p> 
      <p>这时7和1，6和0，不符从小到大的顺序，同理，需颠倒7和0。</p> 
      <p><br /></p> 
      <p>至此，各种情况我们都考虑了，而且归纳出基本的想法是：</p> 
      <p><br /></p> 
      <p><strong><span style="color:#c00000;">用中序遍历，记录顺序不符的对。如果只有一对元素不符，交换他们；如果有两对不符，那么将第一对中的前一个元素，和第二对中的后一个元素，互换。</span></strong></p> 
      <p><br /></p> 
      <p>如果采用基于递归和堆栈的中序遍历，空间要求会是O(n)，显然不符合题意。那么，我们需要寻求能用O(1)空间进行中序遍历的方法。</p> 
      <p><br /></p> 
      <p>我们需要求助于递推或循环的中序遍历算法，显然，之前我们节目中讲到的Morris算法就是很好的。你可以回复“Morris”到这个微信公众账号“待字闺中”了解Morris算法。除了它，你还能想到别的O(1)空间的中序遍历算法吗？</p> 
      <p><br /></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：快排单链表；及乾坤大挪移的分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-08</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-103504-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面<span style="font-family:宋体">试题</span>：</strong><br /></p> 
      <p><br /></p> 
      <p><span style="font-family:宋体"></span>快排(QuickSort)单向链表(Singly Linked List)。</p> 
      <p><br /></p> 
      <p><span style="font-family:宋体">============================ </span></p> 
      <p><strong>乾坤大挪移的分析</strong></p> 
      <p><br /></p> 
      <p>题目：</p> 
      <p><br /></p> 
      <p>给定一个单向链表，设计一个算法实现链表向右旋转K个位置。K是非负的整数。这题看起来简单，可真编程实现有陷阱啰。</p> 
      <p><br /></p> 
      <p>举例：</p> 
      <p>给定：1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;null 并且K=3，</p> 
      <p>则有：4-&gt;5-&gt;6-&gt;1-&gt;2-&gt;3-&gt;null。 </p> 
      <p><br /></p> 
      <p>分析：</p> 
      <p><br /></p> 
      <p><span style="font-family:宋体">这</span>个<span style="font-family:宋体">题</span>目，看起来是一个相<span style="font-family:宋体">对简单</span>的<span style="font-family:宋体">题</span>目。很多同学在面<span style="font-family:宋体">试</span>的<span style="font-family:宋体">时</span>候，如果看到<span style="font-family:宋体">这</span>个<span style="font-family:宋体">题</span>目，想必会心花怒放。可是，不要高<span style="font-family:宋体">兴</span>得太早，你能<span style="font-family:宋体">够</span>一次通<span style="font-family:宋体">过</span>么？bug free？</p> 
      <p><br /></p> 
      <p>如果<span style="font-family:宋体">这</span>个<span style="font-family:宋体">题</span>目，不能<span style="font-family:宋体">够</span>一次性bug free的完成，考官会很失望，<span style="font-family:宋体">结</span>果可能就是可想而知了。因<span style="font-family:宋体">为</span>，在很多大公司的面<span style="font-family:宋体">试</span>中，例如google，amazon等，往往更加看重的是bug free的能力，所以<span style="font-family:宋体">题</span>目不会很<span style="font-family:宋体">难，但要求bug free的，这正好考察基本功和平时是否有严格训练</span>。那要做到bug free就是至关重要的。</p> 
      <p><br /></p> 
      <p>回到<span style="font-family:宋体">这</span>个<span style="font-family:宋体">题</span>目，我<span style="font-family:宋体">们简单说</span>下<span style="font-family:宋体">这</span>个<span style="font-family:宋体">题</span>目的思路。</p> 
      <p><br /></p> 
      <p>首先看看一些细节，比如，</p> 
      <p><br /></p> 
      <p><span style="font-family:宋体;">1. &nbsp; &nbsp; </span><span style="font-family:宋体;">当K=0时，怎么办？</span></p> 
      <p><span style="font-family:宋体;">2. &nbsp; &nbsp; </span><span style="font-family:宋体;">当K等于链表长度时，怎么办？</span></p> 
      <p><span style="font-family:宋体;">3. &nbsp; &nbsp; </span><span style="font-family:宋体;">当K大于链表长度时，怎么办？</span></p> 
      <p><br /></p> 
      <p>除了K=0，显然，我们需要知道尾指针。那么，第一步，扫描链表得到尾指针tail和链表的长度M。如果M=0，完毕。</p> 
      <p><br /></p> 
      <p>接下来，计算需要移动的步数得到新的头指针之前的节点，就是，(K-1) % M，假设指向这个节点的指针为p。</p> 
      <p><br /></p> 
      <p>那么将tail的next指向head，然后将head指向p的next，然后将p的next指向null。</p> 
      <p><br /></p> 
      <p>这个解法可能需要扫描链表两次。如果我们事先知道链表的长度M的话，也许我们可以用双指<span style="font-family:宋体;">针法：</span></p> 
      <p><span style="font-family:宋体;"><br /></span></p> 
      <p><span style="font-family:宋体;">有两个指针，第一个指针先走 M-(K % M)-1 </span><span style="font-family:宋体;">步，然后第一个和第二个指针一起走，直到第一个指针指到终点，这个时候：</span></p> 
      <p><span style="font-family:宋体;"><br /></span></p> 
      <p><span style="font-family:宋体">1. &nbsp; &nbsp; </span><span style="font-family:宋体">第二个指针所指的next节点设置为新的头节点</span></p> 
      <p><span style="font-family:宋体">2. &nbsp; &nbsp; </span><span style="font-family:宋体">将第二个指针所指节点的next指针指向null</span></p> 
      <p><span style="font-family:宋体">3. &nbsp; &nbsp; </span><span style="font-family:宋体">将第一个指针所指的节点的next指针指向旧的头节点</span></p> 
      <p><br /></p> 
      <p>下面，我们来看一个变化的类似题，以达到举一反三。<br /></p> 
      <p><br /></p> 
      <p>题目是这样的，对于有n个元素的数组 int a[n]={....}；写一个高效算法将数组内容循环左移m位。比如： int a[6] ={1,2,3,4,5,6} ，循环左移3位得到结果{456123}。<br /></p> 
      <p><br /></p> 
      <p>算法的基本思想如下：<br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" /><br /></p> 
      <p>还是用面试中的常用技巧，从一个例子出发。假设有一个包含8个数的数组 int a[8] = {1, 2, 3, 4, 5, 6, 7, 8}; 将其内容循环左移3位，即左移后的结果是{4, 5, 6, 7, 8, 1, 2, 3}。</p> 
      <p><br style="background-color:#ffffff;" />从例子可以看出，将1,2,3移到了数组的最后，从4开始，直到8都往前移动了3个位置。因此我们可设想将1,2,3看成一个整体先和4, 5, 6交换, 再和7, 8交换。</p> 
      <p><br /></p> 
      <p>第一次交换的结果：<br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" /> &nbsp;4, 5, 6, 1, 2, 3, 7, 8<br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" /><br /></p> 
      <p>由于7，8只有两位，因此第二次交换只和1，2，3中的1,2进行交换。结果如下：<br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" /> &nbsp;4, 5, 6, 7, 8, 3, 1, 2。<br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" /><br /></p> 
      <p>可以看出，前五位已经满足了最终结果，只有后3位还不满足最终结果。但是只要将3, 1, 2看成一个子数组，再将这个子数组循环左移1位，即可变成1, 2, 3。 <br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" /><br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" />因此在移动元素时可将要左移的m位看成一个整体（如上例中的1, 2, 3)，依次和它后面的相同位数的数组元素交换，如果后面的元素不足m位，假设为t位，t &lt; m，那么只交换t位，这样，前面的数组元素（前 n - m 个元素一定满足条件）。</p> 
      <p><br style="background-color:#ffffff;" />最后将后面m个元素看成一个子数组，再对其进行循环左移m - n % m位。 <br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" /><br style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;" />算法的时间复杂度为O(n)，应该少于最基本循环算法的O(mn)，空间复杂度为O(1)。<br /></p> 
      <p><span style="font-family:verdana, arial, helvetica, sans-serif;font-size:14px;line-height:25px;background-color:#ffffff;"><br /></span></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">面试题：MapReduce矩阵；及快排单链表之解答</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-09</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-105680-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：</strong></p> 
      <p><br /></p> 
      <p>一个很大的2D矩阵，如果某点的值，由它周围某些点的值决定，例如下一时刻(i,j) 的值取当前时刻它的8邻点的平均，那么怎么用MapReduce来实现。<br /></p> 
      <p><span style="color:#33463f;font-family:arial, helvetica, sans-serif;font-size:13.63636302947998px;line-height:22.999998092651367px;background-color:#fafafa;"><br /></span></p> 
      <p>=====================</p> 
      <p><strong>快排单链表分析</strong></p> 
      <p><br /></p> 
      <p>题目：</p> 
      <p><br /></p> 
      <p>快排(QuickSort)单向链表(Singly Linked List)。<br /></p> 
      <p><br /></p> 
      <p>分析：</p> 
      <p><br /></p> 
      <p>思路和数据的快速排序一样，都需要找到一个pivot元素、或者节点。然后将数组或者单向链表划分为两个部分，然后递归分别快排。</p> 
      <p><br /></p> 
      <p>针对数组进行快排的时候，交换交换不同位置的数值，在分而治之完成之后，数据就是排序好的。那么单向链表是什么样的情况呢？除了交换节点值之外，是否有其他更好的方法呢？可以修改指针，不进行数值交换。这可以获取更高的效率。</p> 
      <p><br /></p> 
      <p>在修改指针的过程中，会产生新的头指针以及尾指针，要记录下来。在partition之后，要将小于pivot的的部分、pivot、以及大于pivot的部分重新串起来成为一个singly linked list。</p> 
      <p><br /></p> 
      <p>在partition时，我们用最后的节点作为pivot。当我们扫描链表时，如果节点值大于pivot，将节点移到尾部之后；如果节点小于，保持不变。<br /></p> 
      <p><br /></p> 
      <p>在递归排序时，我们先调用partition将pivot放到正确的为止并返回pivot，然后，递归左边，递归右边，最后在合成一个单链表。 </p> 
      <p><br /></p> 
      <p>C++实现：</p> 
      <p><br /></p> 
      <div class="line number48 index47 alt1 highlighted"> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *partition(</code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *head, </code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *end,</code> 
       <br /> 
      </div> 
      <div class="line number50 index49 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node **newHead, </code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node **newEnd)</code> 
      </div> 
      <div class="line number51 index50 alt2 highlighted"> 
       <code class="cpp plain">{</code> 
      </div> 
      <div class="line number52 index51 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *pivot = end;</code> 
      </div> 
      <div class="line number53 index52 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *prev = NULL, *cur = head, *tail = pivot;</code> 
      </div> 
      <div class="line number54 index53 alt1 highlighted"></div> 
      <div class="line number55 index54 alt2 highlighted"> 
       <br /> 
      </div> 
      <div class="line number57 index56 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">while</code> 
       <code class="cpp plain">(cur != pivot)</code> 
      </div> 
      <div class="line number58 index57 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp plain">{</code> 
      </div> 
      <div class="line number59 index58 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">if</code> 
       <code class="cpp plain">(cur-&gt;data &lt; pivot-&gt;data)</code> 
      </div> 
      <div class="line number60 index59 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">{</code> 
      </div> 
      <div class="line number61 index60 alt2 highlighted"> 
       <code class="cpp spaces"> </code> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </code> 
       <code class="cpp keyword bold">if</code> 
       <code class="cpp plain">((*newHead) == NULL)</code> 
      </div> 
      <div class="line number64 index63 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">(*newHead) = cur;</code> 
      </div> 
      <div class="line number65 index64 alt2 highlighted"></div> 
      <div class="line number66 index65 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">prev = cur; &nbsp;</code> 
      </div> 
      <div class="line number67 index66 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">cur = cur-&gt;next;</code> 
      </div> 
      <div class="line number68 index67 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">}</code> 
      </div> 
      <div class="line number69 index68 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">else</code> 
      </div> 
      <div class="line number70 index69 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">{</code> 
      </div> 
      <div class="line number71 index70 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">if</code> 
       <code class="cpp plain">(prev)</code> 
       <br /> 
      </div> 
      <div class="line number73 index72 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">prev-&gt;next = cur-&gt;next;</code> 
      </div> 
      <div class="line number74 index73 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">struct</code> 
       <code class="cpp plain">node *tmp = cur-&gt;next;</code> 
      </div> 
      <div class="line number75 index74 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">cur-&gt;next = NULL;</code> 
      </div> 
      <div class="line number76 index75 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">tail-&gt;next = cur;</code> 
      </div> 
      <div class="line number77 index76 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">tail = cur;</code> 
      </div> 
      <div class="line number78 index77 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">cur = tmp;</code> 
      </div> 
      <div class="line number79 index78 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">}</code> 
      </div> 
      <div class="line number80 index79 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp plain">}</code> 
      </div> 
      <div class="line number81 index80 alt2 highlighted"></div> 
      <div class="line number82 index81 alt1 highlighted"> 
       <code class="cpp spaces"> </code> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">if</code> 
       <code class="cpp plain">((*newHead) == NULL)</code> 
      </div> 
      <div class="line number85 index84 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">(*newHead) = pivot;</code> 
      </div> 
      <div class="line number86 index85 alt1 highlighted"></div> 
      <div class="line number87 index86 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp plain">(*newEnd) = tail;</code> 
       <br /> 
      </div> 
      <div class="line number89 index88 alt2 highlighted"> 
      </div> 
      <div class="line number90 index89 alt1 highlighted"> 
       <code class="cpp spaces"> </code> 
       <code class="cpp spaces"> &nbsp; </code> 
       <code class="cpp keyword bold">return </code> 
       <code class="cpp plain">pivot;</code> 
      </div> 
      <div class="line number92 index91 alt1 highlighted"> 
       <code class="cpp plain">}</code> 
      </div> 
      <div class="line number93 index92 alt2 highlighted"></div> 
      <div class="line number94 index93 alt1 highlighted"></div> 
      <div class="line number95 index94 alt2 highlighted"> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *quickSortRecur(</code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *head, </code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *end)</code> 
       <br /> 
      </div> 
      <div class="line number97 index96 alt2 highlighted"> 
       <code class="cpp plain">{</code> 
      </div> 
      <div class="line number98 index97 alt1 highlighted"> 
       <code class="cpp spaces"> </code> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">if</code> 
       <code class="cpp plain">(!head || head == end)</code> 
      </div> 
      <div class="line number100 index99 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">return </code> 
       <code class="cpp plain">head;</code> 
      </div> 
      <div class="line number101 index100 alt2 highlighted"></div> 
      <div class="line number102 index101 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp plain">node *newHead = NULL, *newEnd = NULL;</code> 
      </div> 
      <div class="line number103 index102 alt2 highlighted"></div> 
      <div class="line number104 index103 alt1 highlighted"> 
       <code class="cpp spaces"> </code> 
       <code class="cpp spaces"> &nbsp; </code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *pivot = partition(head, end, &amp;newHead, &amp;newEnd);</code> 
      </div> 
      <div class="line number107 index106 alt2 highlighted"></div> 
      <div class="line number108 index107 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">if</code> 
       <code class="cpp plain">(newHead != pivot)</code> 
       <br /> 
      </div> 
      <div class="line number111 index110 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp plain">{</code> 
      </div> 
      <div class="line number112 index111 alt1 highlighted"> 
       <code class="cpp spaces"> </code> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; </code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node *tmp = newHead;</code> 
      </div> 
      <div class="line number114 index113 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">while</code> 
       <code class="cpp plain">(tmp-&gt;next != pivot)</code> 
      </div> 
      <div class="line number115 index114 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">tmp = tmp-&gt;next;</code> 
      </div> 
      <div class="line number116 index115 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">tmp-&gt;next = NULL;</code> 
      </div> 
      <div class="line number117 index116 alt2 highlighted"></div> 
      <div class="line number118 index117 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">newHead = quickSortRecur(newHead, tmp);</code> 
       <br /> 
      </div> 
      <div class="line number120 index119 alt1 highlighted"> 
      </div> 
      <div class="line number121 index120 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">tmp = getTail(newHead);</code> 
       <br /> 
      </div> 
      <div class="line number123 index122 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp; &nbsp; &nbsp;</code> 
       <code class="cpp plain">tmp-&gt;next = &nbsp;pivot;</code> 
      </div> 
      <div class="line number124 index123 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp plain">}</code> 
      </div> 
      <div class="line number125 index124 alt2 highlighted"></div> 
      <div class="line number126 index125 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp plain">pivot-&gt;next = quickSortRecur(pivot-&gt;next, newEnd);</code> 
       <br /> 
      </div> 
      <div class="line number128 index127 alt1 highlighted"> 
      </div> 
      <div class="line number129 index128 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">return</code> 
       <code class="cpp plain">n ewHead;</code> 
      </div> 
      <div class="line number130 index129 alt1 highlighted"> 
       <code class="cpp plain">}</code> 
      </div> 
      <div class="line number131 index130 alt2 highlighted"></div> 
      <div class="line number132 index131 alt1 highlighted"> 
       <code class="cpp keyword bold">void </code> 
       <code class="cpp plain">quickSort(</code> 
       <code class="cpp keyword bold">struct </code> 
       <code class="cpp plain">node **headRef)</code> 
       <br /> 
      </div> 
      <div class="line number135 index134 alt2 highlighted"> 
       <code class="cpp plain">{</code> 
      </div> 
      <div class="line number136 index135 alt1 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp plain">(*headRef) = quickSortRecur(*headRef, getTail(*headRef));</code> 
      </div> 
      <div class="line number137 index136 alt2 highlighted"> 
       <code class="cpp spaces"> &nbsp; &nbsp;</code> 
       <code class="cpp keyword bold">return</code> 
       <code class="cpp plain">;</code> 
      </div> 
      <div class="line number138 index137 alt1 highlighted"> 
       <code class="cpp plain">}</code> 
      </div> 
      <p><br /></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">面试题：鸡蛋挺住体；及MapReduce矩阵分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-10</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-106640-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>今日面试题：鸡蛋挺住体</p> 
      <p><br /></p> 
      <p>两个鸡蛋：两个软硬程度一样但未知的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事。有座100层的建筑，要你用这两个鸡蛋以最少的次数确定哪一层是鸡蛋可以安全落下的最高位置。可以摔碎两个鸡蛋。<br /></p> 
      <p><span style="color:#33463f;font-family:arial, helvetica, sans-serif;font-size:13.63636302947998px;line-height:22.999998092651367px;background-color:#fafafa;"><br /></span></p> 
      <p>＝＝＝＝＝＝＝＝＝＝＝＝＝＝</p> 
      <p>MapReduce矩阵的分析</p> 
      <p><br /></p> 
      <p>题目：</p> 
      <p><br /></p> 
      <p>一个很大的2D矩阵，如果某点的值，由它周围某些点的值决定，例如下一时刻(i,j) 的值取当前时刻它的8邻点的平均，那么怎么用MapReduce来实现。<br /></p> 
      <p><br /></p> 
      <p>分析：</p> 
      <p><br /></p> 
      <p>首先，让我们以WordCount为例来解释MapReduce是怎么工作的。</p> 
      <p><br /></p> 
      <p>原始状态下，输入–Map — Shuffle — Reduce — 输出</p> 
      <p><br /></p> 
      <p><img class="alignnone size-full wp-image-285" src="pics/689-106640-1.jpg" width="504" height="393" style="word-wrap:break-word;border:0px none;margin:0px;padding:5px;-webkit-box-shadow:#cccccc 0px 0px 3px;box-shadow:#333333 0px 0px 3px;" onerror="" /></p> 
      <p><br /></p> 
      <p>假设有如下的两个文本文件来运行WorkCount程序：</p> 
      <p><br /></p> 
      <p>Hello World Bye World<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hello Hadoop GoodBye Hadoop</p> 
      <p><br /></p> 
      <h2>map数据输入</h2> 
      <p>Hadoop针对文本文件缺省使用LineRecordReader类来实现读取，一行一个key/value对，key取偏移量，value为行内容。</p> 
      <p><br /></p> 
      <p>如下是map1的输入数据：<br style="word-wrap:break-word;margin:0px;padding:0px;" />Key1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Value1<br style="word-wrap:break-word;margin:0px;padding:0px;" />0 &nbsp; &nbsp; &nbsp; &nbsp; Hello World Bye World</p> 
      <p><br /></p> 
      <p>如下是map2的输入数据：<br style="word-wrap:break-word;margin:0px;padding:0px;" />Key1 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Value1<br style="word-wrap:break-word;margin:0px;padding:0px;" />0 &nbsp; &nbsp; &nbsp; &nbsp; Hello Hadoop GoodBye Hadoop</p> 
      <h2><br /></h2> 
      <h2>map输出/combine输入</h2> 
      <p>如下是map1的输出结果<br style="word-wrap:break-word;margin:0px;padding:0px;" />Key2 &nbsp; &nbsp; &nbsp; Value2<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hello &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1<br style="word-wrap:break-word;margin:0px;padding:0px;" />World &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1<br style="word-wrap:break-word;margin:0px;padding:0px;" />Bye &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1<br style="word-wrap:break-word;margin:0px;padding:0px;" />World &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</p> 
      <p>如下是map2的输出结果<br style="word-wrap:break-word;margin:0px;padding:0px;" />Key2 &nbsp; &nbsp; &nbsp; &nbsp;Value2<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hello &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hadoop &nbsp; &nbsp; &nbsp; &nbsp; 1<br style="word-wrap:break-word;margin:0px;padding:0px;" />GoodBye &nbsp; &nbsp; &nbsp;1<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hadoop &nbsp; &nbsp; &nbsp; &nbsp; 1</p> 
      <h2>combine输出</h2> 
      <p>Combiner类实现将相同key的值合并起来，它也是一个Reducer的实现。</p> 
      <p><br /></p> 
      <p>如下是combine1的输出<br style="word-wrap:break-word;margin:0px;padding:0px;" />Key2 &nbsp; &nbsp; &nbsp; &nbsp; Value2<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hello &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1<br style="word-wrap:break-word;margin:0px;padding:0px;" />World &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;2<br style="word-wrap:break-word;margin:0px;padding:0px;" />Bye &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1</p> 
      <p><br /></p> 
      <p>如下是combine2的输出<br style="word-wrap:break-word;margin:0px;padding:0px;" />Key2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Value2<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hello &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hadoop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2<br style="word-wrap:break-word;margin:0px;padding:0px;" />GoodBye &nbsp; &nbsp; &nbsp; &nbsp; 1</p> 
      <p><br /></p> 
      <p>combiner视业务情况来用，减少MAP-&gt;REDUCE的数据传输，提高shuffle速度，就是在map中再做一次reduce操作。combiner使用的合适，可以在满足业务的情况下提升job的速度，如果不合适，则将导致输出的结果不正确。</p> 
      <p><br /></p> 
      <p>对于wordcount来说，value就是一个叠加的数字，所以map一结束就可以进行reduce的value叠加，而不必要等到所有的map结束再去进行reduce的value叠加。</p> 
      <p><br /></p> 
      <h2>reduce输出</h2> 
      <p>Reducer类实现将相同key的值合并起来。</p> 
      <p><br /></p> 
      <p>如下是reduce的输出<br style="word-wrap:break-word;margin:0px;padding:0px;" />Key2 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Value2<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hello &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2<br style="word-wrap:break-word;margin:0px;padding:0px;" />World &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2<br style="word-wrap:break-word;margin:0px;padding:0px;" />Bye &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1<br style="word-wrap:break-word;margin:0px;padding:0px;" />Hadoop &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 2<br style="word-wrap:break-word;margin:0px;padding:0px;" />GoodBye &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 1<br style="word-wrap:break-word;margin:0px;padding:0px;" /><br /></p> 
      <p>即实现了WordCount的处理。</p> 
      <p><br /></p> 
      <p>下图是官方的流程图：</p> 
      <p><img class="alignnone wp-image-286" src="pics/689-106640-2.jpg" width="806" height="374" style="word-wrap:break-word;border:0px none;margin:0px;padding:5px;-webkit-box-shadow:#cccccc 0px 0px 3px;box-shadow:#333333 0px 0px 3px;" onerror="" /></p> 
      <p><br /></p> 
      <p>有了这个基础知识，我们来看如何用MapReduce来解决上述问题。</p> 
      <p><br /></p> 
      <p>以下标对作为map的key，遇到（i，j），生成（i-1，j-1），（i-1，j），etc，然后在reduce时merge相同的key，并计算value。<br /></p> 
      <p><br /></p> 
      <p>当你理解了MapReduce的工作原理，是不是很简单？</p> 
      <p><br /></p> 
      <p><span style="text-decoration:underline;">我们为你的职业未来热身，帮助你提高专业知识和面试经验。在微信加“待字闺中”就能关注我们。有经验分享或投广告请联系liren.chen@gmail.com</span><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：Magic&nbsp;Index；及鸡蛋挺住体分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-12</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-109416-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：</strong></p> 
      <p>给定一个数组A，其中有一个位置被称为Magic Index，含义是：如果i是Magic Index，则A[i] = i。假设A中的元素递增有序、且不重复，请给出方法，找到这个Magic Index。更进一步，当A中允许有重复的元素，该怎么办呢？</p> 
      <p><br /></p> 
      <p>==================================</p> 
      <p><strong>鸡蛋挺住体分析：</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题描述</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">两个软硬程度一样但未知的鸡蛋，它们有可能都在一楼就摔碎，也可能从一百层楼摔下来没事。有座100层的建筑，要你用这两个鸡蛋通过最少的次数确定哪一层是鸡蛋可以安全落下的最高位置。可以摔碎两个鸡蛋</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>方法分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">看到这个题目，最保险的方法就是一层一层试验，但这样只需要一个鸡蛋就可以了。我们现在有两个鸡蛋，完全可以用有更快的方法。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">进一步呢？可能试验的方法是二分查找，例如，第一个鸡蛋再50层扔下，如果碎了，第二个鸡蛋从1-49逐层试验；如果没碎，第一个鸡蛋在75层扔下，如果碎了，第二个鸡蛋从51-74逐层试验…但是，这个方法，很容易悲剧，例如，当正好49层是可以安全落下的，需要尝试50次。比只有一个鸡蛋的情况，效果还要差。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面的分析都是从鸡蛋的角度出发的，想要得到最少的尝试次数，似乎比较难。那如果我们换个角度，从每个高度的楼层来看呢？如果，某个楼层是可以安全落下的，那么最少需要多少次尝试呢？看下面的分析</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">在我们编程解决问题的过程中，如果遇到最优问题的时候，往往可以先尝试一下动态规划的方法。而动态规划的方法，首要的我们要找到构成这个最优问题的最优子问题。所以，下面的分析，我们首先尝试动态规划的方法，如何解决这个问题，这也是典型的程序员的思路；其次，在众多的问题当中，有不少可以直接归结为数学方程式，如果我们能够写出数学方程式，那么，答案将是更加的简洁、美妙。所以，第二个方法，将尝试如果总结出数学方程式。</p> 
      <h5 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text;font-size:1em;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;"><span class="mini-icon mini-icon-link"></span>基于动态规划的方法</h5> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">前面提到，若要采用动态规划的方法，最重要的是要找到子问题。做如下的分析，假设f{n}表示从第n层楼扔下鸡蛋，没有摔碎的最少尝试次数。第一个鸡蛋，可能的落下位置(1,n),第一个鸡蛋从第i层扔下，有两个情况：</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">碎了，第二个鸡蛋，需要从第一层开始试验，有i-1次机会</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">没碎，两个鸡蛋，还有n-i层。这个就是子问题了f{n-i} 所以，当第一个鸡蛋，由第i个位置落下的时候，要尝试的次数为1 + max(i - 1, f{n - i})，那么对于每一个i，尝试次数最少的，就是f{n}的值。状态转移方程如下： f{n} = min(1 + max(i - 1, f{n - 1}) ) 其中: i的范围为(1, n), f{1} = 1 完毕。</p></li> 
      </ol> 
      <h6 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text;color:#777777;font-size:1em;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;"><span class="mini-icon mini-icon-link"></span>推广</h6> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">动态规划的方法，可以推广为n层楼，m个鸡蛋。如下分析： 假设f{n,m}表示n层楼、m个鸡蛋时找到最高楼层的最少尝试次数。当第一个鸡蛋从第i层扔下，如果碎了，还剩m-1个鸡蛋，为确定下面楼层中的安全楼层，还需要f{i-1,m-1}次，找到子问题；不碎的话，上面还有n-i层，还需要f[n-i,m]次，又一个子问题。 状态转移方程如下： f{n, m} = min(1 + max(f{n - 1, m - 1}, f{n - i, m}) ) 其中： i为(1, n), f{i, 1} = 1</p> 
      <h5 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text;font-size:1em;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;"><span class="mini-icon mini-icon-link"></span>基于数学方程的方法</h5> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">假设最少尝试次数为x，那么，第一个鸡蛋必须要从第x层扔下，因为：如果碎了，前面还有x - 1层楼可以尝试，如果没碎，后面还有x-1次机会。如果没碎，第一个鸡蛋，第二次就可以从x +（x - 1）层进行尝试，为什么是加上x - 1，因为，当此时，第一个鸡蛋碎了，第二个鸡蛋还有可以从x+1 到 x + (x - 1) - 1层进行尝试，有x - 2次。如果还没碎，那第一个鸡蛋，第三次从 x + (x - 1) + (x - 2)层尝试。碎或者没碎，都有x - 3次尝试机会，依次类推。那么，x次的最少尝试，可以确定的最高的楼层是多少呢？ x + (x - 1) + (x - 2) + … + 1 = x(x+1) / 2 那反过来问，当最高楼层是100层，最少需要多少次呢？x(x+1)/2 &gt;= 100, 得到x&gt;=14，最少要尝试14次。</p> 
      <p><br /></p> 
      <embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">推荐阅读：从动态规划新手到专家</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-14</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-112761-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><span class="bodyTitle" style="font-size:18px;line-height:1.2;font-weight:bold;color:#333333;font-family:arial, helvetica, verdana, sans-serif;background-color:#ffffff;"></span></p> 
      <h1 style="">动态规划：从新手到专家</h1> 
      <p><span style=""><br /></span></p> 
      <p><span style="">Hawstein翻译</span></p> 
      <p><br /></p> 
      <h2 style="">前言</h2> 
      <p style="">我们遇到的问题中，有很大一部分可以用动态规划(简称DP)来解。 解决这类问题可以很大地提升你的能力与技巧，我会试着帮助你理解如何使用DP来解题。 这篇文章是基于实例展开来讲的，因为干巴巴的理论实在不好理解。</p> 
      <p style="">注意：如果你对于其中某一节已经了解并且不想阅读它，没关系，直接跳过它即可。</p> 
      <h2 style="">简介(入门)</h2> 
      <p style=""><strong>什么是动态规划，我们要如何描述它?</strong></p> 
      <p style="">动态规划算法通常基于一个递推公式及一个或多个初始状态。 当前子问题的解将由上一次子问题的解推出。使用动态规划来解题只需要多项式时间复杂度， 因此它比回溯法、暴力法等要快许多。</p> 
      <p style="">现在让我们通过一个例子来了解一下DP的基本原理。</p> 
      <p style="">首先，我们要找到某个状态的最优解，然后在它的帮助下，找到下一个状态的最优解。</p> 
      <p style=""><strong>“状态”代表什么及如何找到它?</strong></p> 
      <p style="">“状态&quot;用来描述该问题的子问题的解。原文中有两段作者阐述得不太清楚，跳过直接上例子。</p> 
      <p style="">如果我们有面值为1元、3元和5元的硬币若干枚，如何用最少的硬币凑够11元？ (表面上这道题可以用贪心算法，但贪心算法无法保证可以求出解，比如1元换成2元的时候)</p> 
      <p style="">首先我们思考一个问题，如何用最少的硬币凑够i元(i&lt;11)？为什么要这么问呢？ 两个原因：1.当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。 2.这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。</p> 
      <p style="">好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1，怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。</p> 
      <p style="">OK，码了这么多字讲具体的东西，让我们来点抽象的。从以上的文字中， 我们要抽出动态规划里非常重要的两个概念：状态和状态转移方程。</p> 
      <p style="">上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的&quot;状态&quot;， 这个状态是怎么找出来的呢？我在另一篇文章 动态规划之背包问题(一)中写过： 根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。 那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，</p> 
      <p style="">d(i)=min{ d(i-v<sub style=" font-size:10px;line-height:0;vertical-align:baseline;bottom:-0.25em; ">j</sub>)+1 }，其中i-v<sub style=" font-size:10px;line-height:0;vertical-align:baseline;bottom:-0.25em; ">j</sub> &gt;=0，v<sub style=" font-size:10px;line-height:0;vertical-align:baseline;bottom:-0.25em; ">j</sub>表示第j个硬币的面值;</p> 
      <p style="">有了状态和状态转移方程，这个问题基本上也就解决了。当然了，Talk is cheap,show me the code!</p> 
      <p style="">伪代码如下：</p> 
      <p style=""><img src="pics/689-112761-1.jpg" style="max-width:100%;height:auto;border:0px;" onerror="" /></p> 
      <p style="">下图是当i从0到11时的解：</p> 
      <p style=""><img src="pics/689-112761-2.jpg" style="max-width:100%;height:auto;border:0px;" onerror="" /></p> 
      <p style="">从上图可以得出，要凑够11元至少需要3枚硬币。</p> 
      <p style="">此外，通过追踪我们是如何从前一个状态值得到当前状态值的， 可以找到每一次我们用的是什么面值的硬币。比如，从上面的图我们可以看出， 最终结果d(11)=d(10)+1(面值为1)，而d(10)=d(5)+1(面值为5)，最后d(5)=d(0)+1 (面值为5)。所以我们凑够11元最少需要的3枚硬币是：1元、5元、5元。</p> 
      <p style="">注意：原文中这里本来还有一段的，但我反反复复读了几遍， 大概的意思我已经在上文从i=0到i=3的分析中有所体现了。作者本来想讲的通俗一些， 结果没写好，反而更不好懂，所以这段不翻译了。</p> 
      <h2 style="">初级</h2> 
      <p style="">上面讨论了一个非常简单的例子。现在让我们来看看对于更复杂的问题， 如何找到状态之间的转移方式(即找到状态转移方程)。 为此我们要引入一个新词叫递推关系来将状态联系起来(说的还是状态转移方程)</p> 
      <p style="">OK，上例子，看看它是如何工作的。</p> 
      <p style="">一个序列有N个数：A[1],A[2],…,A[N]，求出最长非降子序列的长度。 (讲DP基本都会讲到的一个问题LIS：longest increasing subsequence)</p> 
      <p style="">正如上面我们讲的，面对这样一个问题，我们首先要定义一个“状态”来代表它的子问题， 并且找到它的解。注意，大部分情况下，某个状态只与它前面出现的状态有关， 而独立于后面的状态。</p> 
      <p style="">让我们沿用“入门”一节里那道简单题的思路来一步步找到“状态”和“状态转移方程”。 假如我们考虑求A[1],A[2],…,A[i]的最长非降子序列的长度，其中i&lt;N， 那么上面的问题变成了原问题的一个子问题(问题规模变小了，你可以让i=1,2,3等来分析) 然后我们定义d(i)，表示前i个数中以A[i]结尾的最长非降子序列的长度。OK， 对照“入门”中的简单题，你应该可以估计到这个d(i)就是我们要找的状态。 如果我们把d(1)到d(N)都计算出来，那么最终我们要找的答案就是这里面最大的那个。 状态找到了，下一步找出状态转移方程。</p> 
      <p style="">为了方便理解我们是如何找到状态转移方程的，我先把下面的例子提到前面来讲。 如果我们要求的这N个数的序列是：</p> 
      <pre style=""><code style="">5，3，4，8，6，7 </code></pre> 
      <p style="">根据上面找到的状态，我们可以得到：（下文的最长非降子序列都用LIS表示）</p> 
      <ul style=""> 
       <li><p>前1个数的LIS长度d(1)=1(序列：5)</p></li> 
       <li><p>前2个数的LIS长度d(2)=1(序列：3；3前面没有比3小的)</p></li> 
       <li><p>前3个数的LIS长度d(3)=2(序列：3，4；4前面有个比它小的3，所以d(3)=d(2)+1)</p></li> 
       <li><p>前4个数的LIS长度d(4)=3(序列：3，4，8；8前面比它小的有3个数，所以 d(4)=max{d(1),d(2),d(3)}+1=3)</p></li> 
      </ul> 
      <p style="">OK，分析到这，我觉得状态转移方程已经很明显了，如果我们已经求出了d(1)到d(i-1)， 那么d(i)可以用下面的状态转移方程得到：</p> 
      <pre style=""><code style="">d(i) = max{1, d(j)+1},其中j&lt;i,A[j]&lt;=A[i] </code></pre> 
      <p style="">用大白话解释就是，想要求d(i)，就把i前面的各个子序列中， 最后一个数不大于A[i]的序列长度加1，然后取出最大的长度即为d(i)。 当然了，有可能i前面的各个子序列中最后一个数都大于A[i]，那么d(i)=1， 即它自身成为一个长度为1的子序列。</p> 
      <p style="">分析完了，上图：(第二列表示前i个数中LIS的长度， 第三列表示，LIS中到达当前这个数的上一个数的下标，根据这个可以求出LIS序列)</p> 
      <p style=""><img src="pics/689-112761-3.jpg" style="max-width:100%;height:auto;border:0px;" onerror="" /></p> 
      <p style="">Talk is cheap, show me the code:</p> 
      <div class="highlight" style=""> 
       <pre style=""><code class="cpp" style=""><span class="cp" style="color:#4c8317;">#include &lt;iostream&gt;</span><span class="k" style="color:#0000aa;">using</span><span class="k" style="color:#0000aa;">namespace</span><span class="n">std</span><span class="p">;</span><span class="kt" style="color:#00aaaa;">int</span><span class="nf" style="color:#00aa00;">lis</span><span class="p">(</span><span class="kt" style="color:#00aaaa;">int</span><span class="n">A</span><span class="p">[],</span><span class="kt" style="color:#00aaaa;">int</span><span class="n">n</span><span class="p">){</span><span class="kt" style="color:#00aaaa;">int</span><span class="o">*</span><span class="n">d</span><span class="o">=</span><span class="k" style="color:#0000aa;">new</span><span class="kt" style="color:#00aaaa;">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span><span class="kt" style="color:#00aaaa;">int</span><span class="n">len</span><span class="o">=</span><span class="mi" style="color:#009999;">1</span><span class="p">;</span><span class="k" style="color:#0000aa;">for</span><span class="p">(</span><span class="kt" style="color:#00aaaa;">int</span><span class="n">i</span><span class="o">=</span><span class="mi" style="color:#009999;">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="mi" style="color:#009999;">1</span><span class="p">;</span><span class="k" style="color:#0000aa;">for</span><span class="p">(</span><span class="kt" style="color:#00aaaa;">int</span><span class="n">j</span><span class="o">=</span><span class="mi" style="color:#009999;">0</span><span class="p">;</span><span class="n">j</span><span class="o">&lt;</span><span class="n">i</span><span class="p">;</span><span class="o">++</span><span class="n">j</span><span class="p">)</span><span class="k" style="color:#0000aa;">if</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&amp;&amp;</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi" style="color:#009999;">1</span><span class="o">&gt;</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">+</span><span class="mi" style="color:#009999;">1</span><span class="p">;</span><span class="k" style="color:#0000aa;">if</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="n">len</span><span class="p">)</span><span class="n">len</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">];</span><span class="p">}</span><span class="k" style="color:#0000aa;">delete</span><span class="p">[]</span><span class="n">d</span><span class="p">;</span><span class="k" style="color:#0000aa;">return</span><span class="n">len</span><span class="p">;</span><span class="p">}</span><span class="kt" style="color:#00aaaa;">int</span><span class="nf" style="color:#00aa00;">main</span><span class="p">(){</span><span class="kt" style="color:#00aaaa;">int</span><span class="n">A</span><span class="p">[]</span><span class="o">=</span><span class="p">{</span><span class="mi" style="color:#009999;">5</span><span class="p">,</span><span class="mi" style="color:#009999;">3</span><span class="p">,</span><span class="mi" style="color:#009999;">4</span><span class="p">,</span><span class="mi" style="color:#009999;">8</span><span class="p">,</span><span class="mi" style="color:#009999;">6</span><span class="p">,</span><span class="mi" style="color:#009999;">7</span><span class="p">};</span><span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">lis</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="mi" style="color:#009999;">6</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="n">endl</span><span class="p">;</span><span class="k" style="color:#0000aa;">return</span><span class="mi" style="color:#009999;">0</span><span class="p">;</span><span class="p">}</span></code></pre> 
      </div> 
      <p style="">该算法的时间复杂度是O(n<sup style=" font-size:10px;line-height:0;vertical-align:baseline;top:-0.5em; ">2</sup> )，并不是最优的解法。 还有一种很巧妙的算法可以将时间复杂度降到O(nlogn)，网上已经有各种文章介绍它， 这里就不再赘述。传送门： LIS的O(nlogn)解法。 此题还可以用“排序+LCS”来解，感兴趣的话可自行Google。</p> 
      <p style=""><strong>练习题</strong></p> 
      <p style="">无向图G有N个结点(1&lt;N&lt;=1000)及一些边，每一条边上带有正的权重值。 找到结点1到结点N的最短路径，或者输出不存在这样的路径。</p> 
      <p style="">提示：在每一步中，对于那些没有计算过的结点， 及那些已经计算出从结点1到它的最短路径的结点，如果它们间有边， 则计算从结点1到未计算结点的最短路径。</p> 
      <p style="">尝试解决以下来自topcoder竞赛的问题：</p> 
      <ul style=""> 
       <li><p>ZigZag – 2003 TCCC Semifinals 3</p></li> 
       <li><p>BadNeighbors – 2004 TCCC Round 4</p></li> 
       <li><p>FlowerGarden – 2004 TCCC Round 1</p></li> 
      </ul> 
      <h2 style="">中级</h2> 
      <p style="">接下来，让我们来看看如何解决二维的DP问题。</p> 
      <p style="">平面上有N*M个格子，每个格子中放着一定数量的苹果。你从左上角的格子开始， 每一步只能向下走或是向右走，每次走到一个格子上就把格子里的苹果收集起来， 这样下去，你最多能收集到多少个苹果。</p> 
      <p style="">解这个问题与解其它的DP问题几乎没有什么两样。第一步找到问题的“状态”， 第二步找到“状态转移方程”，然后基本上问题就解决了。</p> 
      <p style="">首先，我们要找到这个问题中的“状态”是什么？我们必须注意到的一点是， 到达一个格子的方式最多只有两种：从左边来的(除了第一列)和从上边来的(除了第一行)。 因此为了求出到达当前格子后最多能收集到多少个苹果， 我们就要先去考察那些能到达当前这个格子的格子，到达它们最多能收集到多少个苹果。 (是不是有点绕，但这句话的本质其实是DP的关键：欲求问题的解，先要去求子问题的解)</p> 
      <p style="">经过上面的分析，很容易可以得出问题的状态和状态转移方程。 状态S[i][j]表示我们走到(i, j)这个格子时，最多能收集到多少个苹果。那么， 状态转移方程如下：</p> 
      <pre style=""><code style="">S[i][j]=A[i][j] + max(S[i-1][j], if i&gt;0 ; S[i][j-1], if j&gt;0) </code></pre> 
      <p style="">其中i代表行，j代表列，下标均从0开始；A[i][j]代表格子(i, j)处的苹果数量。</p> 
      <p style="">S[i][j]有两种计算方式：1.对于每一行，从左向右计算，然后从上到下逐行处理；2. 对于每一列，从上到下计算，然后从左向右逐列处理。 这样做的目的是为了在计算S[i][j]时，S[i-1][j]和S[i][j-1]都已经计算出来了。</p> 
      <p style="">伪代码如下：</p> 
      <p style=""><img src="pics/689-112761-4.jpg" style="max-width:100%;height:auto;border:0px;" onerror="" /></p> 
      <p style="">以下两道题来自topcoder，练习用的。</p> 
      <ul style=""> 
       <li><p>AvoidRoads – 2003 TCO Semifinals 4</p></li> 
       <li><p>ChessMetric – 2003 TCCC Round 4</p></li> 
      </ul> 
      <h2 style="">中高级</h2> 
      <p style="">这一节要讨论的是带有额外条件的DP问题。</p> 
      <p style="">以下的这个问题是个很好的例子。</p> 
      <p style="">无向图G有N个结点，它的边上带有正的权重值。</p> 
      <p style="">你从结点1开始走，并且一开始的时候你身上带有M元钱。如果你经过结点i， 那么你就要花掉S[i]元(可以把这想象为收过路费)。如果你没有足够的钱， 就不能从那个结点经过。在这样的限制条件下，找到从结点1到结点N的最短路径。 或者输出该路径不存在。如果存在多条最短路径，那么输出花钱数量最少的那条。 限制：1&lt;N&lt;=100 ; 0&lt;=M&lt;=100 ; 对于每个i，0&lt;=S[i]&lt;=100；正如我们所看到的， 如果没有额外的限制条件(在结点处要收费，费用不足还不给过)，那么， 这个问题就和经典的迪杰斯特拉问题一样了(找到两结点间的最短路径)。 在经典的迪杰斯特拉问题中， 我们使用一个一维数组来保存从开始结点到每个结点的最短路径的长度， 即M[i]表示从开始结点到结点i的最短路径的长度。然而在这个问题中， 我们还要保存我们身上剩余多少钱这个信息。因此，很自然的， 我们将一维数组扩展为二维数组。M[i][j]表示从开始结点到结点i的最短路径长度， 且剩余j元。通过这种方式，我们将这个问题规约到原始的路径寻找问题。 在每一步中，对于已经找到的最短路径，我们找到它所能到达的下一个未标记状态(i,j)， 将它标记为已访问(之后不再访问这个结点)，并且在能到达这个结点的各个最短路径中， 找到加上当前边权重值后最小值对应的路径，即为该结点的最短路径。 (写起来真是绕，建议画个图就会明了很多)。不断重复上面的步骤， 直到所有的结点都访问到为止(这里的访问并不是要求我们要经过它， 比如有个结点收费很高，你没有足够的钱去经过它，但你已经访问过它) 最后Min[N-1][j]中的最小值即是问题的答案(如果有多个最小值， 即有多条最短路径，那么选择j最大的那条路径，即，使你剩余钱数最多的最短路径)。</p> 
      <p style="">伪代码：</p> 
      <p style=""><img src="pics/689-112761-5.jpg" style="max-width:100%;height:auto;border:0px;" onerror="" /></p> 
      <p style="">下面有几道topcoder上的题以供练习：</p> 
      <ul style=""> 
       <li><p>Jewelry – 2003 TCO Online Round 4</p></li> 
       <li><p>StripePainter – SRM 150 Div 1</p></li> 
       <li><p>QuickSums – SRM 197 Div 2</p></li> 
       <li><p>ShortPalindromes – SRM 165 Div 2</p></li> 
      </ul> 
      <h2 style="">高级</h2> 
      <p style="">以下问题需要仔细的揣摩才能将其规约为可用DP解的问题。</p> 
      <p style="">问题：StarAdventure – SRM 208 Div 1:</p> 
      <p style="">给定一个M行N列的矩阵(M*N个格子)，每个格子中放着一定数量的苹果。 你从左上角的格子开始，只能向下或向右走，目的地是右下角的格子。 你每走过一个格子，就把格子上的苹果都收集起来。然后你从右下角走回左上角的格子， 每次只能向左或是向上走，同样的，走过一个格子就把里面的苹果都收集起来。 最后，你再一次从左上角走到右下角，每过一个格子同样要收集起里面的苹果 (如果格子里的苹果数为0，就不用收集)。求你最多能收集到多少苹果。</p> 
      <p style="">注意：当你经过一个格子时，你要一次性把格子里的苹果都拿走。</p> 
      <p style="">限制条件：1 &lt; N, M &lt;= 50；每个格子里的苹果数量是0到1000(包含0和1000)。</p> 
      <p style="">如果我们只需要从左上角的格子走到右下角的格子一次，并且收集最大数量的苹果， 那么问题就退化为“中级”一节里的那个问题。将这里的问题规约为“中级”里的简单题， 这样一来会比较好解。让我们来分析一下这个问题，要如何规约或是修改才能用上DP。 首先，对于第二次从右下角走到左上角得出的这条路径， 我们可以将它视为从左上角走到右下角得出的路径，没有任何的差别。 (即从B走到A的最优路径和从A走到B的最优路径是一样的)通过这种方式， 我们得到了三条从顶走到底的路径。对于这一点的理解可以稍微减小问题的难度。 于是，我们可以将这3条路径记为左，中，右路径。对于两条相交路径(如下图)：</p> 
      <p style=""><img src="pics/689-112761-6.jpg" style="max-width:100%;height:auto;border:0px;" onerror="" /></p> 
      <p style="">在不影响结果的情况下，我们可以将它们视为两条不相交的路径：</p> 
      <p style=""><img src="pics/689-112761-7.jpg" style="max-width:100%;height:auto;border:0px;" onerror="" /></p> 
      <p style="">这样一来，我们将得到左，中，右3条路径。此外，如果我们要得到最优解， 路径之间不能相交(除了左上角和右下角必然会相交的格子)。因此对于每一行y( 除了第一行和最后一行)，三条路径对应的x坐标要满足：x1[y] &lt; x2[y] &lt; x3[y]。 经过这一步的分析，问题的DP解法就进一步地清晰了。让我们考虑行y， 对于每一个x1[y-1]，x2[y-1]和x3[y-1]，我们已经找到了能收集到最多苹果数量的路径。 根据它们，我们能求出行y的最优解。现在我们要做的就是找到从一行移动到下一行的方式。 令Max[i][j][k]表示到第y-1行为止收集到苹果的最大数量， 其中3条路径分别止于第i,j,k列。对于下一行y，对每个Max[i][j][k] 都加上格子(y,i)，(y,j)和(y,k)内的苹果数量。因此，每一步我们都向下移动。 我们做了这一步移动之后，还要考虑到，一条路径是有可能向右移动的。 (对于每一个格子，我们有可能是从它上面向下移动到它， 也可能是从它左边向右移动到它)。为了保证3条路径互不相交， 我们首先要考虑左边的路径向右移动的情况，然后是中间，最后是右边的路径。 为了更好的理解，让我们来考虑左边的路径向右移动的情况，对于每一个可能的j,k对(j&lt;k)， 对每个i(i&lt;j)，考虑从位置(i-1,j,k)移动到位置(i,j,k)。处理完左边的路径， 再处理中间的路径，最后处理右边的路径。方法都差不多。</p> 
      <p style="">用于练习的topcoder题目：</p> 
      <ul style=""> 
       <li><p>MiniPaint – SRM 178 Div 1</p></li> 
      </ul> 
      <h2 style="">其它</h2> 
      <p style="">当阅读一个题目并且开始尝试解决它时，首先看一下它的限制。 如果要求在多项式时间内解决，那么该问题就很可能要用DP来解。遇到这种情况， 最重要的就是找到问题的“状态”和“状态转移方程”。(状态不是随便定义的， 一般定义完状态，你要找到当前状态是如何从前面的状态得到的， 即找到状态转移方程)如果看起来是个DP问题，但你却无法定义出状态， 那么试着将问题规约到一个已知的DP问题(正如“高级”一节中的例子一样)。</p> 
      <p style=""><br /></p> 
      <p style="">英文原文：</p> 
      <p style=""><span style="line-height:23px;">http://community.topcoder.com/tc?module=Static&amp;d1=tutorials&amp;d2=dynProg</span></p> 
      <div> 
       <span style=""><br /></span> 
      </div> 
      <p style=""><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：相差甚远；及Magic&nbsp;Index分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-15</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-113731-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：相差甚远</strong></p> 
      <p>给定一个数组，我们可以找到两个不相交的、并且是连续的子数组A和B，A中的数字和为sum(A), B中的元素和为sum(B)。找到这样的A和B，满足sum(A) - sum(B)的绝对值是最大的。</p> 
      <p>例如：</p> 
      <p>[2, -1 -2, 1, -4, 2, 8]划分为A=[-1, -2, 1, -4], B=[2, 8]， 最大的值为16。</p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><strong>Magic Index 分析：</strong></p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">给定一个数组A，其中有一个位置被称为Magic Index，含义是：如果i是Magic Index，则A[i] = i。假设A中的元素递增有序、且不重复，请给出方法，找到这个Magic Index。更进一步，当A中允许有重复的元素，该怎么办呢？</p> 
      <h4 style=" text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text; font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif; "><span class="mini-icon mini-icon-link"></span>没有重复元素的情况</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">一些同学在遇到这个题目的时候，往往会觉得比较简单。扫描一遍，不就ok了么？O(n)的。很简单呀。可是，大家要注意到，还有一个条件没有用：A中的元素是有序递增的。这个条件，并不是放在这里迷惑大家的，而是有更大的作用的。这个时候，该如何想呢？O(n)不是最好的方法，更好的是什么呢？怎么利用数组有序呢？在有序的数组中查找一个满足特定元素的条件，我们通常会想到二分查找。 我们来回顾一下二分查找，对于要查找的目标t，我们首先与数组中间的元素比较，如果t大于中间的元素，则在右半部分继续查找；如果t小于中间的元素，则在左半部分，继续查找。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">那么，我们的题目能够利用上述的思想呢？我们来看一个具体的例子：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">-10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">-5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">12</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">mid=3，A[mid] = 2，即A[mid] &lt; mid。接下来，我们应该在哪一边查找呢？我们知道数组的元素是递增有序，且不重复的，也就是说，在A[mid]左边的元素，比A[mid]都要小，没有重复，意味着什么呢？每向左移动一位，至少减1。所以，在mid左边，不可能有一个i，A[i]=i的。如果有，根据前面的分析，我们知道A[mid] - A[i] &gt;= mid - i, 如果A[i] = i，则，A[mid] &gt;= mid, 这与事实A[mid] &lt; mid相悖。所以，接下来，只能在右边进行查找。代码与二分查找也很像。</p> 
      <h4 style=" text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text; font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif; "><span class="mini-icon mini-icon-link"></span>有重复元素的情况</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果数组A中，有重复元素，是什么情况呢？经过前面的分析，我们知道，是否有重复的主要差别在，数组的元素从右到左进行递减，每次不一定至少是1了，有可能是0了。让我们直观的看一下影响吧。</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">-10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">12</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">看上面的数组，同样A[mid] &lt; mid。我们应该继续查右边么？显然，右边并不存在Magic Index。查找右边，就会找不到这样的Magic Index。此时，应该如何处理呢？我们无法确定，Magic Index是在左边，还是在右边了。那就两边都递归进行处理吧。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">在这里还有一个小技巧，我们就是要分别递归处理[0, mid - 1]和[mid + 1， end]（end是数组长度-1）么？我们看一个具体的例子：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">-10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">12</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">13</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">20</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个例子，当我们进行左半部分递归处理的时候，需要考虑的范围是[0, 3]。可实际上，我们只需要考虑[0, 2]。原因是，数组元素在mid=4的左边的值都要小于或者等于A[mid]=2，所以最大的一个有可能是Magic Index的，就是index为A[mid]的情况。所以，这时右边的边界应该是min(mid - 1, A[mid])。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">那么，右边的情况呢？如下例子：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">-10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">12</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">13</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">20</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">此时，要在右半部分进行查找，范围一般是[5, 8]。但是，由于数组有序，后面的值，一定是大于等于A[mid]=9的。所以，有可能是Magic Index的最小Index是9，也就是说右边的递归，应该是从索引为9的位置开始。此例，就意味着，无需处理右边了。</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：须弥之镜；及相差甚远分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-16</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-115425-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：一个都不能少</strong></p> 
      <p><strong><br /></strong></p> 
      <p>有k个有序的数组，请找到一个最小的数字范围。使得这k个有序数组中，每个数组都至少有一个数字在该范围中。</p> 
      <p>例如：</p> 
      <p><br /></p> 
      <p>1: 4, 10, 15, 24, 26</p> 
      <p>2: 0, 9, 12, 20</p> 
      <p>3: 5, 18, 22, 30</p> 
      <p><br /></p> 
      <p>所得最小范围为[20,24]，其中，20在2中，22在3中，24在1中。</p> 
      <p><br /></p> 
      <p>=============================</p> 
      <p><strong>相差甚远面试题分析<embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">给定一个数组，我们可以找到两个不相交的、并且是连续的子数组A和B，A中的数字和为sum(A), B中的元素和为sum(B)。找到这样的A和B，满足sum(A) - sum(B)的绝对值是最大的。 例如：[2, -1 -2, 1, -4, 2, 8]划分为A=[-1, -2, 1, -4], B=[2, 8]， 最大的值为16</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果没有比较丰富的经验，这个题目咋一看，有一种不明觉厉的感觉。但只要逐层分析，就可以看到，其实只要分析两层就可以了。首先我们来看看题目有哪些要点（明确题意，有不清楚的，一定要澄清。）：</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">子数组是不相交的</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">子数组是连续的，这个有点多余，但还是强调一下得好</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">然后题目的要求是，差的绝对值最大。那我们自然而然能够想到：找到的两个不相交的子数组，一个值要很小，一个值要很大。这样才能够保证差的绝对值最大。那如何找到这样的数组呢？我们从不相交的这个条件入手。看题目中例子（从简单的例子出发，发现解决方案，是面试中常用技巧。切记！）：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">-1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">-2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">看上面的表格，如果两个子数组不想交，我们有六个位置，作为划分的备选，0和1之间、1和2之间、2和3之间，...，直到5和6之间。这六个位置，都可以将数组划分为两部分。我们设定，数组长度为n，i将数据划分为两部分分别为 [0,i-1]和[i,n-1]。都是两边包含的集合。i是从1到n-1的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">对于任意的i，我们得到了两部分[0, i-1]和[i, n-1]。接下来，就是在这两部分中，找到一个和最小的子数组A，以及和最大的子数组B。那么A-B的绝对值，就是i这个划分下，满足条件的两个数组的差的最大值。对于，所有的i而言，这个绝对值最大时的A和B就是我们要找到的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">思路通顺了，接下来要确定，找到在i处划分，和最大以及和最小的子数组的方法。这里，就要使用到，我们前几天分享的动态规划的思想。那篇文章，大家好好阅读分析了么。相信一定能够给大家带来很多的启发。回到这个题目，我们单独的考虑，给定一个数组，求和最大的子数组以及和最小的子数组。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">先分析和最大的子数组，这个问题，是比较经典的问题了，但是我们这里要处理的是，求得每一个i左侧的最大连续子数组。作如下分析，假设数组为X, 假设max_until[i]表示，以i位置结尾的连续子数组的最大和。max_until[i]和max_until[i-1]是什么关系呢？</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果X[i] + max_until[i - 1] &gt; max_until[i - 1] and X[i] + max_until[i - 1] &gt; X[i]。那么X[i]应该加入到连续子数组中，max_until[i] = max_until[i-1] + X[i].</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">否则max_until[i] = X[i]，连续子数组只有一个元素。</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">但是，我们要的并不是以i结尾的子数组，尽管给的例子中是这样的，我们要的是i之前的所有连续子数组中，和最大的。并不一定包括i。要如何处理呢？我们再开辟子数组max_left[i]表示[0,i]中连续子数组的最大值。那这个值要如何求得呢？我们在遍历数组，求得max_until[i]的时候，max_left[i]只需要在max_until[i]和此前保存的最大值里取最大的即可。也就是一次遍历，就可以完全求得max_until数组和max_left数组。同理可以求得min_until以及min_left数组。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这是处理的划分的左半部分。那么右半部分呢？</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">右半部分的思路也是一样的，只不过，我们在遍历数组的时候，需要从右向左进行遍历。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">总结整个方法的流程如下：</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">从左向右遍历数组，计算max_left和min_left数组，O(n)时间复杂度</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">从右向左遍历数组，计算max_right和min_right数组，O(n)时间复杂度</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">然后对于每一个i，i从1开始到n-1,计算max_left[i - 1] - min_right[i], max_right[i] - min_left[i - 1]。选取绝对值最大的。</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">方法的整体空间复杂度为O(n),时间复杂度也是O(n)。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;-webkit-font-smoothing:antialiased;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>总结</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个题目，其实是采用动态规划解决最大连续子数组和问题的变种，又多了一层思考。面试者在遇到一个新的题目的时候，不要慌乱，对问题进行仔细分析，进而对其进行分解，分解为自己熟悉的问题。那问题也就解决了。</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：又见Google搜索之星；及须弥之境分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-17</span><a href="/account/daiziguizhongren" id="post-user" class="activity-meta" onclick=""><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-117305-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" />今日面试题：又见Google搜索之星</strong><br /></p> 
      <p><strong><br /></strong></p> 
      <p>给定一批查询日志，数量为n。其中，有的查询出现了多于n/3次，请在线性时间内，找到所有满足条件的查询。<br /></p> 
      <p><br /></p> 
      <p>===========================</p> 
      <p><br /></p> 
      <h3 style="text-rendering:optimizelegibility;margin-top:0px !important;padding:0px;line-height:1.7;cursor:text;font-size:1.5em;font-family:helvetica, arial, freesans, clean, sans-serif;margin-right:0px;margin-bottom:15px;margin-left:0px;">须弥之镜面试题分析</h3> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">有k个有序的数组，请找到一个最小的数字范围。使得这k个有序数组中，每个数组都至少有一个数字在该范围中。 例如：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">1: 4, 10, 15, 24, 26 </p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">2: 0, 9, 12, 20 </p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">3: 5, 18, 22, 30</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">所得最小范围为[20,24]，其中，20在2中，22在3中，24在1中。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">遇到一个题目，我们要通过分析找到突破口。这个题目的突破口是什么呢？其实比较好找。就是“有序”，而且k个数组都是有序的，那么我们脑海里就会浮现出各种可以尝试的方法：可以对有序的数组进行二分查找、可以对多个有序的数组进行归并排序，生成一个有序的数组等等。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">那这个题目选择哪个方法继续尝试呢？那我们再分析一下要解决的问题。找到一个最小的范围，每一个有序数组中，都至少有一个元素在这个范围中。找到这样一个范围并不难，可是如何确定最小的范围呢？最终得到的最小的范围，至少包含三个元素，并且在所有数组整体的排序中，是相邻的。假设最小范围是[a, b, c]，a &lt; b &lt; c。 c-a是最小的。并且，a，b，c来自不同的有序数组。还有一种情况是[a,b,d,c]，a,b,c不是紧邻的，中间有一个d即： a&lt; d &lt; c。这时，d只能是来自b所在的数组，如下分析：</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">d来自a所在的数组，那么应有更短的范围c - d</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">d来自c所在的数组，那么应有更短的范围d - a</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">d来自b所在的数组，范围大小是不变的，就是无论是考虑d，还是考虑b。都没有影响。</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">从上面的分析，我们得出，只需要考虑在最终的排序中，考虑邻近的、并且来自不同有序数组的元素，作为备选的范围。那么该怎么样做到只考虑临近的、并且来自不同的有序数组的元素呢？这里就用到了归并排序的思想。以原题中的例子为例，假设有三个指针指，p1,p2,p3，分别指向三个数组的第一个元素：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">步骤</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">指针当前值</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">最大值</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">最小值</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">min_range_value</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">移动指针</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4,0,5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4,9,5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10,9,5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10,9,18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10,12,18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">15,12,18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">12</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">15,20,18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">20</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">15</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">24,20,18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">24</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">18</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">24,20,22</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">24</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">20</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">end</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">结束是因为第二个数组已经没有元素可以再进行遍历了。最终得到最小的min_range_value为4，即为题目例子的答案。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面这个方法，通过归并排序的思想，确保每次都是k个来自不同的数组的元素进行比较，得到最大值、最小值。就可以得到一个范围，包含了所有数组中的数字。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个题的著名变种是从网页中产生包含所有查询词的最小的摘要。如果你 面过Google，你应该听说过这题。</p> 
      <p><br /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：熟悉的陌生人；及又见Google搜索之星分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-18</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="pics/689-118112-0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：熟悉的陌生人</strong></p> 
      <p>大家都知道facebook用户都是双向的好友，a是b的好友，那么b一定是a的好友，现在给定一个用户列表，其中有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，并且每组内的用户，互相都不是好友。如果能，请给出这个划分。</p> 
      <p>例子1：</p> 
      <p>用户：{1, 2, 3}<br /></p> 
      <p>好友关系：1-2， 2-3</p> 
      <p>划分：{1,3} {2}</p> 
      <p><br /></p> 
      <p>例子2：</p> 
      <p>用户{1,2,3,4}</p> 
      <p>好友关系：1-2， 2-3， 3-4，4-1</p> 
      <p>划分：{1, 3}{2, 4}</p> 
      <p><br /></p> 
      <p>==================================</p> 
      <p><br /></p> 
      <p><strong>又见Google之星分析</strong></p> 
      <p><br /></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">给定一批查询日志，数量为n。其中，有的查询出现了多于n/3次，请在线性时间内，找到所有满足条件的查询。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果初次遇到这个问题，我们会有什么样的思路呢？</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">采用hashmap进行计数，O(n)的空间，O(n)的时间</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">进行排序，O(nlogn)</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">快速选择算法，这个也可以做到O(n)的时间。</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">但是，如果面试官进一步限制了可以采用方法的范围：不允许使用上述方法，该如何处理呢？</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们在之前的面试题目中，遇到过类似的一个问题：那次的查询出现的次数是一半以上。大家还记得，我们的解法么？道理很简单，但解法是很巧妙的，当我们每次去掉两个不相同的查询，那最终剩下的查询，就是我们要找的查询——这个查询的出现次数，占了一半以上。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">那如果是多于n/3次呢？更一般的情况下，如果是多于n/m次呢？道理完全一样的：我们每次去掉m个不同的查询，那最终剩下的查询，就是我们要找的备选的。道理很简单，可是要如何实现呢？之前的题目，是比较简单就能够实现每次去掉两个不同的查询的，更一般的情况下，如何每次去掉m个不同的元素呢？</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">下面我们会介绍一种实现方法，核心的原理就是：每次去掉m个不同的查询。第一个方法，是很有趣的一个方法，相信能够给大家以启发。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>一种有趣的实现</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">有一个经典的游戏，叫做俄罗斯方块。想必很多同学都玩过的吧，俄罗斯方块，有不同颜色、不同形状的方块，从上往下落，如果砌满一行，这一行就会消失。一般列数都是固定的，在玩儿的过程中不会变化。这里要讲的一个实现，就是从俄罗斯方块这个游戏启发而来的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们申请一个大小为m的map，开始遍历查询日志，如果：</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">遇到一个不在map中的查询，则插入map中，并且将值设置为1（相当于新落下一个方块）</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">遇到一个在map中的查询，则将map中，该查询对应的值加1（相当于在已有的方块上又多加了一个）</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">当map中的查询个数等于m时，则对map中所有查询的值减一（相当于砌满了一层，就会消掉）。直到遍历完毕查询日志，map中还存在的查询，就是我们要找的查询的备选。我们看下面的具体的例子：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">查询日志为：4 3 3 2 1 2 3 4 4 7 且m=5</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上述方法的步骤如下：</p> 
      <ol style="margin:15px 0px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;padding-left:30px;"> 
       <li><p>当 4 3 3 落入到map中的时候，map的形状如下：</p> 
        <table style="border-spacing:0px;font-size:inherit;margin:15px 0px;width:694px;overflow:auto;display:block;" class=" noBorderTable"> 
         <tbody> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
          </tr> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
          </tr> 
         </tbody> 
        </table><p><br /></p></li> 
       <li><p>当 2 1 2 3 落入到map中的时候，map形状如下：</p> 
        <table style="border-spacing:0px;font-size:inherit;margin:15px 0px;width:694px;overflow:auto;display:block;" class=" noBorderTable"> 
         <tbody> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
          </tr> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
          </tr> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
          </tr> 
         </tbody> 
        </table><p><br /></p></li> 
       <li><p>当 4 4 落入到map中的时候，map的形状如下：</p> 
        <table style="border-spacing:0px;font-size:inherit;margin:15px 0px;width:694px;overflow:auto;display:block;" class=" noBorderTable"> 
         <tbody> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
          </tr> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
          </tr> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
          </tr> 
         </tbody> 
        </table><p><br /></p></li> 
       <li><p style="margin-top:15px;margin-bottom:15px;">当 7 落入到map中的时候，map形状如下：</p> 
        <table style="border-spacing:0px;font-size:inherit;margin:15px 0px;width:694px;overflow:auto;display:block;" class=" noBorderTable"> 
         <tbody> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
          </tr> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
          </tr> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
          </tr> 
         </tbody> 
        </table><p style="margin-top:15px;margin-bottom:15px;">此时，map的大小=5，可以消除一行了。</p></li> 
       <li><p style="margin-top:15px;margin-bottom:15px;">消除之后如下图：</p> 
        <table style="border-spacing:0px;font-size:inherit;margin:15px 0px;width:694px;overflow:auto;display:block;" class=" noBorderTable"> 
         <tbody> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
          </tr> 
          <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
           <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
          </tr> 
         </tbody> 
        </table><p style="margin-top:15px;margin-bottom:15px;">此时剩下三个查询，但不都是满足条件的查询，需要逐个验证。O(n)即可。</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">分析上述方法的空间复杂度为O(m).当m=3时，就可以认为是常数空间。那么时间复杂度呢？切要看map是如何实现的，如果是基于树的，整个的时间复杂度O(nlogm)，m=3时，可以认为是O(n)的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
      <p><br /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：构造最大数；及熟悉的陌生人分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-19</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/119599/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：构造最大数</strong></p> 
      <p>给定只包含正数的数组，给出一个方法，将数组中的数拼接起来，得到的数，是最大的。</p> 
      <p>例如：</p> 
      <p>[4, 94, 9, 14, 1] 拼接之后，所得最大数为：9944141<br /></p> 
      <p><br /></p> 
      <p>===============================<embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><strong>熟悉的陌生人分析</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">大家都知道facebook用户都是双向的好友，a是b的好友，那么b一定是a的好友，现在给定一个用户列表，其中有些用户是好友，有些不是，请判断，这些用户是否可以划分为两组，并且每组内的用户，互相都不是好友。如果能，请给出这个划分。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">例子1： 用户：{1, 2, 3} 好友关系：1-2， 2-3 划分：{1,3} {2}</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">例子2： 用户{1,2,3,4} 好友关系：1-2， 2-3， 3-4，4-1 划分：{1, 3}{2, 4}</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">有很多面试题比较直接，看到题目，面试者很自然的就想到用什么方法，这时候，往往面试官要的是bug-free的code；还有一些问题，不那么直接，那就是考察，应试者的分析问题、分解问题的能力。往往是一个相对复杂的问题，分解为我们见过的、相对简单的问题；还有一类问题，从实际当中来，这就需要有建模的能力，也可以说是把问题抽象出来的能力，然后才是分解成小的问题等。这样的题目，能够全面的考察应试者的能力。例如今天的面试题。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">今天的面试题来自facebook的实际问题。像在我们国内，有很多同学在做新浪微博的数据挖掘，好友推荐、关系预测、圈子发现、转发分析、影响力分析等等，这些都是很实际、很有用的问题，每一个问题，都可以作为一个值得深入探讨的面试题。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">相对而言，今天的面试题目比较简单。因为建模的部分，已经在题目中给出了。稍想一下，图分割的问题。facebook的好友关系是双向的，意味着是无向图（新浪微博，twitter都是有向图）。然后，要把图划分为两组，这两组满足什么条件呢？组内没有边，组间有边。这显然就是一个二分图。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">那问题很明显了，就是facebook好友关系构成的图，是否是一个二分图？如果是，请找到这个划分。就是二分图判断+找到一个划分即可。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">根据二分图的特性，一条边上的两个点，肯定是属于不同的组。如果它们出现在同一个组中，肯定就不是二分图了。怎么判断，一条边上的两个点，分属于不同的组呢？我们需要遍历图，如果找到一条边，两个节点，都在同一组，则不是二分图；如果图遍历完成之后，没有找到这样的边，则是二分图。我们在遍历的过程中，我们需要区分，一条边的两个节点分属于不同的组，这里我们用到了染色法。核心思想如下：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">从某一个点开始，将这个节点染色为白色，并且开始广度优先遍历，找到与其相邻的节点，如果是二分图，相邻节点的颜色都应该不同。如果是黑色，则不变；如果是无色，则染成黑色；如果是白色，也就是同色，程序退出。当图遍历完毕时，没有相邻节点同色的，则是二分图，标记为白色和黑色的两组就是一个划分。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">来看两个例子，第一个图中的例子2：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">步骤</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">遍历节点</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">相邻节点</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">队列</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1：白</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2：黑，4：黑</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2，4</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2：黑</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1：白，3：白</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4，3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4：黑</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1：白，3：白</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3：白</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2：黑，4：黑</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">空</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">队列空，结束遍历。找到划分{1,3}白{2,4}黑。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">再看一个不是二分图的例子： 用户{1，2，3，4} 关系：1-2，1-3，1-4，2-3，3-4.</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">判断步骤如下：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">步骤</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">遍历节点</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">相邻节点</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">队列</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1：白</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2：黑，3：黑，4：黑</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2，3，4</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2：黑</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1：白，3：白</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3，4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">发现3矛盾了，则上面的关系，不够成二分图。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：相伴一生；及构造最大数分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-20</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/120936/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：相伴一生</strong></p> 
      <p><strong><br /></strong></p> 
      <p>给定一个数组，数组中只包含0和1。请找到一个最长的子序列，其中0和1的数量是相同的。</p> 
      <p>例1：10101010 结果就是其本身。</p> 
      <p>例2：1101000 &nbsp; &nbsp;结果是110100</p> 
      <p>请大家展开自己的思路。<br /></p> 
      <p><br /></p> 
      <p>=========================<embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><strong>构造最大数分析</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">给定只包含正数的数组，给出一个方法，将数组中的数拼接起来，得到的数，是最大的。 例如： [4, 94, 9, 14, 1] 拼接之后，所得最大数为：9944141</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">初看这个题目，肯定是要排序的。按照从左到右的第一个位置的数字，从大到小进行排序。如题目中的例子，结果是：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">94</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">14</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">直接拼接为9494141显然不是最大的。那很自然的想法，就是考虑从左到右第二位的数字。考虑9和94的第二个数字，9没有第二个数字如何处理？这里有一个小技巧，就是用9补位。为什么用9呢？994&gt;949，因为4&lt;9，所以，拼接的方式 9 + “” + 94. 为了方便我们排序，所以用9进行了补位。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">再看一个例子：56,54,5。第一次排序结果为:</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">56</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">54</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第二次呢？</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">56</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">55</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">54</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">此时要注意，第二55，是由5补位而来的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">再看一个复杂一点的例子，包含了：1位数，2位数，3位数：96 9 95 556 56 55 5 554 54 3 2 1</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第一次排序：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">96</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">95</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">556</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">56</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">55</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">554</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">54</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">96</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">95</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">556</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">56</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">55</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">554</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">54</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第二次排序：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">96</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">95</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">56</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">556</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">55</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">554</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">54</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">99</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">96</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">95</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">56</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">556</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">55</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">55</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">554</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">54</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面一行，是原始数字，下面一行，经过补位了。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第三次排序</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">96</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">95</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">56</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">556</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">55</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">554</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">54</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">99</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">96</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">95</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">565</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">556</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">555</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">555</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">554</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">545</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第四次排序</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">96</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">95</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">56</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">556</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">55</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">554</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">54</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">99</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">96</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">95</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">565</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">556</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">555</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">555</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">554</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">545</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">处理最后三个个位数即可。则最终的结果是: 996955655655554554321</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面的算法，排序处理自左向右第一位，然后处理第二位，一次类推，如果某一组内，即第一个数字相同的一组，长度不同时，采用第一位进行补位。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>一个巧妙的方法</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们在上面的方法中，相当于，比较两个数字的时候，把两个数字拆开，逐位进行比较。那我们接下来，就是将这两个数字，作为一个整体，进行比较。然后一次排序，就得到了结果。给定例子：5,54,56</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">比较5和54，实际上就是比较545和554哪个大</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">比较5和56，实际上就是比较556和565哪个大</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">比较54和56，实际上就是比较5456和5654哪个大</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">那我们对快排程序做一下变化，当两个数字a和b进行比较时，比较的是ab和ba两个数字的大小即可。只是比较发生了变化，剩下的和快排都是一样的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">相比较而言，后面这种方法，更简单易懂一些，而且，看上去要美很多，但是确不容易那么直接的想到。我们在平时积累的过程中，就要尝试多多的方法，即使看起来不那么美的方法，这些思路的开拓，会帮助我们举一反三，帮助我们在遇到新的题目的时候，游刃有余。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：巧妙排序；及相伴一生分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-21</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/122275/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：巧妙排序</strong><br /></p> 
      <p><strong><br /></strong></p> 
      <p>排序只有1，2，3三个元素的数组，不能统计1，2，3的个数。<br /></p> 
      <p>希望大家能够相出多多的思路。比如，最小的空间，最少的次数。</p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p>===================</p> 
      <p><strong>相伴一生分析：</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">给定一个数组，数组中只包含0和1。请找到一个最长的子序列，其中0和1的数量是相同的。<br />例1：10101010 结果就是其本身。<br />例2：1101000 结果是110100<br />请大家展开自己的思路。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个题目，看起来比较简单，一些同学可能认为题目的描述符合动态规划的特征，然后就开始用动态规划解，努力找状态转移方程。这些同学的感觉，是很正确的。但，找状态转移方程，我们要对原来的数组进行变换一下。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">原来是0和1的串，我们将0都换为-1。这样题目目标就变成，找到一个最长的子串，子串数字和是0。设原数组为A, DP[i]表示从0开始到i的子数组和。DP遍历一遍数组即可。例1中的数组产生的DP为：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个例子，最后一个值是0，并且长度是偶数位。直接满足了结果。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">再看例子2：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">-1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">5的位置为0，最长子串从0开始到5，长度为6。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面这两个例子，所求的子串都是从头开始，如果不是从头开始，会是什么样的呢？看这个例子：1101100</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">通过观察上面的表格，我们可以得到，DP[0]==DP[6]==DP[2]，DP[1]==DP[3]. 根据DP的定义，如果DP[i]==DP[j]，i 一种方法，我们用map保存DP的值到位置的映射，如下表：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">DP值</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">位置</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">最大位置</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">最小位置</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">最大长度</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0，2，6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1，3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">最长子串长度</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们最终的算法，要综合考虑最常穿是否从头开始的。 上面的这个思路，时间复杂度是O(n),空间复杂度也是O(n).</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">还有其他的思路，例如DP保存的是[0,i]的1的个数，那么DP[j] - DP[i] * 2 == j - i则表明A[i+1]...A[j]是一个满足条件的串，找到j-i最大的，就是最终的结果，这个思路的时间复杂度为O(n^2),空间复杂度为O(n).</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：找数组的波谷；及巧妙排序的分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-22</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/122759/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：找数组的波谷</strong></p> 
      <p><strong><br /></strong></p> 
      <p>一个数组A[1...n]，满足A[1]&gt;=A[2], A[n] &gt;= A[n-1]。A[i]被成为波谷，意味着：A[i-1] &gt;= A[i] &lt;= A[i+1]。请给出一个算法，找到数组中的一个波谷。O(n)的方法，是很直接，有更快的方法么？</p> 
      <p><br /></p> 
      <p>=========================</p> 
      <p><strong>巧妙排序分析：</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">排序只有1，2，3三个元素的数组，不能统计1，2，3的个数。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个题目，尽管也是排序，但却不能使用快速排序的方法。只有三个元素，如果时间复杂度仍旧是O(nlogn)，显然不是最好的。那就可以使用线性的排序算法，例如计数排序，可是题目中要求，不能够对1，2，3进行统计个数。那该如何处理呢？请大家看下面的方法，我们首先通过例子来说明：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p3</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">假设，我们有三个指针：p1、p2、p3.p1从左侧开始，指向第一个非1的数字；p3从右侧开始，指向第一个非3的数字。p2从p1开始遍历，如果是2，p2继续遍历，直到p2遇到1或者3：</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果遇到1，则和p1进行交换，然后p1向右，指向第一个非1的数字</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果遇到3，则和p3进行交换，然后p3向左，指向第一个非3的数字</p></li> 
      </ol> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p1，p2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p3</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">交换之后，p2继续从p1开始，如果是2继续遍历，如果是1或者3，重复上面的步骤，所得如下：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p1，p2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p3</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">根据上面的方法继续下去</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">p2在p3右侧，算法结束。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">总结一下上面的算法：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">p1从左侧开始，指向第一个非1的数字；p3从右侧开始，指向第一个非3的数字。</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">p2从p1开始遍历，如果是2，p2继续遍历，直到p2遇到1或者3</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果遇到1，则和p1进行交换，然后p1向右，指向第一个非1的数字</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果遇到3，则和p3进行交换，然后p3向左，指向第一个非3的数字</p></li> 
      </ol> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">重复上面的步骤，直到p2在p3的右侧结束。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>基于快排划分的思路</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面的思路，是针对三个数的，如果有更多的数，怎么处理呢？比如，4个，5个等等。下面根据快速的排序的启发，介绍一种算法，尽管在处理三个数的时候，比较次数会多些，但，具有很好的通用性。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">思路来自快排的划分部分，快排的划分部分：给定pivot，然后将数据划分为&lt;=pivot和&gt;pivot两部分。这样，三个数字时，需要两次划分：</p> 
      <ol style="list-style-type:decimal;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第一次，用1作为pivot,划分1到最左边；</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第二次，用2作为pivot，划分2到左边，则得到整体的排序。</p></li> 
      </ol> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>最巧妙的思路</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们将1，2，3，替换为互质的2，3，5，得到如下：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">之后，乘起来得到的900.这900里，除以2，有多少个2，就有多少个1；然后除以3，有多少个3，就有多少个3对应的2；然后除以5，有多少个5，就有多少个5对应的3。这是如何保证的呢？因为2，3，5是互质的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如下：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">被除数</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">除数</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">商</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">余数</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">排序结果</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">900</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">450</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">450</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">225</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">225</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">112</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2尝试结束，尝试3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">225</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">75</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">75</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">25</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">25</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3尝试结束，尝试5</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">25</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">全部结束</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">最终结果为112233.上面的这种思路，实际上是计数的一种变种。没有直接的技术，那自然就是可以的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：绳子的长度；及找数组的波谷分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-23</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/124001/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：绳子的长度</strong></p> 
      <p><strong><br /></strong></p> 
      <p>一根一米长的绳子，随机断成三段；求最短的一段的期望长度以及最长的一段的期望长度。<strong><br /></strong></p> 
      <p><br /></p> 
      <p>================================</p> 
      <p><br /></p> 
      <p><strong>找数组的波谷分析：</strong><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">一个数组A[1...n]，满足A[1]&gt;=A[2], A[n] &gt;= A[n-1]。A[i]被成为波谷，意味着：A[i-1] &gt;= A[i] &lt;= A[i+1]。请给出一个算法，找到数组中的一个波谷。O(n)的方法，是很直接，有更快的方法么？</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个题目遍历一遍数组，显然就可以找到全部的波谷。时间复杂度O(n)，空间复杂度是O(1)。但是如果我们只需要找到一个波谷，是否有更快的方法呢？更快的方法O(1)是不可能的，那只有O(logn)，自然就想到二分查找。这个题目如果进行二分呢？我们看下面的数组A：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">left</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">mid</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">right</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">A[0]&gt;A[1]，A[6]&gt;A[5]，满足题目中要求数组的条件。满足这样的条件，数组中一定是存在波谷的。假设不存在波谷，则A[0]&lt;A[1]，A[6]&lt;A[5]，与条件相悖。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上表中的mid=3，A[mid]=2。A[mid-1]&lt;A[mid]&lt;A[mid+]。根据上面的分析，[mid, 6]一定有一个波谷。所以处理有半部分</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">left</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">mid</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">right</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">此时，mid满足波谷的条件，找到波谷。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">总结上面的思路，找到数组的mid元素，mid有几种情况：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>如果A[mid-1]&gt;=A[mid] &amp;&amp; A[mid+1]&gt;=A[mid]，找到波谷；</p></li> 
       <li><p>如果A[mid-1]&lt;=A[mid]&lt;A[mid+1]，right=mid，在左侧继续找；</p></li> 
       <li><p>如果A[mid+1]&lt;=A[mid]&lt;A[mid-1]，left=mid，在右侧继续找；</p></li> 
       <li><p>如果A[mid-1]&lt;A[mid] &amp;&amp; A[mid+1]&lt;A[mid]，任意一侧都可以，任意一侧，都必将存在波谷。</p></li> 
      </ul> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>进一步分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果这个题目中，没有A[1]&gt;=A[2]以及A[n]&gt;=A[n-1]的约束，还能够以O(logn)的时间复杂度完成么？关键点就在于，中间的元素与其相邻的元素进行大小比较的时候，还能否选择一边继续进行查找。当A[mid-1]&lt;=A[mid]时，可能是A[1]&lt;A[2]&lt;…&lt;A[mid-1]&lt;=A[mid]是不存在波谷的。所以，在左侧查找是找不到波谷的。所以，如果没有原题中的条件，两边都要进行遍历查找，我们的递归式应该是如下的形式：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">T(n)=2T(n/2)+1</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">根据主定理，解得，时间复杂度为O(n).此时，是不存在O(logn)的。</p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：千王之王；及绳子的长度分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-24</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/125628/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：千王之王</strong></p> 
      <p><strong><br /></strong></p> 
      <p>52张牌，四张A，随机打乱后问，从左到右一张一张翻直到出现第一张A，请问平均要翻几张牌？<br /></p> 
      <p><br /></p> 
      <p>===========================</p> 
      <p><strong>绳子的长度分析：<embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">分析：</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这题随机变量看似3个，但是其实两个就可以了。设在X，Y处把棍子折断，X，Y都在[0,1]区间内均匀分布。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们不妨设X&lt;Y, 那么三段的长度分别为X,Y-X,1-Y (米）。 如果X是最短的，那么满足</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>X&lt;Y-X</p></li> 
       <li><p>X <img src="https://raw.github.com/koth/tthings/master/1.gif" style="border:0px;max-width:100%;box-sizing:border-box;" /></p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这里，主要是由给出的条件，分别给出X,Y的上下界。我们先对Y积分，Y的上下界由1），2）很容易给出，那么X的呢？一般可画图出 X，Y的坐标图，以及边界条件1）2），我们可知X最小为0，当1），2）两条曲线相交时取到最大值1/3. 计算积分公式得出1/54. 这里我们假定了X，Y-X，1-Y中，X最小。Y-X最小以及1-Y最小的情形类似跟这种情况对称，变化下符号就一样了。 另外Y&gt;X情况也是一样，所以，我们加总这六种情况，得出期望值为: 6*1/54=1/9.</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">计算最大的一段的值类似， 可先假定一组条件，然后根据对称性，简单求和。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们还是先假定X&lt;Y 然后X为其中最大段，那么</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>X &gt;Y-X<br /></p></li> 
       <li><p>X &gt;1-Y<br /></p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这种情况，画出图来，容易确定积分上限界限，从而列出公式：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;"><img src="https://raw.github.com/koth/tthings/master/2.jpg" style="border:0px;max-width:100%;box-sizing:border-box;" /></p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">等于1/54 + 1/12 ,同样，根据对称性，乘以6，最终得11/18.</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>有简单的方法吗？</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">如果很熟悉一些几何的特性的话，画出坐标图，求X期望可化为求质心，应用求质心的公式可快速求解，感兴趣的朋友可尝试下。</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：色子玄机；及千王之王分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-25</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/126625/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：色子玄机</strong></p> 
      <p>有两个色子，一个是正常的，六面分别1-6的数字；另一个六面都是空白的。现在有0-6的数字，请给出一个方案，将0-6中的任意数字涂在空白的色子上，使得当同时扔两个色子时，以相等的概率出现某一个数字（这个数字是两个色子上数字的和），比如，如果一个色子是1，另一个色子是2，则出现的数字是3。依次类推。</p> 
      <p><br /></p> 
      <p><br /></p> 
      <p>=====================</p> 
      <p><strong>千王之王分析：<embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">52张牌，四张A，随机打乱后问，从左到右1张一张翻直到出现第一张A，请问平均要翻几张牌？</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>第一种分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">摸到第一张A之前的都是其他的牌，那么，之前会有多少种可能呢？ 之前可能会有0张，1张。。。。48张。考虑4张A在牌中的位置，他们把其他牌分成了5份（四个点把直线分成五段）。每一份的个数从0-48不等，完全随机的情况下，每份的平均长度为48/5=9.6，摸完这9.6张后，接下来的就是第一张A，故平均需要摸9.6+1=10.6张，即11张。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>另一种方法</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">通常情况下，设n张牌要翻f(n)次，则f(4)=1。翻第一张牌分“翻到”和“没翻到”两种情况：若翻到，则只翻了1次；若没翻到，则要翻1+f(n-1)次。故f(n) = 1*(4/n) + [1+f(n-1)]*(n-4)/n。可得f(n)=(n+1)/5，f(52)= 53/5。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">假设n张牌要翻f(n)次。当有4张牌的时候，都是A。显然f(4)=1。当n&gt;4的时候，f(n)是什么呢？从第一张开始翻，有两种情况：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>如果翻到A，则1次，概率是4/n</p></li> 
       <li><p>如果没有翻到，则需要1+f(n-1)次，概率是(n-4)/n</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">则得到递归式：f(n)= 1 &times; 4/n + (1+f(n)) &times; (n-4)/n；当然，在我们的题目中，n=52。如何解这个递归式呢？</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">n取值</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">f(n)</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">f(5)=4/5+2/5=6/5=(5 + 1)/5</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">f(6)=4/6+(1 + 6/5)&times;2/6=7/5=(6 + 1)/5</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">f(7)=4/7+(1 + 7/5)&times;3/7=8/5=(7 + 1)/5</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">…</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">n</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">f(n)=(n+1)/5</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">递归证明，由大家完成。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>小应用</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">玩过三国杀的朋友都知道，黄盖的技能是苦肉，苦肉技能每掉一次血可以多模2张牌(前提是没失血过多)。 现在假如你是黄盖， 这轮底牌还剩11张，你通过记牌知道底牌中至少还有2个桃，你还有3滴血，请问你应不应该苦肉到底，拼一把（到剩一滴血）. 应用之前的分析，到第一个桃，平均需要(11-2)/(2+1) +1=4. 4张牌黄盖只需掉2滴血，还能剩一滴血，然后摸到桃还能回血， 看起来还是很合算的。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><br /></h4> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：死亡小岛；及色子玄机分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-26</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/128624/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><br /></p> 
      <p><strong>今日面试题：死亡小岛</strong></p> 
      <p>一个小岛，表示为一个N&times;N的方格，从(0,0)到(N-1, N-1)，一个人站在岛上，位置(x, y)，他可以上下左右走，一步一个格子，他选择上下左右的可能性是一样的。当他走出小岛，就意味着死亡。假设他要走n步，请问他死亡的概率有多大？请写出求解代码。</p> 
      <p><br /></p> 
      <p><br /></p> 
      <p>===============================<br /></p> 
      <p><strong>色子玄机分析<embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">有两个色子，一个是正常的，六面分别1-6的数字；另一个六面都是空白的。现在有0-6的数字，请给出一个方案，将0-6中的任意数字涂在空白的色子上，使得当同时扔两个色子时，以相等的概率出现某一个数字。如果一个色子是1，另一个色子是2，则出现的数字是3。依次类推。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">首先，深入理解题目。两个色子，一个色子上1到6，是正常的，可以理解为，随手一扔，每个数字出现的概率是相同的，都是1/6；另一个呢？空白的，不过我们可以自己涂上0-6的数字，包括0和6。然后扔完了之后，一个色子上面出现a，另一个色子出现b，最终把a+b作为一个数字。有多少个不同的数字呢？假设有n个，则题目要求是每一个出现的概率都是1/n。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">n的取值都有那些呢？1到12都可以。加入，就是1-12的数字，该如何涂空白的色子，保证概率相等呢？两个色子，每个六面，扔起来，一共36种可能，如果出现12个数字，并且，每个数字是等概率的，则36/12=3，每个可能会出现三次。当，第一个色子，扔得数字是1时，第二个色子要有三次是0才能保证1出现了三次。同理，当第一个色子扔的是6，要得到三次12的数字，则第二个色子要有三次是6。则，空白的色子，必须涂三个0，三个6。我们来证明，每一个概率都是3/36=1/12:</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">第一个色子</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">第一个色子概率</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">第二个色子</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">所得数字</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1/6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(0)=p(6)=1/2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(1) = p(7) = 1/2 * 1/6 = 1/12;</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1/6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(0)=p(6)=1/2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(2) = p(8) = 1/2 * 1/6 = 1/12;</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1/6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(0)=p(6)=1/2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(3) = p(9) = 1/2 * 1/6 = 1/12;</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1/6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(0)=p(6)=1/2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(4) = p(10) = 1/2 * 1/6 = 1/12;</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1/6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(0)=p(6)=1/2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(5) = p(11) = 1/2 * 1/6 = 1/12;</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1/6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(0)=p(6)=1/2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">p(6) = p(12) = 1/2 * 1/6 = 1/12;</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">则，p(1)=p(2)=p(3)=p(4)=p(5)=p(6)=p(7)=p(8)=p(9)=p(10)=p(11)=p(12)=1/12</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">最后的取值范围，还可以是其他的么？我们已经知道正常的色子，哪一面出现的概率都是1/6；能不能充分利用这个呢？只需要空白的色子，六面都是一个数字就可以了。p = 1/6 * 1 最终每个数字出现的概率都是1/6。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：谁多谁少；及死亡小岛分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-27</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/130105/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：谁多谁少</strong></p> 
      <p>盒子A有10个红球，盒子B有十个绿球。进行如下的操作：<br /></p> 
      <ol style="list-style-type:decimal;"> 
       <li><p>随机从A中拿三个球放入B中；</p></li> 
       <li><p>随机从B中拿三个球放入A中</p></li> 
      </ol> 
      <p>问题是，在哪一个盒子中，会出现一个颜色的球比另一个颜色的球更多？该如何分析？<br /></p> 
      <p><br /></p> 
      <p><strong>死亡小岛分析：</strong><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">一个小岛，表示为一个N&times;N的方格，从(0,0)到(N-1, N-1)，一个人站在岛上，位置(x, y)，他可以上下左右走，一步一个格子，他选择上下左右的可能性是一样的。当他走出小岛，就意味着死亡。假设他要走n步，请问他死亡的概率有多大？请写出求解代码。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">遇到这样的问题，就试着走几步好了。当一个人在(x,y)的时候，假设他此时，死亡的概率为p(x,y,n)，然后，他有四种选择，而且是可能性相同，就是说，选择上下左右的概率都是1/4：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>选择上边，死亡的概率是多少呢？此时位置为(x, y-1)，剩余的步数为n-1,则概率为p(x, y - 1, n - 1)</p></li> 
       <li><p>选择下边同理：概率为p(x, y + 1, n - 1)</p></li> 
       <li><p>选择左边同理：概率为p(x - 1, y, n - 1)</p></li> 
       <li><p>选择右边同理：概率为p(x + 1, y, n - 1)</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">则，p(x,y,n)=(p(x, y - 1, n - 1) + p(x, y + 1, n - 1) + p(x - 1, y, n - 1) + p(x + 1, y, n - 1))/4，可以表达出递归的形式。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个题目，看似比较复杂，但是尝试走一步，之后，写出递归表达式了，就比较简单了。递归终止的条件，只要x或者y，满足了小于0或者大于n-1的时候，p=1。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">代码如下：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;"><img src="http://chuansongme.com/static/img/essay/689/130105/1.jpg" onerror="" /><br /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：选择旅游国家；及谁多谁少分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-28</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/130499/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：选择旅游国家</strong></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" />有一个待选国家的列表，以及国家的相对热门程度，请给出一个算法，随机选择一个国家，并且保证，越是热门的国家，随机选择它的可能性就越高。</p> 
      <p><br /></p> 
      <p>=====================================</p> 
      <p><strong>谁多谁少分析：</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">盒子A有10个红球，盒子B有十个绿球。进行如下的操作：<br /></p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>随机从A中拿三个球放入B中 <br /></p></li> 
       <li><p>随机从B中拿三个球放入A中 <br /></p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">问题是，在哪一个盒子中，会出现一个颜色的球比另一个颜色的球更多？该如何分析？<br /></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">最近概率相关的面试题目出了不少，不知道大家对这类题目的感觉如何。是否已经抓住了一些路子，一些分析方法，遇到一个题目的时候，可以按部就班的解决它。这些都没有什么比较好的方法，只有勤加练习，多多接触概率的题目，练习多了，自然不在话下。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面这个题目，初次分析，很多同学会凭直觉显然是B啊。但是，这个直觉是准的么？一个准确的直觉，往往是建立在大量的练习经验之上的。所以，还在锻炼过程中的同学们，要尝试具体去分析、去做。而不是猜。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">首先这个题目的目标大家理解了么？这里有个小坑。两个盒子，肯定都是一种颜色的球比另一种颜色的球多，但是哪个更多呢？关键在这个“更”字，直接上，感觉是B的同学，也是对“更”字的关注不够。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">仔细、逐步分析，让我们看看实际是什么样的：第一步，从A中，随机选择三个红球放入B中，这里没有什么变数。看第二步：从B中，取三个球，放入A中。那么有多少个红球被拿到A中呢？</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">B中拿出红球个数</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">A中情况</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">B中情况</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">哪个更多</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7红球，3绿球</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7绿球，3红球</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">一样多</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8红球，2绿球</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8绿球，2红球</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">一样多</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9红球，1绿球</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9绿球，1红球</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">一样多</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10红球，0绿球</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10绿球，0红球</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">一样多</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">所以，最终的答案是一样最多的，没有哪个盒子里是更多的。</p> 
      <embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：重出江湖；及选择旅游国家分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-29</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/131371/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：重出江湖</strong></p> 
      <p>n个色子，每个色子m面，每一面的值分别是1-m。你将n个色子同时抛，落地后将所有朝上面的数字加起来，记为sum。给定一个数字x，如果sum&gt;x，则你赢。给定n，m，x，求你赢的概率。<br /></p> 
      <ul style="list-style-type:disc;"> 
       <li><p><span style="color:#333333;"><span style="font-size:14px;line-height:17px;">1&lt;=n&lt;=100</span></span></p></li> 
       <li><p><span style="color:#333333;"><span style="font-size:14px;line-height:17px;">1&lt;=m&lt;=10</span></span></p></li> 
       <li><p><span style="color:#333333;"><span style="font-size:14px;line-height:17px;">m&lt;=x&lt;n*x</span></span></p></li> 
      </ul> 
      <p><br /></p> 
      <p><strong><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" />选择旅游国家分析：</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">有一个待选国家的列表，以及国家的相对热门程度，请给出一个算法，随机选择一个国家，并且保证，越是热门的国家，随机选择它的可能性就越高。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">每当我们遇到一个题目的时候，都要对题目进行充分的理解，有哪些条件，目标是什么。这个题目看完之后，我们能够得到两个要点：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>随机选择一个国家</p></li> 
       <li><p>越是热门，选择的可能性、概率就越高</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们怎么做到这个呢？如何充分理解这个呢？还是通过一个例子来进行：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">国家</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">A</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">B</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">C</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">D</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">热度</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">随机选择一个国家，意味着，如果热度相同，则被选择的概率是相同的，更进一步，都可以表示为2/10。依次类推，A被选择的概率是1/10，热度最小，则概率最小。并且，概率之间的比，和热度之间的比是相同的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">那么，我们以怎么样的方法，来保证，选择A的概率是1/10，B和D的概率是2/10，C的概率是5/10？我们稍作变换，将上面的表格，转换为如下的表格：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">A</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">B</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">B</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">C</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">C</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">C</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">C</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">C</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">D</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">D</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们只要保证，选择上面表格中每一个元素的概率是相同的，就可以得到A，B，C，D的概率值。如何保证呢？两种情况：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>当国家数以及热度都是固定时，比如上面的总数10，随机0-9的数字，即可。</p></li> 
       <li><p>当国家数以及热度都是不固定时，则需要蓄水池抽样算法</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">蓄水池抽样算法，在我们前面的系列中有介绍，是时候翻开前面的东西，复习一下了。</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：第n杯水；及重出江湖分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-30</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/132318/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">今日面试题：第n杯水</h4> 
      <p>有一座金字塔，从上到下，第一层有一个杯子、第二层有两个杯子，依次类推。对杯子进行编号，有如下的形状：<br /></p> 
      <p> &nbsp; &nbsp;1</p> 
      <p> &nbsp;2 &nbsp; 3</p> 
      <p>4 &nbsp; 5 &nbsp; 6</p> 
      <p>每个杯子的容量为C升，从塔顶倒下L升水，当1号杯子满了之后，会等量溢出到2号和3号杯子。当2号和3号满了，2号溢出到4号和5号，3号溢出到5号和6号，注意5号接受来自两个杯子的水。依次类推。给定C和L，请问，第n杯里有多少水。<br /></p> 
      <p><br /></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">重出江湖分析 </h4> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">n个色子，每个色子m面，每一面的值分别是1-m。你将n个色子同时抛，落地后将所有朝上面的数字加起来，记为sum。给定一个数字x，如果sum&gt;x，则你赢。给定n，m，x，求你赢的概率。</p> 
      <ul style="list-style-type:disc;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">1&lt;=n&lt;=100</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">1&lt;=m&lt;=10</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">m&lt;=x&lt;n*m</p></li> 
      </ul> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个题目的描述，是将具体的问题一般化了。掌握了，这个问题的分析，就可以对这类问题通吃。一个具体的情况是什么呢？两个色子，每个色子六面，同时抛，求朝上数字和大于某一个值的概率。这个情况比较简单，两个色子同时抛，一共36种情况，注意这里有的和是相同的。此时，最少可以通过穷举的方法，得到答案。但是本题中的意思，显然是无法通过穷举呢？那该如何分析呢？</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">n个色子，每个色子m面。则一共有m^n中情况（类比上面分析的36种情况）。在这些里面，有多少个和是大于x的呢？假设，f(n,x)表示n个色子，所有朝上的数字和是x的情况数量。对于某一个色子，每一面朝上的概率是1/m。假设这个色子的k面朝上，1&lt;=k&lt;=m，则f(n,x) = sum{f(n - 1, x - k)} 1&lt;=k&lt;=m。递归的终止条件是，当只有一个色子的时候，f(1,k) = 1, 1&lt;=k&lt;=m，其他都是0</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">则最终的概率为(f(n, x + 1) + … + f(n, m*n)) / m^n。每一个大于x的和的可能情况数量之和除以总的情况数量。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">以2个6面色子为例，验证上面的公式。</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">和</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">情况数</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">11</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">12</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">取和大于10的概率，即2/36+1/36 = 3/36 = 1/12。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">根据上面的公式，(f(2, 11) + f(2, 12)) / 12</p> 
      <ul style="list-style-type:disc;"> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">f(2, 11) = f(1, 10) + f(1, 9) + f(1, 8) + f(1, 7) + f(1, 6) + f(1, 6) = 2</p></li> 
       <li><p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">f(2, 12) = f(1, 11) + f(1, 10) + f(1, 9) + f(1, 8) + f(1, 7) + f(1, 6) = 1</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">则概率为3/12，与穷举方法一致。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
      <p><br /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：最大矩形；及第n杯水分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-07-31</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/133948/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：最大矩形</strong><br /></p> 
      <p>在一个位图中找面积最大的白色矩形：给你一个NxN的黑白位图，找一个面积最大的全白色的矩形。注意了，是一个<strong>矩形</strong>，不是任意一个白色相连的区域。你的算法能够达到的最好的时间复杂度是多少呢？<br /></p> 
      <p><br /></p> 
      <p>===================</p> 
      <p><strong>第n杯水分析</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">有一座金字塔，从上到下，第一层有一个杯子、第二层有两个杯子，依次类推。对杯子进行编号，有如下的形状：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
       </tbody> 
      </table> 
      <p><span style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;background-color:#ffffff;">每个杯子的容量为C升，从塔顶倒下L升水，当1号杯子满了之后，会等量溢出到2号和3号杯子。当2号和3号满了，2号溢出到4号和5号，3号溢出到5号和6号，注意5号接受来自两个杯子的水。依次类推。给定C和L，请问，第n杯里有多少水。 </span></p> 
      <p><span style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;background-color:#ffffff;"><br /></span></p> 
      <p><span style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;background-color:#ffffff;">####分析 </span></p> 
      <p><span style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;background-color:#ffffff;">这个类型的题目，关键点就是明了水倒下来的过程。我们这里做简单的分析， 假设L&gt;C, 如果L</span></p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">金字塔深度</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">杯号</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">A索引</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">观察上面的表格，我们会发现，一个规律，i号杯深度为h，则i号中溢出的水，将平分进入：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>i + h + 1</p></li> 
       <li><p>i + h + 2</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">比如，文章开始的图中，3号杯进入5号和六号，3号杯的h为1，则</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>5 = 3 + 1 + 1</p></li> 
       <li><p>6 = 3 + 2 + 2</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">利用这个技巧，可以在数组中存储树形的金字塔，并且可以很方便的找到孩子节点。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">计算出所有的A[i]之后，要得到最后的答案，还有一部之遥。即：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>A[i] &gt;= C ? C : A[i]</p></li> 
      </ul> 
      <p style="margin-bottom:0px !important;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;">【分析完毕】</p> 
      <p><strong><br /></strong><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：Google赛马；及最大矩形分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-01</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/134926/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：Google赛马</strong></p> 
      <p><strong><br /></strong></p> 
      <p>想必田忌赛马的故事，大家都耳熟能详。但是，大家知道Goolge的童鞋们是怎么赛马的么？不过，首先，大家要先尝试一下：有25匹马，每次只能五匹一起跑，那么最少跑几次，才能确定前三甲呢？<br /></p> 
      <p><br /></p> 
      <p>=====================================================<br /></p> 
      <p><strong>最大矩形分析</strong></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">在一个位图中找面积最大的白色矩形：给你一个NxN的黑白位图，找一个面积最大的全白色的矩形。注意了，是一个矩形，不是任意一个白色相连的区域。你的算法能够达到的最好的时间复杂度是多少呢？</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">为了方便进行分析，我们假设黑色位置都是0，白色的位置都是1.题目的问题就转化为，找到一个最大的矩形，其中所有的元素都是1.</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">遇到这样的题目，该如何分析呢？这是一个矩形，是二维，是否是由一维的某些问题扩展而来的呢？一维的问题的解法，是否可以扩展到二维呢？我们看下面的题目：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">在柱状图中找最大的矩形：给一组非负的整数来表示一个柱状图，设计一个算法找到最大面积的能适合到柱状图内的矩形。比如，对与这组数，1 2 3 4 1 ，有两种可能的方案，一种是适合到 2 3 4 内的矩形，面积是 2*3；另一种是适合到 3 4 内的矩形，面积是 3*2。你觉得能有O(n)算法吗？</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面的题目，我们在微博上都讨论过的。大家还记得，一维的时候，是怎么样的解法么？思路如下：</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;"><em>一个线性算法是用堆栈来保存当前可能的矩形（高度和起始位置）。从左到右扫描，对一个元素，如果 a）大于栈顶元素， push； b）小于的话，pop所有的大于它的元素，计算面积，更新最大值。这时如果堆栈空，push一个新的元素，高度等于当前元素，起始位置为0；否则，push当前元素高度和栈顶的起始位置。</em></p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这是一个很巧妙的解法，是否能够应用到二维的情况呢？在微博中，我们简短的给出了一个思路。下面，我们在这里详细讨论，针对如下例子，有矩阵A：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面的这个矩阵，该如何转化为一维的情况处理呢？最直接的思路如下：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>第一行作为一维的情况处理；</p></li> 
       <li><p>第一行、第二行，对应列相加，生成一个新的数组，然后应用一维的处理情况；</p></li> 
       <li><p>第一行、第二行、第三行，对应列相加，生成一个新的数组，然后应用一维的处理情况；</p></li> 
       <li><p>...直到整个矩阵都包括在内；</p></li> 
       <li><p>第二行作为一维的情况处理；</p></li> 
       <li><p>第二行、第三行，对应列相加，生成一个新的数组，然后应用一维的处理情况；</p></li> 
       <li><p>...一次类推</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面的思路是可行的，但是时间复杂度是n^3的。如何进一步改进呢？思路也是从上面的过程中得到的。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">生成新的矩阵C,C[i][j]表示第j列，从第i个元素开始，包括第i个元素，向上数，直到遇到0时，1的个数。则C为：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">上面这个矩阵的构造，遍历一边A的全部元素即可。n^2的时间复杂度。这个矩阵的最大作用，就是将上面思路中，跨几行考虑的情况，都变为一行了。时间复杂度降了一个级别，每一行，应用一维处理处理的情况，就可以得到最终的结果。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">将上面斜体的描述转换为如下步骤：(h, i)，h表示C[i][j]的大小，可以理解为矩形的高度，i表示起始位置，第三行为例：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">i</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">C[i]</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">栈操作</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">最大值</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">栈内容</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">push (1,0)</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(1,0)</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">push (3,1)</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(3,1)(1,0)</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">pop (3,1),push (2,1)</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(2-1)*3=3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(2,1)(1,0)</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">什么都不做</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(2,1)(1,0)</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">push(3,4)</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(3,4)(2,1)(1,0)</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">pop(3,4)</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(5-4)*3=3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(2,1)(1,0)</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">pop(2,1)</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(5-1)*2=8</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(1,0)</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">pop(1,0)</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">(5-0)*1=5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;"><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">则得到这一行的最大值为8。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">总结算法过程如下：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>初始(h,0)，入栈；</p></li> 
       <li><p>遍历后续元素：</p></li> 
       <li><p>* 如果h &gt; h_top, 则入栈；</p></li> 
       <li><p>* 如果h = h_top, 则不进行任何操作；</p></li> 
       <li><p>* 如果h &lt; h_top, 出栈，直到栈顶元素的高度小于h，每次出栈，更新最大值(i - i_pop)*h_pop &gt; max ? (i - i_pop)*h_pop : max；此时如果h&gt;h_top,则push (h, i_lastpop)，如果栈为空，则push (h, 0).</p></li> 
       <li><p>直到元素遍历完毕</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：可怜的小老鼠；及Google赛马分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-02</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/136084/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：可怜的小老鼠</strong></p> 
      <p><strong><br /></strong></p> 
      <p>有11瓶酒，只有一瓶有毒。喝酒之后，三天会死，只有三天时间。请问至少需要多少只老鼠，可以找出9瓶没有毒的酒。<br /></p> 
      <p><br /></p> 
      <p>===============================================</p> 
      <p><strong>Google赛马分析</strong></p> 
      <h4 style="margin:20px 0px 10px;padding:0px;border:0px;-webkit-font-smoothing:antialiased;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="padding:0px;border:0px;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:14px;line-height:22px;margin-top:10px;margin-bottom:15px;">想必田忌赛马的故事，大家都耳熟能详。但是，大家知道Goolge的童鞋们是怎么赛马的么？不过，首先，大家要先尝试一下：有25匹马，每次只能五匹一起跑，那么最少跑几次，才能确定前三甲呢？</p> 
      <h4 style="margin:20px 0px 10px;padding:0px;border:0px;-webkit-font-smoothing:antialiased;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;">分析</h4> 
      <p style="padding:0px;border:0px;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:14px;line-height:22px;margin-top:10px;margin-bottom:15px;">这样的题目，该如何分析呢？没有任何的名次信息，没有秒表，没有相机记录距离(题目中疏忽了:))，我们先简单一点，如何确定第一名呢？6次是可以的，例如可以有如下的方法：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;border:0px;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:14px;line-height:22px;"> 
       <li style="margin:0px;padding:0px;border:0px;"><p>每5匹马比赛一次，找到5个第一名，然后这5匹马进行比赛，得到第一名，6次；</p></li> 
       <li style="margin:0px;padding:0px;border:0px;"><p>首先5匹马进行比赛，得到第一名，此时剩下20匹马没有参与比赛。每次4匹，分为5组，一次和第一名比较。也是6次得到最终的第一名</p></li> 
       <li style="margin:0px;padding:0px;border:0px;"><p>...</p></li> 
      </ul> 
      <p style="padding:0px;border:0px;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:14px;line-height:22px;margin-top:15px;margin-bottom:15px;">我们采用继续第一种方法分析，前三名的情况，如下表：</p> 
      <table style="margin:15px 0px;padding:0px;border:0px;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:14px;line-height:22px;" class=" noBorderTable"> 
       <tbody style="margin:0px;padding:0px;border:0px;"> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">A1</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">B1</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">C1</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">D1</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">E1</td> 
        </tr> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">A2</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">B2</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">C2</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">D2</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">E2</td> 
        </tr> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">A3</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">B3</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">C3</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">D3</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">E3</td> 
        </tr> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">A4</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">B4</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">C4</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">D4</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">E4</td> 
        </tr> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">A5</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">B5</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">C5</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">D5</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">E5</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="padding:0px;border:0px;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:14px;line-height:22px;margin-top:15px;margin-bottom:15px;">上表中A&gt;B&gt;C&gt;D&gt;E，A1&gt;A2&gt;A3&gt;A4&gt;A5。是由前五次得出的结果，因为我们只要前3的名次，排除掉不可能的马匹，变为如下的表格：</p> 
      <table style="margin:15px 0px;padding:0px;border:0px;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:14px;line-height:22px;" class=" noBorderTable"> 
       <tbody style="margin:0px;padding:0px;border:0px;"> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">A1</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">B1</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">C1</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
        </tr> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">A2</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">B2</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
        </tr> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;">A3</td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
        </tr> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
        </tr> 
        <tr style="margin:0px;padding:0px;border-width:1px 0px 0px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
         <td style="margin:0px;padding:6px 13px;border:1px solid #cccccc;"><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-bottom:0px !important;padding:0px;border:0px;color:#333333;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:14px;line-height:22px;margin-top:15px;">B3为何要排除呢，因为，如果B3不排除，则A1&gt;A2&gt;A3&gt;B3。就是前四的名次了。剩下的6个里面，A1是第一名已经确定，那么剩下的5匹取前两名，即可得到全部前三甲。此时又赛了场。则总共赛了7场。</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：巧妙变换；及可怜的小老鼠分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-03</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/137408/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><strong>今日面试题：巧妙变换</strong></p> 
      <p>输入数组[a1,a2,...,an,b1,b2,...,bn]，构造函数，使得输出为，[a1,b1,a2,b2,...,an,bn]，注意：方法要是in-place的。</p> 
      <p>======================================<br /><strong>可怜的小老鼠分析<embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></strong></p> 
      <h4 style=" text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text; font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif; ">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">有11瓶酒，只有一瓶有毒。喝酒之后，三天会死，只有三天时间。请问至少需要多少只老鼠，可以找出9瓶没有毒的酒。</p> 
      <h4 style=" text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text; font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">题目描述很简单，可我们仍要抓住要点：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>11瓶，1瓶有毒</p></li> 
       <li><p>喝酒之后，三天会死；只有三天时间-&gt;即使某一个老鼠没有被毒死，也不会有时间重复利用了</p></li> 
       <li><p>要使用最少个数的老鼠，要找到9瓶没有毒的</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">10瓶无毒的，为何要找到9瓶呢？老鼠开始喝酒，第一只要喝哪些，第二只要喝哪些呢？现在有什么依据么？显然酒瓶和老鼠都是一样的，不可区分的。那么怎么来选择哪些老鼠喝哪瓶酒，进而进行判断呢？这是这个题目的关键点、核心点。11个酒瓶，我们对其编号1-11，如下为二进制的表示，看完二进制的表示，也许很多同学，就明白了该如何选择。</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">编号</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">二进制</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0001</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0010</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0011</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0100</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">5</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0101</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">6</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0110</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">7</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0111</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">8</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1000</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">9</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1001</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">10</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1010</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">11</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">1011</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">观察每一位的0和1的分布情况，从右向左，第一位是1的，有6个情况；是0的，有5个情况。这样，我们可以让一只老鼠喝掉都是1的，然后又两种情况：</p> 
      <ul style="margin:15px 0px;padding:0px 0px 0px 30px;font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;"> 
       <li><p>老鼠死了，说明有毒的那个瓶子的二进制位从右到左第一位是1.</p></li> 
       <li><p>老鼠没死，说明有毒的那个瓶子的二进制位从右到左第一位是0.</p></li> 
      </ul> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">同样的，同时，另外两只老鼠测试第二位为1的瓶子以及第三位为1的瓶子，分别因为死或者没死，得到0、1的情况。三只老鼠，所有可能的情况如下</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">01情况</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">解释</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">000</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">三个老鼠都没死，只可能是1000号瓶子有毒，剩下10个都没毒</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">001</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">可能有毒的是0001、1001，去掉这两个，还有9个无毒</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">010</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0101有毒，10个无毒</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">011</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0011,1011可能有毒，9个确保无毒</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">100</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0100有毒，10个无毒</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">101</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0101有毒，10个无毒</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">110</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0110有毒，10个无毒</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">111</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">0111有毒，10个无毒</td> 
        </tr> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#f8f8f8;"> 
         <td><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">根据上面的表格，得到，至少需要三个老鼠。此类的题目分析的思路，就是这样的，要找到突破口：表示为二进制的形式。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">例如，1w瓶酒，只有一瓶有毒，只有三天时间，老鼠喝了之后，三天才会发作，至少需要多少只老鼠，才能找到有毒的酒？一样的思路，就是二进制位数多了一些。</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：逆序；及巧妙变换分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-05</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/138459/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><span style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:1.5em;line-height:1.7;">今日面试题：逆序</span></p> 
      <p><span style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:1.5em;line-height:1.7;"></span></p> 
      <p>一个整数，可以表示为二进制的形式，请给出尽可能多的方法对二进制进行逆序操作。</p> 
      <p>例如：10000110 11011000的逆序为 00011011 01100001</p> 
      <p><br /></p> 
      <p>=====================================<br /></p> 
      <p><span style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:1.5em;line-height:1.7;">巧妙变换分析</span></p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span></h4> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;">原题</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">输入数组[a1,a2,...,an,b1,b2,...,bn]，构造函数，使得输出为，[a1,b1,a2,b2,...,an,bn]，注意：方法要是in-place的。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个题目，并不是一个有难度的题目。描述很简单，尽管要求了in-place的方法，解决的方法还是很多的。在下面介绍方法的时候，我们都以[a1,a2,a3,a4,b1,b2,b3,b4]为例。</p> 
      <h4 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:1.7;cursor:text;font-size:1.2em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>in-place</h4> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">我们经常在面试题目中看到这个词，这个到底是什么意思呢？我们看看wiki中的说法：<em>In computer science, an in-place algorithm (or in Latin in situ) is an algorithm which transforms input using a data structure with a small, constant amount of extra storage space. </em>所以，如果这个题目的解法，需要O(n)的空间。则不是in-place的算法，in-place对应的是out-of-place。</p> 
      <h5 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:25px;cursor:text;font-size:1em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>最容易想到的方法</h5> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">通过观察输入输出的格式，直接通过将b1进行交换，直至目标的位置，其他元素也如此操作。直到完成变换。如下的过程：</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">确定b1的位置，b1要和前面3个元素依次交换。</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">确定b2的位置，b2要和前面的2个元素一次交换，同样为了保证in-place。注意交换次数少了一次。</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">依次确定b3和b4的位置，b4是最后的元素，不需进行交换，b3需要交换一次。</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">通过上面的分析，则整体的交换次数，3+2+1=6，不失一般性(n-1)+…+1，时间复杂度O(n^2)。</p> 
      <h5 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:25px;cursor:text;font-size:1em;font-family:helvetica, arial, freesans, clean, sans-serif;"><span class="mini-icon mini-icon-link"></span>特别的方法</h5> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">同样针对上面的例子：<br />第一步：交换最中间的一对元素，得到</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第二步：交换最中间的两对元素，得到</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">第三步：交换最中间的三对元素，得到</p> 
      <table style="border-spacing:0px;font-size:15px;margin:15px 0px;width:724px;overflow:auto;display:block;font-family:helvetica, arial, freesans, clean, sans-serif;line-height:25px;" class=" noBorderTable"> 
       <tbody> 
        <tr style="border-top-width:1px;border-top-style:solid;border-top-color:#cccccc;background-color:#ffffff;"> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b1</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b2</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b3</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">a4</td> 
         <td style="border:1px solid #dddddd;padding:6px 13px;">b4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">完毕，得到结果。<br />在上面的交换中，交换的次数分别为1,2,3，推而广之，1,…,n-1，则时间复杂度仍旧是O(n^2)的。</p> 
      <h5 style="text-rendering:optimizelegibility;margin:1em 0px 15px;padding:0px;line-height:25px;cursor:text;font-size:1em;font-family:helvetica, arial, freesans, clean, sans-serif;">in-place的O(n)方法</h5> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">这个问题，是存在O(n)时间复杂度的in-place算法的。但是，并不是很好理解。这里引用@xiaxia同学的说明，他发表在水木上。希望同学们能够理解：<br />首先，对2n=3^k - 1的情况下，k是整数。这时候可以通过几个cyclic shift解决。<br />每个cycle的起始位置是3^i, i=0,1,...,k-1. cycle里面元素下标的符合这样的模式(3^i&times;2^j) mod (2n+1)<br />举例说明：k=2时，2n=8.<br />假设一个数列是[1，2，3，4，5，6，7，8]<br />那么这几个cycle是<br />i=0, 3^i=1, [1,2,4,8,16,32] mod 9 = [1,2,4,8,7,5]<br />i=1， 3^i=3, [3,6] mod 9 = [3,6] <br />显然这些cycle都是闭合的，比如对[1,2,4,8,7,5]， 5&times;2 mod 9 = 1， 对[3,6] 6&times;2 mod 9 = 3<br /></p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">下面做这两个cyclic shift<br />做完第一个后：<br />[1，2，3，4，5，6，7，8] -&gt; [5，1，3，2，7，6，8，4]<br />做完第二个后：<br />[5，1，3，2，7，6，8，4] -&gt; [5，1，6，2，7，3，8，4]<br />搞定。<br /></p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">其次对2n！=3^k - 1的情况下，找一个最大的m，m满足2m=3^k - 1并且m 比如假设n=6，那么m=4.<br />假设一个素列A=[1，2，3，4，5，6，7，8，9，10，11，12]<br />首先A[m+1,...,n+m]做一个距离为m的右循环。<br />也就是[5,6,7,8,9,10]做一个距离为m的右循环，变成[7,8,9,10,5,6]<br />做完这个循环，[1，2，3，4，5，6，7，8，9，10，11，12]-&gt;[1，2，3，4，7，8，9，10，5, 6, 11，12]<br />然后对前2m项，做1的操作，[1，2，3，4，7，8，9，10，5, 6, 11，12]-&gt;[7，1，8，2，9，3，10，4，5, 6, 11，12] <br />然后对于下的2*(n-m)项[5，6，11，12]递归操作。<br />水木链接：http://www.newsmth.net/bbscon.php?bid=1032&amp;id=47005 <br />论文链接：http://vdisk.weibo.com/s/yXIrsIXU0qvF-</p> 
      <p style="font-family:helvetica, arial, freesans, clean, sans-serif;font-size:15px;line-height:25px;margin-top:15px;margin-bottom:15px;">【分析完毕】</p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
      <p><embed id="xunlei_com_thunder_helper_plugin_d462f475-c18e-46be-bd10-327458d045bd" type="application/thunder_download_plugin" height="0" width="0" /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：相差最大；及逆序分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-06</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/139720/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：相差最大</h3> 
      <p>给定无序数组A，在线性时间内找到i和j，j&gt;i，并且保证A[j]-A[i]是最大的。</p> 
      <p><br /></p> 
      <p>======================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">逆序分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">一个整数，可以表示为二进制的形式，请给出尽可能多的方法对二进制进行逆序操作。<br />例如：10000110 11011000的逆序为 00011011 01100001</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">题目中说是一个整数，对它的二进制进行逆序。并不是一个01字符串，或者01的数组。那么我们该如何解决这个问题呢？方法还是比较多的，有的中规中矩、有的非常巧妙。我们要掌握中规中规的方法，见识更多的巧妙的方法。慢慢的，能够举一反三，在遇到新的问题时，能够有灵思妙想。</p> 
      <h5 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 25px; cursor: text; font-size: 1em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>最直接的方法</h5> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">直接的方法，很容易想到：有如下代码： int v = 111;<br />int r = v;<br />int s = 32;&nbsp;<br />for (; 0 != v; v &gt;&gt;= 1) {&nbsp;<br />&nbsp;&nbsp;&nbsp;&nbsp;r &lt;&lt;= 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;r |= v &amp; 1;<br />&nbsp;&nbsp;&nbsp;&nbsp;s--;<br />}<br />r &lt;&lt;= s;<br />System.out.println(r);<br />代码比较好理解，取到v的最低位，作为r的最高位；v每取一次最低位，则右移一位；r每确定一位，则左移一位。同时记录移动了多少位，最终要补齐。</p> 
      <h5 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 25px; cursor: text; font-size: 1em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>通过查表的方法</h5> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">在遇到位操作的问题时，往往题目中限定了总的位数，比如这个题目，我们可以认为32位。这就给我们带来了一个以空间换时间的解决思路：查表法。位数是固定的，可以申请空间，存储预先计算好的结果，在计算其他的结果的时候，则查表即可。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">32位相对于查表来讲，还是太大了。既然这样缩小范围，32个bit，也就是4个byte。每个byte 8bit，可以表示0-255的整数。可以通过申请256大小的数组，保存这256个整数，二进制逆序之后的整数。然后将一个32位的整数，划分为4个byte，每一个byte查表得到逆序的整数：r1,r2,r3,r4。按照r4r3r2r1顺序拼接二进制得到的结果就是最终的答案。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这是一个思路，大家可以进一步思考，尝试。</p> 
      <h5 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 25px; cursor: text; font-size: 1em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>巧妙的方法</h5> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">我们这里主要分析这个巧妙的方法，核心思想是：分治法。即：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>逆序32位分解为两个逆序16位的</p></li> 
       <li><p>逆序16位分解为两个逆序8位的</p></li> 
       <li><p>逆序8位分解为两个逆序4位的</p></li> 
       <li><p>逆序4位分解为两个逆序2位的</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">最后一个2位的逆序，直接交换即可。也就是分治递归的终止条件。但是，在上面的过程中，还没有应用到位操作的技巧。根据动态规划的思想，我们可以自底向上的解决这个问题：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>每2位为一组，进行交换，完成2位逆序</p></li> 
       <li><p>每4位为一组，前面2位与后面2位交换，完成4位逆序</p></li> 
       <li><p>每8位为一组，前面4位和后面4为交换，完成8位的逆序</p></li> 
       <li><p>每16位为一组，前面8位和后面8位交换，完成16位的逆序</p></li> 
       <li><p>2组16位的交换，完成32位的逆序</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">通过下面的例子，详解上面的过程，我们以16位为例：10000110 11011000<br /></p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">经过4步，逆序完成。推而广之，总的时间复杂度为O(logn)，n是二进制的位数。这个方法可以推广到任意位。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">示例代码如下：<br />int v = 111;<br />v = ((v &gt;&gt; 1) &amp; 0x55555555) | ((v &amp; 0x55555555) &lt;&lt; 1);<br />v = ((v &gt;&gt; 2) &amp; 0x33333333) | ((v &amp; 0x33333333) &lt;&lt; 2);<br />v = ((v &gt;&gt; 4) &amp; 0x0F0F0F0F) | ((v &amp; 0x0F0F0F0F) &lt;&lt; 4);<br />v = ((v &gt;&gt; 8) &amp; 0x00FF00FF) | ((v &amp; 0x00FF00FF) &lt;&lt; 8);<br />v = ( v &gt;&gt; 16 ) | ( v &lt;&lt; 16);<br />System.out.println(v);<br />上面的思路理解了，代码不难理解。例如第二行，前边是取偶数位，后面是取奇数位，奇数位左移一位，偶数位右移一位，再取或，就是交换了奇数偶数位。也就是第一个步骤。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">基于位运算的一些巧妙的方法有很多。大家可以自行研究，后面会和大家分享更多的面试题目。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：合并总数；及相差最大分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-07</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/140766/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题</h3> 
      <p>求正数数组内和为指定数字的合并总数</p> 
      <p>例如：[5, 5, 10, 2, 3] 合并值为 15</p> 
      <p>合并总数为4，分别为:(5 + 10, 5 + 10, 5 + 5 + 2 + 3, 10 + 2 + 3)</p> 
      <p>=============================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">相差最大分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">给定无序数组A，在线性时间内找到i和j，j&gt;i，并且保证A[j]-A[i]是最大的。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目是比较简单的。很直接的，对于每一个A[j]，如果知道前面的元素中最小的元素min，则此时相差最大为A[j]-min。则，假设有一个数组M，M[j]表示[0,j-1]中最小的元素。这个遍历一边A，就可以完成构造M。再遍历一边数组，就可以找到相差最大的。我们举个例子看看M，以及是否有改进的空间。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">假设A={1,2,5,3,4}。通过一次遍历，得到M如下：</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这是一个极端的例子，但确实给了我们一个改进的方向，就是并不需要一个数组保存最小值，而只需要一个变量即可。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">上面的例子不明显，假定A={2,5,1,3,4}，过程如下：</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">j</td> 
         <td style="padding: 6px 13px; ">A[j]</td> 
         <td style="padding: 6px 13px; ">最小值m</td> 
         <td style="padding: 6px 13px; ">A[j]-m</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">0</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">5</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">3</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">0</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">3</td> 
         <td style="padding: 6px 13px; ">3</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">2</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">3</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">最终得到相差最大为3.这个例子，可以找到两个i，j。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">上面的过程是一个不断改进的一个过程。如果在面试的过程中，能够很好的完成，即使在面试官的指导之下，也是没有问题的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目，如果有的同学给出数组C,C[j]表示[0,j]中的最小值；数组B表示[j+1, n-1]中的最大值；这两个数组遍历两次可以得到，然后，再遍历一次A，对于每一个i，B[i]-C[i]中最大的，就是最终的值。这个思路也是ok的，只不过比我们开始提到的，更加一些，可以通过观察C，B的变化，找到规律，进行化简。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：序列生成；及合并总数分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-08</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/142017/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：序列生成</h3> 
      <p>给定一个表达式2^i*2^j，其中i，j为非负整数。请找到一种方法，生成如下序列：<br /></p> 
      <pre style="">2^0&nbsp;*&nbsp;5^0&nbsp;=&nbsp;1
2^1&nbsp;*&nbsp;5^0&nbsp;=&nbsp;2
2^2&nbsp;*&nbsp;5^0&nbsp;=&nbsp;4
2^0&nbsp;*&nbsp;5^1&nbsp;=&nbsp;5
2^3&nbsp;*&nbsp;5^0&nbsp;=&nbsp;8
2^1&nbsp;*&nbsp;5^1&nbsp;=&nbsp;10
2^4&nbsp;*&nbsp;5^0&nbsp;=&nbsp;16
2^2&nbsp;*&nbsp;5^1&nbsp;=&nbsp;20
2^0&nbsp;*&nbsp;5^2&nbsp;=&nbsp;25
...
...
...</pre> 
      <p>请大家开动脑筋，找到更多的方法。</p> 
      <p>=================================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">合并总数分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">求正数数组内和为指定数字的合并总数</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">比如[5, 5, 10, 2, 3] 合并值为 15 :<br />有4种 ： (5 + 10, 5 + 10, 5 + 5 + 2 + 3, 10 + 2 + 3)</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">有的时候，一个题目不能够立刻想到比较优化的想法，就可以先找到一个解决方案，然后根据方案的不足进行优化。而且这个时候，逆转一下思路，便会柳暗花明。由递归到动态规划，不就是如此么？</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">我们设定f(index，sum)表示数组从index开始到结束组成的sum的总数。那么，f(index, sum)可以表示为什么呢？ 我们这个题目，就是要最终求得f(0, 15)，从头开始分析，最终组成的和为15的可能组合中，可能包含第0个元素，也可能不包含, 原始数组为A：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>当包含第0个元素时，剩下的表示为f(1, 15-A[0])</p></li> 
       <li><p>不包含第0个元素时，剩下的表示为f(1, 15)</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">则，f(0, 15) = f(1, 15) + f(1, 15 - A[0])。依次递归。递归的终止条件是什么呢？对于f(index,sum):</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>当和小于等于0的时候，f(index,sum) = 0</p></li> 
       <li><p>当和小于sum的时候， f(index, sum) = f(index + 1, num);</p></li> 
       <li><p>当和等于sum的时候，f(index, sum) = 1 + f(index + 1, sum);</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">但是，上面的条件，并没有使用题目中，数组全是正数，也就是存在负数也可以。如果仅仅是正数，后两个改为：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>当和小于sum的时候， f(index, sum) = 0;</p></li> 
       <li><p>当和等于sum的时候，f(index, sum) = 1;</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">有一个条件，我们没有使用，也意味着提升的空间。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">可是，上面的方案，时间复杂度是指数级。怎么做一些改进呢？一般在对一个算法进行优化的时候，有哪些思路呢？尤其是这种时间很恐怖的？我想很多同学都有这个经验，就是空间换时间。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">大家可以想象动态规划的思想，大家看如下的状态转移方程：</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">dp[n][m]=dp[n-1][m]+dp[n-1][m-num[n-1]]</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">dp[n][m]表示前n个元素组成和为m的情况数。初始化dp[0][0]=1，其他为0。写出状态转移方程，大家也就明白了，为何要求全是正数了吧，直白一些，数组的索引，怎么可能为负呢？在计算的过程中，将和的情况保存下来，用空间换时间，整个算法的时间复杂度为O(n*m)，不再是指数级。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：找最大数；及序列生成分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-10</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/143952/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：找到最大数</h3> 
      <p>请构造程序，找到满足如下条件的最大数：<br /></p> 
      <p>假设最大数表示为，abcdefghihk..... 每一个字母表示一位，其中</p> 
      <p>abc，bcd，cde...以此类推，每三个一组，构成的数字是素数，也就是说abc, bcd, cde，等，都是素数，而且这些素数是互不相同的。</p> 
      <p><br /></p> 
      <p>=====================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">序列生成分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">给定一个表达式2^i*2^j，其中i，j为非负整数。请找到一种方法，生成如下序列：<br />2^0 * 5^0 = 1<br />2^1 * 5^0 = 2<br />2^2 * 5^0 = 4<br />2^0 * 5^1 = 5<br />2^3 * 5^0 = 8<br />2^1 * 5^1 = 10<br />2^4 * 5^0 = 16<br />2^2 * 5^1 = 20<br />2^0 * 5^2 = 25<br />...<br />...<br />...<br />请大家开动脑筋，找到更多的方法。<br /></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">阅读题目，要得到生成的数字序列是有序的，尽管题目中，并没有明说。这个题目的方法，是比较多的。我们在这里介绍几个。</p> 
      <h5 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 25px; cursor: text; font-size: 1em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>一个简单的方法</h5> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">很多同学，应该接触过丑数那个题目吧？这个题目相比之下，还要简单一些。i，j分别是2和5的指数, 则方法的过程如下:</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>i,j 从0开始，记录较小的值作为序列的当前生成值。则i=j=0时，最小值为1，就是第一个元素；</p></li> 
       <li><p>两个值都是最小元素，所以i和j，都自增1，在最小值1的基础之上乘以2和5得到2，5， 取较小的2作为序列的值，即2，第二个；</p></li> 
       <li><p>此时，只对i进行变化，自增1，在其上一个值的基础之上乘以2，即，2*2=4，再与5比较最小值</p></li> 
       <li><p>依次类推</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个方法的关键是i和j何时递增，以及用数组保存i和j计算的结果。 代码如下：</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; "><img src="http://chuansongme.com/static/img/essay/689/143952/1.jpg" onerror="" /></p> 
      <h5 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 25px; cursor: text; font-size: 1em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">其他方法</h5> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">上面方法的变种，还是比较多的。关键就是围绕着怎么每次产生最小的值。有的同学采用最小堆，有的同学采用栈。都是可以得到最终的结果的，但都没有上面的方法精炼。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">还有的同学提到用动态规划的方法，这也是一种很好的思路。对于dp[n]，判断其是否能够表示为2^i*5^j的形式，可以表示为如下的递归形式</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">dp[n] = ((n % 2 == 0) &amp;&amp; (dp[n/2])) || ((n % 5 == 0) &amp;&amp; (dp[n/5]))</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">并且，显而易见，存在重复利用的递归子过程。但是这个方法，对于n比较大的时候，空间会比较大。因为中间有太多的n不满足条件，我们仍然做了存储，进行了计算。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：周长最长；及找到最大数分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-11</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/144675/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：周长最长</h3> 
      <p>n根长度不一的棍子，判断是否有三根棍子可以构成三角形，并且找到周长最长的三角形。<br /></p> 
      <p><br /></p> 
      <p>=======================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">找到最大数分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">请构造程序，找到满足如下条件的最大数：<br />假设最大数表示为，abcdefghihk..... 每一个字母表示一位，其中<br />abc，bcd，cde...以此类推，每三个一组，构成的数字是素数，也就是说abc, bcd, cde，等，都是素数，而且这些素数是互不相同的。<br /></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">首先，这个最大的数存在么？一定存在的。因为，abc、bcd、cde等都是不同的素数。并不会出现环。总会结束。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">其次，面试题做得多了，要能够令灵活运用。并不是一定要有多么巧妙的方法，当然，一个大家都会追求一个巧妙的思路。但不好觉得暴力的方法，在任何条件下，都是拒之千里的。这个题目首先想到暴力解决，是没有问题的。三位的素数是有限的。这是可以暴力的基础。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">那么，出了暴力之外，还可以如何改进呢？我们首先对这个题目进行建模，构造一个有向图G。G中的节点就是三位素数，比如abc，bcd，def都是三位素数，则他们都是有向图G中的节点。其中，abc和bcd之间有abc指向bcd的边。abc、bcd则与def之间没有边。如此，构造完整G。大家可以在纸上画一画。所有的三位素数如下：<br /></p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">101, 103, 107, 109, 113,<br />127, 131, 137, 139, 149, 151, 157, 163, 167, 173,<br />179, 181, 191, 193, 197, 199, 211, 223, 227, 229,<br />233, 239, 241, 251, 257, 263, 269, 271, 277, 281,<br />283, 293, 307, 311, 313, 317, 331, 337, 347, 349,<br />353, 359, 367, 373, 379, 383, 389, 397, 401, 409,<br />419, 421, 431, 433, 439, 443, 449, 457, 461, 463,<br />467, 479, 487, 491, 499, 503, 509, 521, 523, 541,<br />547, 557, 563, 569, 571, 577, 587, 593, 599, 601,<br />607, 613, 617, 619, 631, 641, 643, 647, 653, 659,<br />661, 673, 677, 683, 691, 701, 709, 719, 727, 733,<br />739, 743, 751, 757, 761, 769, 773, 787, 797, 809,<br />811, 821, 823, 827, 829, 839, 853, 857, 859, 863,<br />877, 881, 883, 887, 907, 911, 919, 929, 937, 941,<br />947, 953, 967, 971, 977, 983, 991, 997<br /></p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">有向图G构造完毕之后，该如何找到最大的数呢？其实就是找到G中，最长的路径。可以采用动态规划来解决。dp[i]表示，到节点i为止的最长路径。状态转移方程可以表示为：</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">dp[i] = max(dp[j] + 1), 其中, 节点j是有边指向i的所有节点。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">在实现过程中，要注意保存路径，这样才能得到最大数。例如，得到最大的j为j1，则 保存prev[i] = j1。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">通过计算，最终得到最大数为：</p> 
      <h3 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>9419919379773971911373313179</h3> 
      <p>【分析完毕】</p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：蚂蚁蚂蚁；及周长最长分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-12</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/145561/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：蚂蚁蚂蚁</h3> 
      <p>n只蚂蚁以每秒1cm的速度在长为Lcm的竿子上爬行。蚂蚁爬到终点会掉下来。两只蚂蚁相遇时，只能调头爬回去。对于每一只蚂蚁i，给定其距离竿子左端的距离x[i]，但是我们不知道蚂蚁的初始朝向。计算，所有蚂蚁掉落需要的最短时间和最长时间。</p> 
      <p><br /></p> 
      <p>==========================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">周长最长分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">n根长度不一的棍子，判断是否有三根棍子可以构成三角形，并且找到周长最长的三角形。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">首先能够构成三角形的三根棍子需要满足什么条件呢？这个简直就是常识了：</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">最长棍子的长度 &lt; 另外两根棍子的长度和</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这是重要条件。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">那么接下来该怎么办呢？暴力法——不要总觉得这是耻辱，要这样想：这是一个好开端。三条边，三层循环。时间复杂度为O(n^3)。这在一般的题目中，都是无法接受的。如何改进的呢？棍子有长有短，我们要找到的是周长最长的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">我们可以对棍子的长度，从大到小排序。从最长的开始找符合构成三角形条件的。找到的第一个就是周长最长的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">下面我们来说明，为什么第一个找到的，就是最长的。假设我们有如下长度的棍子，并且长度一次递减。</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">a</td> 
         <td style="padding: 6px 13px; ">b</td> 
         <td style="padding: 6px 13px; ">c</td> 
         <td style="padding: 6px 13px; ">d</td> 
         <td style="padding: 6px 13px; ">e</td> 
         <td style="padding: 6px 13px; ">f</td> 
         <td style="padding: 6px 13px; ">g</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">假设opq是第一个可以构成三角形的棍子，假设还存在xyz，构成三角形，且，x+y+z &gt; o + p + q, 因为opq是第一个三角形，则x&lt;=o。则y+z &gt; p+q，任取y、z，则可以找到，o，y，z为一个三角形，周长大于opq，并且，这个三角形，在opq之前找到(因为y或者z，大于p或者q，先遍历到)。这个与adf是第一个的假设是矛盾的。所以，不存在xyz构成三角形，周长大于adf。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">那么如果找到第一个能够构成三角形的三根棍子呢？现在棍子的长度已经是排序的。</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">a</td> 
         <td style="padding: 6px 13px; ">b</td> 
         <td style="padding: 6px 13px; ">c</td> 
         <td style="padding: 6px 13px; ">d</td> 
         <td style="padding: 6px 13px; ">e</td> 
         <td style="padding: 6px 13px; ">f</td> 
         <td style="padding: 6px 13px; ">g</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">很明显，我们只需要依次考虑，相邻三个元素是否能够构成三角形即可。因为，如果acd构成三角形，abc一定是，而且，周长还要更长。所以这里O(n)，就可以找到周长最长的三角形。前面排序是O(nlogn)。则，总的时间复杂度是O(nlogn).</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：数字游戏；及蚂蚁蚂蚁分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-13</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/146728/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：数字游戏</h3> 
      <p>盒子中有n张卡片，上面的数字分别为k1,k2,...,kn。你有4次机会，每抽一次，记录下卡片上的数字，再将卡片放回盒子中。如果4个数字的和等于m。则你就赢得游戏，否则就是输。直觉上，赢的可能性太低了。请你给出程序，判断是否有赢的可能性。尽量提高方法的效率。</p> 
      <p><br /></p> 
      <p>====================================<br /></p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">蚂蚁蚂蚁分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">n只蚂蚁以每秒1cm的速度在长为Lcm的竿子上爬行。蚂蚁爬到终点会掉下来。两只蚂蚁相遇时，只能调头爬回去。对于每一只蚂蚁i，给定其距离竿子左端的距离x[i]，但是我们不知道蚂蚁的初始朝向。计算，所有蚂蚁掉落需要的最短时间和最长时间。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">根据题目描述，我们不知道蚂蚁的初始朝向，所以两种都有可能。此时，我们可以先固定第0个蚂蚁的方向，然后再处理其他的蚂蚁。这是一个递归的思路，并且每个蚂蚁有两个选择，一共2^n种情况，计算每一种情况下，所有蚂蚁掉落的时间，选择最短的、最大的则得到答案。这个题目的时间复杂度是指数级的。真真有些高了，那么如何改进呢？</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">我们在摘要中说道，这个题目其实是考察大家想象力的。想象力在哪里呢？我们首先来看看最短时间的情况，直觉上来讲，所有的蚂蚁都超最近的一端走，是需要最短时间的。那么这时，会不会发生碰撞呢？显然是不能的，A和B是两只不同的蚂蚁。</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">…</td> 
         <td style="padding: 6px 13px; ">B</td> 
         <td style="padding: 6px 13px; ">A</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">…</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">假设A到左端近，距离为LA&lt;L/2。B到右端近，距离为LB&lt;L/2。LA+LB&lt;L。但从上表看，LA+LB显然要大于L。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">下面考虑最长时间的情况，也是该发挥想象力的地方。当两只蚂蚁相遇的时候，本来是要调头爬回去的。这与直接交错走过去有什么不同呢？蚂蚁的速度是一样的。大家可以举几个具体的例子，看看这两种情况，差别在哪里。例如:</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">B</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">A</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>当相遇调头时，A和B都调下来的最长时间是4秒。A向左一格，然后调头向右三格</p></li> 
       <li><p>当相遇交错走过时，A向左走三格掉落，B向右走四格掉落。则最长时间为4秒。</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这并不是巧合。可以认为是同样的情况。主要的原因就是蚂蚁的速度是相同的，可以认为是独立的。这样，求所有蚂蚁都掉落的最长时间，就是找离某一端距离最长的蚂蚁，然后向着这一端走，所需要的时间。算法的时间复杂度为O(n)。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">后面求最长时间的关键就是，发挥想象，找到调头和交错走过实际上是一样的。就搞定了。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：七夕鹊桥；及数字游戏分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-14</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/147817/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：七夕鹊桥</h3> 
      <p>有n对喜鹊。每一对可以表示为(x,y)，x、y是喜鹊的编号，并且任意一对，x总是小于y。(c,d)可以连接在(a,b)之后，当且仅当b&lt;c。多对喜鹊连接在一起，就构建成了鹊桥。给定n对喜鹊，请你构建最长的鹊桥，来帮助有情人相会。<br /></p> 
      <p><br /></p> 
      <p>=========================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">数字游戏分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">盒子中有n张卡片，上面的数字分别为k1,k2,...,kn。你有4次机会，每抽一次，记录下卡片上的数字，再将卡片放回盒子中。如果4个数字的和等于m。则你就赢得游戏，否则就是输。直觉上，赢的可能性太低了。请你给出程序，判断是否有赢的可能性。尽量提高方法的效率。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目，和之前Google的一个概率的题目是类似的，当然解决的方法也是类似的，思路大家可以找找前面的题目，不再赘述。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目其实想和大家讲一下思考问题、改进解法的思路。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目最直接的方法就是四重循环遍历，n^4的时间复杂度，比较恐怖，但确实一个很好的起点。不用觉得很丢人，只要我们持续改进即可。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">假设a，b，c是k1到kn中的三个数字，是否存在d使得，a+b+c+d=m？d在k1到kn中。和题目中的意思是一样的，变换等式如下：</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">d = m - a - b - c</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">如果满足上式，就是说，要在k1到k2中查找d，即：查找m - a - b - c，找到就存在；找不到，就是不存在。查找有线性查找，二分查找等。四重循环最内一层循环，可以认为是线性的查找，如果想更快一些，可以应用二分查找，而二分查找需要k1到kn是排序的，则先对n个数字进行排序，时间复杂度O(nlogn)。然后最内一层循环，改为二分查找，时间复杂度为O(n^3logn)。所以总的时间复杂度为O(n^3logn)。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">经过上面的分析，我们可以得到启发，既然可以提出一个d，那么就可以再提出一个c。将a+b+c+d=m转换为c+d=m-a-b。这样，我们可以枚举k1到kn的两个数的和，然后对n2个和，进行排序，时间复杂度为o(n^2logn)。然后遍历n^2个和，设每一个和为pair，查找是否存在m-pair，同样二分查找，时间复杂度为O(n^2logn)。总的时间复杂度为O(n^2logn)。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">经过上面的层层分析，大家能否发现，对于算法的持续改进，还是有一些窍门的，大家细心领悟。领悟得多了，必会有更大的进步。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目其实解法比较多，出了上面介绍的，还有别的方法，比如应用一些数据结构。大家可以开动自己的脑筋，不断的发散。不要为了完成一个题目而去思考。应该尝试不同的思路，即使思路的时间、空间的复杂度并不好，但是只要能够分析清楚。这就是很大的进步。这些也是我们给大家介绍面试题的一个初衷。我们尽可能的将问题分析透彻，希望能够给大家以启迪。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：模糊距离；及七夕鹊桥分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-15</span> <span href="javascript:;" class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/148857/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：模糊距离</h3> 
      <p>X和Y都是只有0和1组成的字符串。D(X,Y)称为模糊距离，定义如下：<br /></p> 
      <ul style="list-style-type: disc;" class=" list-paddingleft-2"> 
       <li><p>首先删除X和Y从头开始的公共子串</p></li> 
       <li><p>然后将X和Y剩下部分的长度相加得到模糊距离</p></li> 
      </ul> 
      <p>例如D(1000,1111)，首先，删除子串“1”，然后剩下“000”和“111”长度都是3，相加为6，则D(1000,1111)=6。<br /></p> 
      <p>例如D(101,1100)，首先删除公共子串“1”，然后剩下&quot;01&quot;和&quot;100&quot;长度分别为2，3，相加为5，则D(101,1100)=5。</p> 
      <p><br /></p> 
      <p>问题是，给定n个只有0和1的字符串，如：</p> 
      <p>1111<br /></p> 
      <p>1000</p> 
      <p>101</p> 
      <p>1100</p> 
      <p>...</p> 
      <p>请找到最大的模糊距离，字符串总数为n，字符串最长为m。</p> 
      <p><br /></p> 
      <p>================================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">七夕鹊桥分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">有n对喜鹊。每一对可以表示为(x,y)，x、y是喜鹊的编号，并且任意一对，x总是小于y。(c,d)可以连接在(a,b)之后，当且仅当b&lt;c。多对喜鹊连接在一起，就构建成了鹊桥。给定n对喜鹊，请你构建最长的鹊桥，来帮助有情人相会。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">首先，要理解这个题目的意思。具体例子说明，给定下面的例子：</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">(15,40)</td> 
         <td style="padding: 6px 13px; ">(5,8)</td> 
         <td style="padding: 6px 13px; ">(1,10)</td> 
         <td style="padding: 6px 13px; ">(30,31)</td> 
         <td style="padding: 6px 13px; ">(34,35)</td> 
         <td style="padding: 6px 13px; ">(9,20)</td> 
         <td style="padding: 6px 13px; ">(36,37)</td> 
         <td style="padding: 6px 13px; ">(2,4)</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">其中，(2,4)和(5,8)能够连接起来，(5,8)和(9,20)能够连接起来，则它们可以都连接起来，为(2,4)(5,8)(9,20)。这一段鹊桥，长度为3。依次类推，还有其他的情况。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">然后，理解了题意，该如何解决呢？假设(a,b)(c,d)(e,f)是可以连接起来的三对喜鹊。则它们的关系如下： b&lt;c,d&lt;e，有根据a&lt;b,c&lt;d,e&lt;f。得到，a&lt;b&lt;c&lt;d&lt;e&lt;f，即b&lt;d&lt;f(从a&lt;c&lt;e出发考虑，也是一样的)。我们可以想象，以每一对喜鹊的第二只编号为基准，进行排序，最终的结果，可以通过如下列表产生。</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">(2,4)</td> 
         <td style="padding: 6px 13px; ">(5,8)</td> 
         <td style="padding: 6px 13px; ">(1,10)</td> 
         <td style="padding: 6px 13px; ">(9,20)</td> 
         <td style="padding: 6px 13px; ">(30,31)</td> 
         <td style="padding: 6px 13px; ">(34,35)</td> 
         <td style="padding: 6px 13px; ">(36,37)</td> 
         <td style="padding: 6px 13px; ">(15,40)</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">怎么找到最长的鹊桥呢？其实就是在上表中，找到最长递增子序列，只不过，在比较连个喜鹊对(a,b)(c,d)的时候，是b和c进行比较即可。这个时间复杂度是O(n^2)的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">可否在从方法的角度，进一步考虑呢？</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">大家思考一个问题，最长的鹊桥，是否会包括第一对喜鹊。我们假设，不包括第一对喜鹊。最长的鹊桥为s1,s2…sk。每一个si，可以表示为(xi,yi)。s0，(x0,y0)为第一对喜鹊。我们有y1 &lt; x2, 并且 y0 &lt; y1。y0last y 则保留，否则抛弃，最终留下来的，就是最长的鹊桥。如上面的例子，得到</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">(2,4)</td> 
         <td style="padding: 6px 13px; ">(5,8)</td> 
         <td style="padding: 6px 13px; ">(9,20)</td> 
         <td style="padding: 6px 13px; ">(30,31)</td> 
         <td style="padding: 6px 13px; ">(34,35)</td> 
         <td style="padding: 6px 13px; ">(36,37)</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">长度为6。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">后面这个思路，不够严谨，没有阐述严格的证明，但是存在的。留给大家思考吧。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">为了美好的爱情，大家都尽力了么？</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：排列木桩；及模糊距离分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-16</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/149786/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：排列木桩</h3> 
      <p>有N个木桩，高度分别为1到N。你现在要将木桩排列为一行，当你从左边看的时候，只看到L个木桩(因为，一些高的木桩会挡住矮的木桩)；从右边看时，只看到R个木桩。给定N、L、R，你该如何排列木桩呢？<br /></p> 
      <p>例1：N=3,L=2,R=1，可行的排列方案只有{2,1,3}。</p> 
      <p>例2：N=3,L=2,R=2，可行的排列方案有{1,3,2}{2,3,1}</p> 
      <p><br /></p> 
      <p>======================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">模糊距离分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">X和Y都是只有0和1组成的字符串。D(X,Y)称为模糊距离，定义如下：<br />首先删除X和Y从头开始的公共子串<br />然后将X和Y剩下部分的长度相加得到模糊距离<br />例如D(1000,1111)，首先，删除子串“1”，然后剩下“000”和“111”长度都是3，相加为6，则<br />D(1000,1111)=6。<br />例如D(101,1100)，首先删除公共子串“1”，然后剩下&quot;01&quot;和&quot;100&quot;长度分别为2，3，相加为5，则<br />D(101,1100)=5。<br /></p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">问题是，给定n个只有0和1的字符串，如：<br />1111<br />1000<br />101<br />1100<br />...<br />请找到最大的模糊距离，字符串总数为n，字符串最长为m。<br /></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目描述比较长，但实际上，并不难。只要耐心，看完题目，即可。描述也不晦涩。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">直接想来，对于每一个01字符串，与其他的每一个01字符串进行模糊距离的计算，时间复杂度是O(nm)，遍历完n个字符串，总的时间复杂度是O(n^2*m)。这个我们可以称为暴力法。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">如何改进上面的方法的，主要是指缩小时间复杂度。一个非常通用的方法，就是以空间换时间。如何换呢？对于模糊距离的第一个条件，我们想到什么呢？公共前缀，不知道同学们，联想到树形结构：trie树没有。例如：给定000、001、0010，我们构造如下的trie树。</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">构造过程中，1为左子树，0为右子树。模糊距离的第一个条件是，去掉公共前缀，则计算时，两个字符串，要有公共前缀，也就意味着，只需要考虑开始分叉的节点，左右子树，可以有一个没有。这样，我们考虑第一个分叉的节点：0，然后可以计算第二部分了，如何计算剩下长度相加呢？尤其，为了找到模糊距离的最大值，我们求得当前节点的左子树的最大深度以及右子树的最大深度，两者相加，及得到一个模糊距离，为3。然后考虑1节点，右子树为空，则模糊距离为1。综合，最大的模糊距离为3。这里有一个小小的技巧，构建的过程中，可以在节点中，存储左右子树的高度，并随着加入新的字符串，更新左右子树的高度。总的时间复杂度为O(nm)。 根据上例，存储的左右子树的高度值变化如下 (left_height, right_height):</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>left_height: 左边子树的高度</p></li> 
       <li><p>right_height: 右边子树的高度</p></li> 
      </ul> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(0,2)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(0,1)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(0,0)</td> 
        </tr> 
       </tbody> 
      </table> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(0,2)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(1,1)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">1(0,0)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(0,0)</td> 
        </tr> 
       </tbody> 
      </table> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(3,2)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(2,1)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">1(1,0)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">0(0,0)</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">0(0,0)</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">浪漫的丁神和美女迪迪</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-17</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/150824/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>丁神与美女迪迪奥森跑步，丁神配速（配速指每公里所需用的时间）5.0，迪迪配速6.0，丁神跑大圈10公里，美女跑小圈5公里(奥森路线是8形，2.5公里处分南北区，大圈要去北区5公里)。他俩一同出发，问丁神啥时候能再次追上美女？你会发现结果是多么的浪漫。</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：修理栅栏；及排列木桩分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-18</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/151362/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 1.5em; line-height: 1.7; ">今日面试题：修理栅栏</span></p> 
      <p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;">为了修理栅栏，需要将很长的木板锯为N块，长度分别为L1,L2...LN。<span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">锯断一块儿木板，需要一定的开销，开销记为木板的长度。例如，长度为21的木板，<span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">锯为三块，长度分别为5，8，8。如下按照如下的顺序据断：</span></span></span></span></p> 
      <ol style="list-style-type: decimal;" class=" list-paddingleft-2"> 
       <li><p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">首先锯断21为13和8两块儿，开销为21</span></span></span></span></p></li> 
       <li><p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">然后锯断13为8和5两块儿，开销为13</span></span></span></span></p></li> 
      </ol> 
      <p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">总的开销为34。但也可以按照如下的顺序：</span></span></span></span></p> 
      <ol style="list-style-type: decimal;" class=" list-paddingleft-2"> 
       <li><p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">首先锯断21为16和5两块儿，开销为21</span></span></span></span></p></li> 
       <li><p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">然后锯断16为8和8两块儿，开销为16</span></span></span></span></p></li> 
      </ol> 
      <p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">总的开销为37。比34要大。<br /></span></span></span></span></p> 
      <p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;">问题是，给定N，以及每一块儿的长度。如何保证最小的开销。尽量采用高效的方法。</span></span></span></span></p> 
      <p><span style="font-family:Helvetica, arial, freesans, clean, sans-serif"><span style="font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px;"><br /></span></span></span></span></p> 
      <p><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 1.5em; line-height: 1.7; ">＝＝＝＝＝＝＝＝＝＝＝＝＝</span></p> 
      <p><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 1.5em; line-height: 1.7; ">排列木桩</span></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">有N个木桩，高度分别为1到N。你现在要将木桩排列为一行，当你从左边看的时候，只看到L个木桩(因为，一些高的木桩会挡住矮的木桩)；从右边看时，只看到R个木桩。给定N、L、R，你该如何排列木桩呢？<br />例1：N=3,L=2,R=1，可行的排列方案只有{2,1,3}。<br />例2：N=3,L=2,R=2，可行的排列方案有{1,3,2}{2,3,1}<br /></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">开始排列木桩的时候，应该如何选取第一根木桩呢？一个很直接的选择就是先确定最高的木桩的位置，也就是N。因为，无论从左到右，还是从右到左看，都要到最高停下来。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">确定了最高的木桩之后，无论从哪一边看，都至少有一个木桩。接下来，该如何处理？想必大家已经想到了，开始递归呗。左右两边，也同样是先确定最高的木桩的位置，依次递归下去。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">构造的方法，是比较简单地。但，往往这个时候面试题并没有结束。面试官，会进一步问：给定NLR，有多少种排列木桩的方法呢？从一个构造问题，转变为一个计数的问题。该如何做呢？方法仍旧是递归，我们尝试写出递归表达式。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">假设，b(N,L,R)表示排列方案的总数。f(N, L)表示N个木桩，排列得到从左边能够看到L个木桩的方案总数。我们从f的递归形式入手分析。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">首先，f(N,N)=1。从左到右，从低到高排列，只有一个方案。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">然后，f(N,M)=0,当N&lt;M时。显而易见。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">其次，f(N,1)=(N-1)!。当只看到一个木桩的时候，即最高的木桩排在最左边，其他的木桩无论怎么排列都可以。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">再次，假设最高的木桩放在从左边开始的第k个位置，则，我们要在剩下的N-1个木桩里面，选取k-1个木桩放在最高木桩的左边，并且，找到能看到L-1个木桩的方案数(因为最高的木桩一定能看见，所以是L-1个)，此时剩下的N-K个木桩，可以任意排列，得到递归表达式如下：</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; "><em>f(N, L) = sum_{L&lt;=k&lt;=N} (N-1 选择 k-1) * f(k-1, L-1) * (N-k)!&nbsp;</em></p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个式子，是仅仅考虑了总左边看到L个柱子的情况，再需要考虑，从右边看，有R根柱子的方案呢？其实很简单了，剩下的N-k个柱子，不要任意排列，要保证从右边能够看到R-1个柱子即可。所得递归式如下：</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; "><em>b(N,L,R) = sum_{L&lt;=k&lt;=N-R+1} (N-1 选择 k-1) * f(k-1, L-1) * f(N-k,R-1)&nbsp;</em></p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">如何？并不是很难的题目，只要抓住从哪根木桩开始即可。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">其实，这个题目从最矮的木桩开始，也可以写出漂亮、而且更简单递归表达式的。简单提示：</p> 
      <ul style="list-style-type: disc;" class=" list-paddingleft-2"> 
       <li><p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">何时能够看到最矮的木桩？</p></li> 
       <li><p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">看到了如何？</p></li> 
       <li><p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">看不到，又如何？</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：兄弟数字；及修理栅栏分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-19</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/151919/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：兄弟数字</h3> 
      <p style="text-align: left;">给定一个数X，他的兄弟数Y定义为：是由X中的数字组合而成，并且Y是大于X的数中最小的。例<span style="font-family:Arial, Liberation Sans, DejaVu Sans, sans-serif"><span style="font-size: 14px; line-height: 18px;">如，38276的兄弟数字为38627。给定X，求Y。</span></span></p> 
      <p style="text-align: left;"><span style="font-family:Arial, Liberation Sans, DejaVu Sans, sans-serif"><span style="font-size: 14px; line-height: 18px;"><br /></span></span></p> 
      <p style="text-align: left;"><span style="font-family:Arial, Liberation Sans, DejaVu Sans, sans-serif"><span style="font-size: 14px; line-height: 18px;">=======================================</span></span></p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">修理栅栏分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">为了修理栅栏，需要将很长的木板锯为N块，长度分别为L1,L2...LN。锯断一块儿木板，需要一定的开销，开销记为木板的长度。例如，长度为21的木板，锯为三块，长度分别为5，8，8。如下按照如下的顺序据断：<br /></p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>首先锯断21为13和8两块儿，开销为21<br /></p></li> 
       <li><p>然后锯断13为8和5两块儿，开销为13<br /></p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">总的开销为34。但也可以按照如下的顺序：<br /></p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>首先锯断21为16和5两块儿，开销为21<br /></p></li> 
       <li><p>然后锯断16为8和8两块儿，开销为16<br /></p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">总的开销为37。比34要大。<br />问题是，给定N，以及每一块儿的长度。如何保证最小的开销。尽量采用高效的方法。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目，要如何分析？这切锯成N块的方法太多了。如何入手呢？其实，题目中的两个例子，都可以表明，我们可以将切割的过程用二叉树表示：</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">21</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">13</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">8</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">8</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">5</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">以及</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">21</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">16</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">5</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">8</td> 
         <td style="padding: 6px 13px; "><br /></td> 
         <td style="padding: 6px 13px; ">8</td> 
         <td style="padding: 6px 13px; "><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">根据上面两棵二叉树，得到开销的计算方法：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>第一棵树，开销34 = 8 * 2 + 5 * 2 + 8 * 1 = 34</p></li> 
       <li><p>第二颗树，开销37 = 8 * 2 + 8 * 2 + 5 * 1 = 37</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">也就是所有的叶子节点的长度乘以深度。叶子节点，就是各个木块儿的长度。从上面的式子，我们可以得出，要想开销最小，树的高度是不变的，那就一定要越短的木板，深度越深，即可。而且，因为一次锯开，肯定是两块儿，所以，要保证整个开销最小，则最短的和次短的木板一定是兄弟，这样，可以递归使得，父亲节点的开销也是最小的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这样，求的最小开销就很简单了，去最短和次短木板，加起来，得到一个开销，假设L1是最短的，L2是次短的。则递归处理(L1+L2)以及剩下的木板即可。这个复杂度是O(N^2)的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">那么是否有更高效的方法呢？上面的方法，是从底向上计算的。锯的时候，如何做呢？从最长的开始，每次都把最长的锯掉。这样排序O(NlogN)。从最大的开始锯。解决。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">还有呢？前面的方法，在取最短的时候，可以采用优先级队列。整个事件复杂度为O(NlogN)，不过空间就是O(N)了。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：格点数目；及兄弟数字分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-20</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/152991/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：格点数目</h3> 
      <p>给定平面上的两个格点P1(x1,y1)，P2(x2,y2)，在线段P1P2上，除P1、P2外，一共有多少个格点？格点定义为x和y都是整数的点。</p> 
      <p>====================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">兄弟数字分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">给定一个数X，他的兄弟数Y定义为：是由X中的数字组合而成，并且Y是大于X的数中最小的。例如，38276的兄弟数字为38627。给定X，求Y。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目当然有暴力的方法，列出所有的排列组合，然后然后找到大于X中，最小的Y。即，找到兄弟数字。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">那有没有更好的方法呢？不想对所有情况进行穷举，就要想办法，尽可能缩小要处理的范围，一般的思路，从右边开始，两两交换，查看是否可以找到Y，最开始考虑两位，进而考虑三位，依次类推，那么如何确定，要考虑多少位呢？假设X的形式如下：x1x2x3...xky1y2y3y4，并且其中y1&gt;y2&gt;y3&gt;y4，xk&lt;y1。则，交换不可能在y1y2y3y4内部发生，以为这几个数字，任意两个交换，X值就变小了，而Y是大于X的。所以y1到y4是不行的。那么xk行么？完全可以，至少和y1交换，数字变大了。 那么到底要和哪个数字交换，进而保证变化最小呢？很显然，要找到y1到y4中，大于xk的值里，最小的一个。这个值交换之后，既保证了不会增加太多，也不会减少。假设就是y3，此时Y是x1x2x3...y3y1y2xky4,这个数是从y3那位开始，大于X的，无论后面的几位是什么。显然易见，最小的Y就是y1y2xky4要从小到大排序的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">下面以一个具体例子来说明上述过程：</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">3</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">7</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">6</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">首先找到，从右边开始的递增的、尽可能长的数位，这里是641。</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">3</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">7</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">(6</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">1)</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">则，选取前一位数字2，进行交换。641中，大于2的最小的值是4，则作如下交换：</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">3</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">7</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">(6</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">1)</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">为了得到最小值，对621，从小到大进行排序，得到</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">3</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">7</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">4</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">6</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">则，Y为34724126.</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：消失的数字；及格点数目分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-22</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/154805/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 1.5em; line-height: 1.7; ">今日面试题：消失的数字</span></p> 
      <p>从1到n，n个数字，每个数字只出现一次。现在，随机拿走一个数字，请给出方法，找到这个数字。</p> 
      <p>如果随机拿走两个数字呢？</p> 
      <p>如果随机拿走k个数字呢？</p> 
      <p>=============================================</p> 
      <p><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 1.5em; line-height: 1.7; ">格点数目分析</span><br /></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">给定平面上的两个格点P1(x1,y1)，P2(x2,y2)，在线段P1P2上，除P1、P2外，一共有多少个格点？格点定义为x和y都是整数的点。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这是一个简单的题目，方法比较多了，比如，首先求的直线的方程式：y=ax+b。然后在x轴，从x1+1开始，到x2-1结束，将每一个整数带入上面的方程式，得到y值。如果y满足y1&lt;y&lt;y2，则找到一个格点，遍历完毕之后，得到全部的格点。时间复杂度，O(|x2-x1|)。也是比较快的。还有更暴力的方法，时间复杂度为O(|x2-x1|*|y2-y1|)，从这个大家可以看出来，完全是遍历每一个整数点，看是否落在直线上。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">那么有没有更快的方法呢？这个题目实际上是求|x1-x2|和|y1-y2|的最大公约数，格点数目就是最大公约数减取1。大家可以画画图，验证这个方法。最好是画一个棋盘。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">大家还记得最大公约数是怎么计算的么？辗转相除法。设a和b的最大公约数为gcd(a,b)，则gcd(a,b) = gcd(b, a%b)。公式比较简单，改如何分析时间复杂度呢？是否更快呢？</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">我们假设a&gt;b，则有如下的过程</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">gcd(a, b) = gcd(b, a%b) = gcd(a%b, b % (a % b)) …</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">一直递归到结束，gcd(x, 0) = x。</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>当b&gt;a/2时，a % b = a - b &lt; a / 2</p></li> 
       <li><p>当b&lt;a/2时，a % b &lt; b &lt; a / 2</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">每一次新的递归，第一个参数都要小于原来的一半，所以，估计其时间复杂度在O(log max(a,b))以内，这里的a和b分别为|x1-x2|和|y1-y2|。比线性的解决方案要快。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：重排数组；及消失的数字分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-23</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/155979/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：重排数组</h3> 
      <p>有原数组S和目标数组T两个数组，它们分别是0-n-1 n个数字的某一种排列的结果。请给出程序，完成从S到T的变换，注意：只允许使用一种操作：数组中的其他元素可以0交换。<br /></p> 
      <p>例如：S={0,1,2}，T={0,2,1}。变换过程中，只允许1和2于0进行交换。下面是一种可行方法：{0,1,2}=&gt;{2,1,0}=&gt;{2,0,1}=&gt;{0,2,1}</p> 
      <p><br /></p> 
      <p>===============================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">消失的数字分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">从1到n，n个数字，每个数字只出现一次。现在，随机拿走一个数字，请给出方法，找到这个数字。<br />如果随机拿走两个数字呢？<br />如果随机拿走k个数字呢？<br /></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">看微博上，有的同学说，题目描述不清楚，最好有一个例子说明。确实应当如此。争取以后多用例子进一步说明题意。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目的含义是：n-1互不相同的整数，取值范围是[1,n]，请找到1-n中，没有出现的整数(好像更难理解了:))。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">当缺少一个数字的时候，很简单，计算1到n的和sum_more，然后再将n-1个整数求和，得到sum_less，则消失的数字就是(sum_more - sum_less)。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">如果消失两个数字呢？按照上面的方法，假设消失的两个数字分别为a和b，1 &lt;= a, b &lt;= n，我们可以得到a + b = sum_more - sum_less。只有一个等式，无法确定a和b的值是多少。根据我们以前学习解方程式的经验，我们还需要一个等式，才能确定a和b的值。现在已知的条件，就只有sum_more,sum_less，这两个分别是n个数的和，以及n-2个数的和，则最终还是要在这些数字的运算形式上做文章。考虑如下两个形式：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>square_sum_more = n个数的平方和</p></li> 
       <li><p>square_sum_less = n-2个数的平方和</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">有，square_sum_more - square_sum_less = a ^ 2 + b ^ 2。又构造了一个式子。这样解如下两个式子，得到a和b，即可：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>square_sum_more - square_sum_less = a ^ 2 + b ^ 2</p></li> 
       <li><p>sum_more - sum_less = a + b</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">解比较简单了，由第二个式子得：b = sum_more - sum_less - a，带入第一个式子，则第一个式子，只有a。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">如果消失三个数字呢？根据上面处理两个数字的情况，有如下的式子：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>sum_more - sum_less = a + b + c</p></li> 
       <li><p>square_sum_more - square_sum_less = a ^ 2 + b ^ 2 + c ^ 2</p></li> 
       <li><p>cube_sum_more - cube_sum_less = a ^ 3 + b ^ 3 + c ^ 3</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">解出a，b，c即可。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">依次类推，当消失k个数字的时候，算法的时间复杂度为O(kn)。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">另外，微博上的一位同学@曹鹏博士，给出了一个O(nlogn)的解法，也是非常巧妙的，具体是采用分治法：知道1-n最低bit有多少个为0，多少个为1。然后统计一下，给出的数最低bit有多少个为0，多少个为1；然后就知道从最低bit为0的那部分取走了k0个数，从最低bit为1那部分取走了k1个数。 其中，k0 + k1 = k。 然后把那些数按照最低bit为0，为1分开。问题变为两个子问题k0,k1，然后再考虑次低bit。很不错的解法。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：查询提示；及重排数组分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-24</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/156873/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">今日面试题：查询提示</h3> 
      <p>搜索引擎的查询提示(suggestion)是非常重要的一个功能。现在给定查询列表，以及每一个查询对应的频率。请设计一种查询提示的实现方案，要兼顾效果和速度。如果有其他更好的优化点，请给出详细说明。</p> 
      <p>==========================================</p> 
      <h3 style=" text-rendering: optimizelegibility; margin-top: 0px !important; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; ">重排数组分析</h3> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">有原数组S和目标数组T两个数组，它们分别是0-n-1 n个数字的某一种排列的结果。<br />请给出程序，完成从S到T的变换，注意：只允许使用一种操作：数组中的其他元素可以0交换。<br />例如：S={0,1,2}，T={0,2,1}。变换过程中，只允许1和2于0进行交换。<br />下面是一种可行方法：{0,1,2}=&gt;{2,1,0}=&gt;{2,0,1}=&gt;{0,2,1}<br /></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个题目还是比较有意思的：至于与0进行不断的交换，并且没有要求采用最少的变换。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">要变换到T数组，就要知道S数组中的值，再T数组中的位置。则有P数组，P[s]表示，T数组中值s的位置， 用p0表示0的位置。如，对于T={0,2,1}而言，P数组如下：</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">s</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">i</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">2</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">则对S数组进行扫描，找到第一个于T数组中相应数字不相等的数a，a不为0，</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">S</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
         <td style="padding: 6px 13px; ">2</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">T</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">则a=1，位置为index。查找P，a在T中的位置为2。如果要把a换到2的位置，则要先把2的位置中的元素换走，及首先swap(S[p0], S[P[a]])，然后swap(S[index], S[p0])。此时p0已经更新为S[P[a]]。两次交换，即找到a=1的最终位置。<br />得到如下的表格：</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">S</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">T</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">重复扫描S数组，找到第一个不相同的元素，a=2，位置为index，查找P[a]=0，则表明，直接swap(S[index],S[p0])即可。<br />最终得到:</p> 
      <table width="724" style="width: 464px; "> 
       <tbody> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(255, 255, 255); "> 
         <td style="padding: 6px 13px; ">S</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
        <tr style="border-top-width: 1px; border-top-style: solid; border-top-color: rgb(204, 204, 204); background-color: rgb(248, 248, 248); "> 
         <td style="padding: 6px 13px; ">T</td> 
         <td style="padding: 6px 13px; ">0</td> 
         <td style="padding: 6px 13px; ">2</td> 
         <td style="padding: 6px 13px; ">1</td> 
        </tr> 
       </tbody> 
      </table> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">上面的思路，是首先考虑在目标数组中的位置，那把原来数组中的这个位置的腾出来，即可。同样的，也可以反过来考虑，思路是相同的，大家可以自己画画表格。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">如果这个题目，进一步问，要使用最少的交换次数，该如何处理呢？按照如下方式构造图</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>数组中的n个元素的每一种排列方式，都是图中的一个节点</p></li> 
       <li><p>如果一个节点所代表的排列方式，通过题目中的一次变换，可以得到另一个节点，则两个节点之间，存在一条边</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">剩下就是求图中最短路径。具体过程，留给大家了。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">大家可以进一步思考，这个题目，还有优化空间么？还有更加巧妙的方法么？希望看到大家的分享。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：字母表；及查询提示分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-26</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/158224/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 1.5em; line-height: 1.7; ">今日面试题：字母表</span></p> 
      <p>每一种语言，都有自己的字母表，类似英文的a-z，但是顺序不相同。例如，有的语言可能是z是第一个之类的。现在给定这个语言的字典，请分析这个字典，得到这个语言的字母表的顺序。</p> 
      <p>例如：有如下的字母：</p> 
      <ol style="list-style-type: decimal;" class=" list-paddingleft-2"> 
       <li><p>C<br /></p></li> 
       <li><p>CAC</p></li> 
       <li><p>CB</p></li> 
       <li><p>BCC</p></li> 
       <li><p>BA</p></li> 
      </ol> 
      <p>经过分析，得到字母表为C-&gt;B-&gt;A。</p> 
      <p>===============================================</p> 
      <p><span style="font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 1.5em; line-height: 1.7; ">查询提示分析</span><br /></p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">搜索引擎的查询提示(suggestion)是非常重要的一个功能。现在给定查询列表，以及每一个查询对应的频率。请设计一种查询提示的实现方案，要兼顾效果和速度。如果有其他更好的优化点，请给出详细说明。</p> 
      <h4 style=" text-rendering: optimizelegibility; margin: 1em 0px 15px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.2em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; "><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这个功能，在搜索引擎里是非常常用的。用户在逐个输入每一个查询词的时候，给出查询的提示，用户可以选择，完成查询的输入。这个过程，查询的提示必须要快。要不然，用户都输入完了，还没有提示，体验太差。那这个问题要怎么做呢？</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">给定的查询日志是这样的：<br />query1 num1<br />query2 num2<br />query3 num3<br />…<br />queryn numn<br /></p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">具体的query可能是“薛蛮子”“郭敬明”等等。用户输入时，会有哪些状态呢？</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>薛</p></li> 
       <li><p>薛蛮</p></li> 
       <li><p>薛蛮子</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">当用户输入完“薛”的时候，就要提示以“薛”开头的哪些查询，而且是查询频率最高的10个，一般是10个。这里是考虑总的查询的频率最高的10个，在实际的过程中，可以考虑当前热门的查询，可能总的次数比较少，但是近几天用户差得非常多，这样的查询也一定要能够提示。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">形式与目的我们都清楚了。具体做法也是比较多的，最直接的，容易想到trie树，因为上面列出的几种状态，就是前缀。那一棵前缀树，显然是最合适的。我们在这里，就不详细说明trie的结构，只给出如何应用trie树。trie树的构建：</p> 
      <ul style="margin-top: 15px; margin-bottom: 15px; padding: 0px 0px 0px 30px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; " class=" list-paddingleft-2"> 
       <li><p>对于所有查询，构建trie树，并且，对于查询结束的节点，进行标记，保存查询的频率。</p></li> 
       <li><p>由叶子节点开始向上，比如，叶子节点A，父节点为B，B存储top10的查询，包括：所有叶子节点代表的查询，以及，如果B是查询结束节点，也包括B节点，按照频率排序的10个查询。依次向上处理，父节点的top10，是所有子节点的top10合并而成。</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">这样查询的时候，直接是对trie进行查询，到某一个节点，读取这个节点存储的top10查询即可，同时，这棵树，对于更新非常友好，可以新增频率，从叶子节点，回溯到根节点，即可。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">或者，采用trie树，不再节点存储top10查询，查询读取到可能类表之后再进行查询，这样会慢一些，但是内存开销稍微小一些。但，总的来说，trie树的内存开销是非常大的。那么，我们看下面的方法。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">一般，参与过搜索引擎的开发过程的，尤其是检索部分的同学，这个题目，第一个想法，可能不是trie树，而是倒排结构。总的来讲，应用倒排结构，有如下特点，也是和trie树进行对比：</p> 
      <ul style="list-style-type: disc;" class=" list-paddingleft-2"> 
       <li><p>查询快</p></li> 
       <li><p>方便压缩，节省内存</p></li> 
       <li><p>更新不方便，可以采用定期重建</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">具体倒排的做法：</p> 
      <ul style="list-style-type: disc;" class=" list-paddingleft-2"> 
       <li><p>对于每一个查询的所有前缀，做为倒排的索引项，创建倒排</p></li> 
       <li><p>每一个倒排，只存储top10频率的查询</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">除了上面介绍的之外，还需要考虑拼音等，思路大体相同。只不过更加需要注意内存的消耗。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal; ">【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：树的高度；及字母表分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-27</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/159124/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：树的高度</h3> 
      <p>有一个棵树，不一定是二叉树，有n个节点，编号为0到n-1。有一个数组A，数组的索引为0到n-1，数组的值A[i]表示节点i的父节点的id，根节点的父节点id为-1。给定数组A，求得树的高度。</p> 
      <p><br /></p> 
      <p>=====================================================<br /></p> 
      <h3>字母表分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>每一种语言，都有自己的字母表，类似英文的a-z，但是顺序不相同。例如，有的语言可能是z是第一个之类的。<br />现在给定这个语言的字典，请分析这个字典，得到这个语言的字母表的顺序。 例如：有如下的字母：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>C</p></li> 
       <li><p>CAC</p></li> 
       <li><p>CB</p></li> 
       <li><p>BCC</p></li> 
       <li><p>BA</p></li> 
      </ol> 
      <p>经过分析，得到字母表为C-&gt;A-&gt;B。</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>这个题目，在给出例子的时候，结果写作：C-&gt;B-&gt;A，这个是疏忽了，幸好很多同学都发现了，没有引起太多的舞蹈。<br />所以，在这里很感谢大家指出问题所在，并且，如果在分析中，大家有觉得不合适的地方，也请大家指出。稍后，会在待字闺中<br />或者微博中说明，真切的希望更多的同学受益。</p> 
      <p>这个题目其实是比较简单的一个题目。可能题目描述上，有点吓人，其实理解了之后，就会发现，还是蛮简单的。<br />这个题目的关键就在于：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>字典其实隐含了字母的顺序的</p></li> 
      </ul> 
      <p>这个是很自然的，如果没有想到这一点，这个题目任意解都可以的。而字典有序，是可以作为一个常识的。我们延续题目中的例子进行分析。<br /></p> 
      <p>首先，C一定是在B之前的，这个是由字典本身的属性决定的。那么剩下的如何考虑呢？比较完第一个字母不同的情况，则比较第一个字母相同的情况。<br />考虑C和CA，根据我们的经验，A一定是在C后面的，如果A在C的前面，则应该是CA，C的顺序。这样：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>根据C和CAC，我们得到C-&gt;A(表示C在A的前面，后面同理)</p></li> 
       <li><p>根据CAC和CB，我们得到A-&gt;B</p></li> 
       <li><p>根据CB和BCC，我们得到C-&gt;B</p></li> 
      </ul> 
      <p>综合，我们有C-&gt;A,A-&gt;B,C-&gt;B这三个关系，但是，还没有结束。根据这三组关系，如何得到CAB的关系呢？ 这三组关系，构成了一个有向无环图，很自然就想要要用拓扑排序得到CAB之间的整体排序。<br /></p> 
      <p>拓扑排序的算法，不在这里详述，总结一下这个题目的思路：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>构建有向无环图：按照字典中单词的顺序，每两个进行比较，找到第一对不相同的字母，确定他们的顺序</p></li> 
       <li><p>对有向无环图进行拓扑排序</p></li> 
      </ul> 
      <p>构建有向无环图的时间复杂度为O(N*M)，N是字典中单词数目，M是单词长度；有向图拓扑排序的时间复杂度是O(|V|+|E|)。</p> 
      <p>这个题目，并不是难题，解决的过程中，仅仅抓住字典的特点即可。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：数组统计；及树的高度分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-28</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/159924/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：数组统计</h3> 
      <p>给定数组A，大小为n，数组元素为1到n的数字，不过有的数字出现了多次，有的数字没有出现。请给出算法和程序，统计哪些数字没有出现，哪些数字出现了多少次。能够在O(n)的时间复杂度，O(1)的空间复杂度要求下完成么？</p> 
      <p><br /></p> 
      <p>================================================<br /></p> 
      <h3>树的高度分析<br /></h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>有一个棵树，不一定是二叉树，有n个节点，编号为0到n-1。有一个数组A，数组的索引为0到n-1，数组的值A[i]表示节点i的父节点的id，根节点的父节点id为-1。给定数组A，求得树的高度。</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>这个题目我们首先把数组写出来，然后进一步分析，就很明了了，如下例子：</p> 
      <table> 
       <tbody> 
        <tr> 
         <td>3</td> 
         <td>3</td> 
         <td>3</td> 
         <td>-1</td> 
         <td>2</td> 
        </tr> 
        <tr> 
         <td>0</td> 
         <td>1</td> 
         <td>2</td> 
         <td>3</td> 
         <td>4</td> 
        </tr> 
       </tbody> 
      </table> 
      <p>根据题意：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>节点0,1,2的父节点为3</p></li> 
       <li><p>节点3是根节点</p></li> 
       <li><p>节点4的父节点为2</p></li> 
      </ul> 
      <p>一个很直接的解法是，遍历数组A中的每一个元素，回溯到根节点，得到这个节点的高度。遍历完毕数组之后，取最大的，就是树的高度。上面的例子大概过程如下：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>0-&gt;3-&gt;-1，得到0到到根的高度为2，同理1-&gt;3-&gt;-1, 2-&gt;3-&gt;-1</p></li> 
       <li><p>3-&gt;-1，高度就是1</p></li> 
       <li><p>4-&gt;2-&gt;3-&gt;-1，得到高度3</p></li> 
      </ul> 
      <p>综上，最大的高度是3，则树的高度为3。这个方法的时间复杂度为O(n^2)，空间复杂度为O(1)。<br /></p> 
      <p>那么是否能够继续改进呢？通过上面的计算过程，我们可以发现，在计算4-&gt;2-&gt;3-&gt;-1的时候，显然2-&gt;3-&gt;-1已经计算过了，不需要再浪费时间重新计算一遍。示例代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/159924/1.jpg" onerror="" /></p> 
      <p>【分析完毕】<br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报该文章</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：灯；及数组统计分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-29</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/161241/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：灯</h3> 
      <p>有100盏灯，依次编号1-100，初始都是关着的。第1次遍历，打开全部的灯；第2次遍历，关掉第2盏、第4盏等被2整除的灯；第3次打开被3整除的灯；第i次，对被i整除的灯做如下操作</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>如果灯开着，就关掉</p></li> 
       <li><p>如果灯关着，就打开</p></li> 
      </ul> 
      <p>如此交替进行，知道100次遍历完毕，请问，还有多少盏灯亮着。</p> 
      <p><br /></p> 
      <p>=============================================<br /></p> 
      <h3>数组统计分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>给定数组A，大小为n，数组元素为1到n的数字，不过有的数字出现了多次，有的数字没有出现。请给出算法和程序，统计哪些数字没有出现，哪些数字出现了多少次。能够在O(n)的时间复杂度，O(1)的空间复杂度要求下完成么？</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>这个题目，是有一定技巧的。技巧是需要慢慢积累，待经验多了之后，可以灵感或者直觉，就产生了技巧。如果不知道技巧，那该怎么办呢？</p> 
      <p>在开始分析之前，说明两个问题：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>原数组是没有排序的。如果排序了，很简单的。</p></li> 
       <li><p>O(1)的空间含义，可以使用变量，但不能开辟数组或者map等来计数。</p></li> 
      </ul> 
      <p>这个题目，很直接的解法就是两层遍历，O(n^2)的复杂度，O(1)的空间。空间满足了，但是时间没有。</p> 
      <p>很多类似的题目，都会用XOR的方法，大家仔细想一下，这个题目，可以么？或者这个题目和可以用XOR的题目的差异在哪儿？最直接的就是，每一个数字的重复的次数是不同的。</p> 
      <p>还有就是以空间换时间的方法，例如用hash map或者数组来计数。时间满足了，但是空间没有满足。</p> 
      <p>那怎样才能有时间复杂度O(n)，空间复杂度O(1)的算法呢？不能开辟新的空间，那么只剩下，重复利用数组A。那么该如何利用数组A呢？</p> 
      <p><br /></p> 
      <p>首先，我们介绍一种三次遍历数组的方法,我们都考虑数组从0开始：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>第一次遍历：对于每一个A[i] = A[i] * n</p></li> 
       <li><p>第二次遍历：对于每一个i，A[A[i]/n]++</p></li> 
       <li><p>第三次遍历：对于每一个i，A[i] % n就是出现次数</p></li> 
      </ul> 
      <p>A[i]应该出现在A中的A[i]位置，乘以n、再除以n，很容易的来回变换；第二次遍历，对于A[i]本来所在的位置不断增1，但绝对不对超出n的，那每一个i出现的次数，就是A[i]对n取余。</p> 
      <p>还有一种两次遍历的方法，也是上面的思路：题目中数组是1到n，为了方便算法考虑，以及数组存储方便，我们考虑0-n-1，结果是相同的。 考虑A[i]，现在位置是i，如果采用A来计数，它的位置应该是A[i] % n，找到计数位置，该如何处理这个位置呢？加1么？显然不可以，这里有一个技巧，就是加n，有两个原因</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>加n可以保证A[i] % n是不变的</p></li> 
       <li><p>A数组，最后每一个元素表示为A[i] = x + k*n，其中x&lt;n，并且k就是我们要统计的频率。</p></li> 
      </ul> 
      <p>上面的思路，转换为代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/161241/1.jpg" onerror="" /></p> 
      <p>【分析完毕】<br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：此起彼伏；及灯分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-30</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/162183/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：此起彼伏</h3> 
      <p>有这样一个数组A，大小为n，相邻元素差的绝对值都是1.如：</p> 
      <p>A={4,5,6,5,6,7,8,9,10,9}。</p> 
      <p>现在，给定A和目标整数t，请找到t在A中的位置。除了依次遍历，还有更好的方法么？<br /></p> 
      <p>===================================================<br /></p> 
      <h3>灯分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>有100盏灯，依次编号1-100，初始都是关着的。第1次遍历，打开全部的灯；第2次遍历，关掉第2盏、第4盏等被2整除的灯；第3次打开被3整除的灯；第i次，对被i整除的灯做如下操作</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>如果灯开着，就关掉</p></li> 
       <li><p>如果灯关着，就打开</p></li> 
      </ul> 
      <p>如此交替进行，直到100次遍历完毕，请问，还有多少盏灯亮着。</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>这个题目比较好玩儿，路子走对了，很简单。想不对，方法就不是那么美。</p> 
      <p>例如，方向不对的话，就按照题目的意思，一遍又一遍的遍历，直到结束，时间复杂度是O(n^2)的。也能够解决问题，但是复杂了。</p> 
      <p>那么怎么办呢？上面的遍历的做法，是横向的思路，现在我们纵向思考。一盏灯，会在那几次被操作。例如编号为100的灯：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>第1次能够操作，打开</p></li> 
       <li><p>第2次能够操作，关闭</p></li> 
       <li><p>第4次能够操作，打开</p></li> 
       <li><p>第5次能够操作，关闭</p></li> 
       <li><p>第10次能够操作，打开</p></li> 
       <li><p>第20次能偶操作，关闭</p></li> 
       <li><p>第25次能够操作，打开</p></li> 
       <li><p>第50次能够操作，关闭</p></li> 
       <li><p>第100次能偶操作，打开</p></li> 
      </ul> 
      <p>最终编号为100的灯是打开的。再来看编号为70这盏灯：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>第1次能够操作，打开</p></li> 
       <li><p>第2次能够操作，关闭</p></li> 
       <li><p>第35次能够操作，打开</p></li> 
       <li><p>第70次能够操作，关闭</p></li> 
      </ul> 
      <p>最终编号为70的灯关闭着。</p> 
      <p>通过上面两个例子，我们会发现，1,2,4,5等都是能够整除100；1,2,35,70都能够整除70。 所以，编号为n的灯，有多少个因数，就有会被操作多少次。很显然，如果是偶数次，则灯一定是关着的。 那什么情况下，操作会是奇数次呢？一个数，每次分解，都是两个数相乘，只有当这两个数相同的时候，才会是偶数次。 所以，最终会亮着的灯，都能够开平方，得到一个正整数：1,4,9,16,25,36,49,64,81,100.</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：数组和；及此起彼伏分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-08-31</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/162804/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：数组和</h3> 
      <p>有数组A={5,3,8,9,16}，第一次遍历有：A = {3-5,8-3,9-8,16-9}={-2,5,1,7}，数组中元素和为-2+5+1+7=11；第二次遍历有：A = {5-(-2),1-5,7-1}={7，-4,6}，元素和为9.</p> 
      <p>给定数组A，求第n次遍历之后，数组中元素的和。</p> 
      <p>======================================================<br /></p> 
      <h3>此起彼伏分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>有这样一个数组A，大小为n，相邻元素差的绝对值都是1.如： A={4,5,6,5,6,7,8,9,10,9}。 现在，给定A和目标整数t，请找到t在A中的位置。除了依次遍历，还有更好的方法么？</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>最近有不少的同学反应题目比较简单，还有的同学反应题目有些难，还有的同学的反映很简单：“见过！”</p> 
      <p>在这里，需要做一下简单的说明：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>每天一个题目，确实很难考虑的面面俱到，又要考虑刚刚开始的同学，又要考虑已经比较厉害的同学。所以，只是简单和容易的每天交替着来。</p></li> 
       <li><p>到目前为止，基本都是找的各大公司的面试题，少有原创的面试题。所以，见多识广的同学，肯定是经常有见过的。不过，这个没有关系，温故知新，我相信重新思考，会给大家带来更多的进步。尤其是可以看到更多人的思路，这个带来的进步是巨大的。</p></li> 
       <li><p>我们也希望同学能够多贡献一些高质量的题目。<br /></p></li> 
       <li><p>不会出一些完全是ACM比赛的题目。还是要照顾大多数。</p></li> 
      </ul> 
      <p>所以，无论题目难易、新旧，只要思考，都会有新的提高。</p> 
      <p>现在我们来看看今天的题目，今天的题目，最直接的就是遍历，访问每一个元素，并且进行比较。这是任何一个、没有任何特点的数组，都可以采用的方法。也就是，相邻元素差的绝对值，我们没有使用。</p> 
      <p>那么如何来利用这个特点呢？看下面的数组：</p> 
      <table> 
       <tbody> 
        <tr> 
         <td>2</td> 
         <td>3</td> 
         <td>4</td> 
         <td>5</td> 
         <td>6</td> 
         <td>5</td> 
         <td>4</td> 
         <td>5</td> 
         <td>6</td> 
         <td>7</td> 
         <td>8</td> 
        </tr> 
       </tbody> 
      </table> 
      <p>如果，我们要找到t=8，则按照如下步骤进行，指针初始指向第一个元素</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>与第一个元素2比较，差值为6，指针指向第6元素，</p></li> 
       <li><p>当前元素为4，与8比较，差值为4，指针指向第10元素</p></li> 
       <li><p>当前位置为8，找到元素。</p></li> 
      </ul> 
      <p>为什么可以直接跳跃指到到第6，或者第10个元素呢？原因就是，相邻元素的差的绝对值都是1.这样，针对第一步来说，当前值2与t=8相 差6，如果t在数组中存在，则一定在2的后面第6个以后，而且，只有当2的后面，每一个都是+1的时候，才会在第6个位置找到t。其他的情况，一定都小于 t。</p> 
      <p>总结下算法过程：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>当前元素与t比较，差为0，则找到；</p></li> 
       <li><p>否则，得到差值为k，指针跳到当前元素后的第k个元素。</p></li> 
       <li><p>重复这两步，直到找到t或者t不在数组中。</p></li> 
      </ol> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：又见排序；及数组和分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-02</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/164379/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：又见排序</h3> 
      <p>给定大小为n的数组A，A中的元素有正有负。请给出方法，对其排序，保证：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>负数在前面，正数在后面</p></li> 
       <li><p>正数之间相对位置不变</p></li> 
       <li><p>负数之间相对位置不变</p></li> 
      </ol> 
      <p>能够做到时间复杂度为O(n)，空间复杂度为O(1)么？</p> 
      <p><br /></p> 
      <p>=======================================================<br /></p> 
      <h3>数组和分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>有数组A={5,3,8,9,16}，第一次遍历有：A = {3-5,8-3,9-8,16-9}={-2,5,1,7}，数组中元素和为-2+5+1+7=11；第二次遍历有：A = {5-(-2),1-5,7-1}={7，-4,6}，元素和为9.</p> 
      <p>给定数组A，求第n次遍历之后，数组中元素的和。</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>处理这样的题目，如果没有直接知道相关的原理，可以自己走一下一些具体的例子，这样就可以发现一些规律，根据这些规律，再去联想解决的完整方法。</p> 
      <p>经过观察，我们可以发现：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>对于第k次遍历而言，x_k_1、x_k_2、...、x_k_m，sum = x_k_m - x_k_1</p></li> 
      </ul> 
      <p>也就是说，第k次遍历结果的和，只与第一个和最后一个元素先关。下面，就来讨论，如何求得第一个和最后一个元素。</p> 
      <p>我们看题目中的例子，先考虑第一个元素的变化</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>第一次遍历 k = 1时：-2=3-5</p></li> 
       <li><p>第二次遍历 k = 2时：7=5-(-2)=(8-3)-(3-5)=8-2*3+5</p></li> 
       <li><p>第三次遍历 k = 3时：-11=-4-7=(1-5)-(5-(-2)) = ((9-8)-(8-3)) - ((8-3)-(3-5))=9-3*8+3*3-5</p></li> 
      </ul> 
      <p>分析到此，想必大家已经能够明白这其中的规律，其实就是杨辉三角，老外叫帕斯卡三角。最后一个节点是类似的。而且，真个方法的时间复杂度与遍历的次数n有关，与数组的大小无关。</p> 
      <p>【注】杨辉三角，在杨辉的《九章算术》中有记载，那时还叫贾宪三角，只不过后来杨辉的名字非常大，渐渐叫杨辉三角的越来越多。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：子序列；及又见排序分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-04</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/165929/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：子序列</h3> 
      <p>给定长度为n的整数数列：a0,a1,..,an-1，以及整数S。这个数列会有连续的子序列的整数总和大于S的，求这些数列中，最小的长度。</p> 
      <p><br /></p> 
      <p>============================================<br /></p> 
      <h3><span class="mini-icon mini-icon-link"></span>又见排序分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>给定大小为n的数组A，A中的元素有正有负。请给出方法，对其排序，保证：</p> 
      <ul class=" list-paddingleft-2"> 
       <li><p>负数在前面，正数在后面</p></li> 
       <li><p>正数之间相对位置不变</p></li> 
       <li><p>负数之间相对位置不变</p></li> 
      </ul> 
      <p>能够做到时间复杂度为O(n)，空间复杂度为O(1)么？</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>这类题目，还有其他的变形，比如，数组A有奇数和偶数，排序奇数在前偶数在后，并且奇数和偶数内部的相对顺序不能变。那么这类的题目，该如何解决呢？</p> 
      <p>首先，暴力法可行：从左到右扫描数组，遇到第一个负数，与其前面的每一个元素进行交换，直到第一个位置，这里并不能直接交换， 因为这样就改变了正数的相对位置了。后面的继续扫描，第二个负数，依次交换到第二个位置。依次类推。算法总的时间复杂度为O(n^2)。</p> 
      <p>上面这个方法，大多数同学，都可以给出。那么，是否有更快的方法呢？大家请看下面的方法：</p> 
      <ul class=" list-paddingleft-2"> 
       <li><p>统计负数的个数，设为M</p></li> 
       <li><p>找到索引k&gt;M的第一个负数</p></li> 
       <li><p>使用i和j两个索引，i从0开始，直到遇到第一个正数，j从k开始，直到遇到第一个负数。交换i，j位置上的数，然后符号取反</p></li> 
       <li><p>对于A[0,M]和A[M, n]分别执行上面三步</p></li> 
       <li><p>修正符号：前面的M个为负数，后面的为正数。</p></li> 
      </ul> 
      <p>下面举例来说明，对于数组{-1,1,3,-2,2}，根据描述，有M=2，k=3。i遇到第一个正数为A[1]=1，j遇到第一个负数为A[3]=-2。然后交换i和j位置上的值， 数组变为{-1, -2, 3, 1, 2}, &nbsp;然后改变符号，得到{-1,2,3,-1,2}。然后递归处理{-1,2},{3,-1,2}，最终得到{-1,2,1,-3,2}。进行最后一步，修正符号, 得到{-1,-2,1,3,2}。即为最终答案。这个方法是nlog(n)的，比上面的提高了一些。</p> 
      <p>但是上面的方法，仍旧不是O(n)的。那么O(n)的方法，是否存在呢？我们认为，接近O(n)的方法是有的。但是，方法过于复杂。这类问题，可以统称为 stable 0-1 sorting。还是蛮有意思的。大家感兴趣的话，可以参考下面的文章：</p> 
      <p>http://www.diku.dk/hjemmesider/ansatte/jyrki/Paper/KP92b.pdf</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：最长等差数列；及子序列分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-05</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/167736/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：最长等差数列<br /></h3> 
      <p>给定未排序的数组，请给出方法找到最长的等差数列。</p> 
      <p>===========================================================<br /></p> 
      <h3>子序列分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>给定长度为n的整数数列：a0,a1,..,an-1，以及整数S。这个数列会有连续的子序列的整数总和大于S的，求这些数列中，最小的长度。</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>如果只是像题目这样的描述，没有强调正数，可以采用O(n^2)的方法。但是，很多同学在讨论的时候，指出了如果是正数，解法将会有什么样的变化。这个很好。不考虑正负的O(n^2)的方法，这里不详细说了，我们来讨论，当数列中都是正数的情况。</p> 
      <p>介绍一个利用排序+二分的方法。对于子序列ai...at，子序列和s=ai+...+at=sum[t]-sum[i-1]。sum[t]表示数列a0...at的和。那么，数组sum天然就是递增的，可以进行二分查找。 那么如何进行二分查找呢？对于数组sum，遍历找到第一个k，sum[k]&gt;S，二分查找k前面的某一个j，j是sum[k]-sum[j]&gt;S里最大的一个，则k-j是最小的。依次遍历完数组。 可以得到最小的长度，整体的时间复杂度O(nlogn)，空间复杂度为O(n)。</p> 
      <p>是否有更快的方法呢？从以上两个方法，我们可以有如下的观察：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>a0...at&gt;S，则a0...at+1无需再考虑</p></li> 
       <li><p>对于a0...at&gt;S，只需尝试a1...at是否&gt;S，如果大于S，则更新最短长度。</p></li> 
       <li><p>如果不大于S，大于S的只可能是a1...atat+1等。</p></li> 
      </ul> 
      <p>鉴于以上的观察，我们有如下的算法：设置索引i，j指向第一个整数：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>++j，直到sum[j]-sum[i]&gt;S，这里不需要额外保存sum，为了方便说明。记录子序列长度</p></li> 
       <li><p>++i，如果sum[j]-sum[i]&gt;S，更新最小子序列长度。直到sum[j]-sum[i]&lt;=S。</p></li> 
       <li><p>++j，直到sum[j]-sum[i]&gt;S。重复上面的两步，直到数组遍历完毕。</p></li> 
      </ol> 
      <p>整个算法的时间复杂度为O(n)。下面我们做一个示例数组为{5,1,3,5,10,7,4,9,2,8},S=10，i=j=0开始</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>当j=3时，和为14&gt;10,则更新最小长度为4</p></li> 
       <li><p>对i进行递增操作，和为9&lt;10，不满足条件。对j进行递增</p></li> 
       <li><p>当i=1，j=4时，和为19&gt;10,长度为4，不更新最小长度。递增i，直到i=3,此时和15&gt;10,更新最小长度为2,</p></li> 
       <li><p>依次类推</p></li> 
      </ol> 
      <p>最终得到最小长度为2.</p> 
      <p>【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">面试秘籍：怎么面试，怎么评分，怎么决定</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-06</span> <span class="activity-meta">匿名网友</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/167735/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3 style=" text-rendering: optimizelegibility; margin-right: 0px; margin-bottom: 15px; margin-left: 0px; padding: 0px; line-height: 1.7; cursor: text; font-size: 1.5em; font-family: Helvetica, arial, freesans, clean, sans-serif; white-space: normal; margin-top: 0px !important; ">面试秘籍：怎么面试，怎么评分，怎么决定</h3> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">本文作者参加了公司的interview workshop，讲怎么面试，怎么评分，怎么决定。主讲做过hiring committee，应该是比较资深的，供大家参考。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">打分系统，公司推荐用的标准：<br /></p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>1.0：不要hire，hire这个人我就辞职</p></li> 
       <li><p>2.0：可以hire，也可以不hire</p></li> 
       <li><p>3.0：建议hire</p></li> 
       <li><p>4.0：一定要这个人，他没来我就辞职</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">实际上，大家常用的标准是：<br /></p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>2.1：strongly no hire</p></li> 
       <li><p>2.7/2.8：border line case</p></li> 
       <li><p>3.0：hire him</p></li> 
       <li><p>3.4：strong hire</p></li> 
      </ul> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">如果你的平均能到2.7/2.8，差不多可以送hiring committee。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">onsite和offer的比例大致是5:1，比我想象的要高的多</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">网上经常有人抱怨：题目都做出来了，也是对的，还是被拒了。面试官写报告时，很看重的一点是速度。他们的理念是：聪明的人反应很快，有错不要紧，只要改的快。全对但是慢的人，没准是见过那道题的。一个人的思维是很难作假的。有同学说，速度就是训练出来的。恭喜你，能训练出来，说明你有足够的天分；并不是所有人都能训练出来。比如我，训练之后，也不能跟那些online coder比。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">面试官写上去的报告，也会被份等级。写得翔实，问题难的那种，很有助于申请。如果问题就是很空泛的讨论，哪怕得了很高的分，也不被看重。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">G家Internship经历是最重要的，可以override一切。onsite第二，电面不太重要。其余的东西可有可无，完全不起作用，最多能作为拒掉一个人的凭证。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">hiring committe四个人，录取需要四个人都同意，而不是majority。因为他们认为：A的人会招A的人，B的人会招C的人。保证质量，就需要把hiring bar设高，希望进来的都是A。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">最后的问题，主讲很直接：根本不希望听你问问题，最好没有问题直接走人：-）安排的时间一般是寒暄3~5分钟，warm up question；然后正式30~40分钟；最后留0~5分钟给你问。写进报告影响你分数的，都是正式问题。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">Expectation是解3~5个题，包括小题。你解的题越多，说明你思维快，越有利。卡在一个题上，就不要纠缠了，尽快move on。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">通常来说，面试者5分钟应该有思路，开始动笔写code；7分钟还在suck在那里，面试官应该帮他，启发无效move on到下一题。但是对于有些人来说，4分钟就把code都给你写完了，他们多半是玩儿online code competition的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">你不知道，不熟悉的topic，直接告诉对方，对方马上会换，一般不会跟你纠缠的。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">面试官的目的是发掘你的闪光点，而不是纠你的错。所以你有什么闪光的地方，都要尽量展示出来，不要一味在哪儿纠结有没有小bug。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">不要觉得前面错了影响心情，主讲就有几次，开头15分钟都是想把那人毙掉，结果后面峰回路转，发现对方特殊的长处，最后给了strong hire。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">不要试图去揣测面试官的评价。标准的官方回答是：your answer is reasonable。那个什么都不说明。因为最后决定权在hiring committee，他们不想误导candidate。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;">说到底，最重要的还是实力。把基础打好，思维磨快，比记住题解答案更有效。</p> 
      <p style="margin-top: 15px; margin-bottom: 15px; font-family: Helvetica, arial, freesans, clean, sans-serif; font-size: 15px; line-height: 25px; white-space: normal;"><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：找数字；及最长等差数列分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-07</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/167734/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：找数字</h3> 
      <p>数组A中，除了某一个数字x之外，其他数字都出现了三次，而x出现了一次。请给出最快的方法，找到x。</p> 
      <p>======================================================<br /></p> 
      <h3>最长等差数列分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>给定未排序的数组，请给出方法找到最长的等差数列。</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>题目描述比较简单，但是有一个问题我们需要首先搞清楚：等差数列中的数字，是否要和原始数组中的顺序一致。题目中，并没有说明，这个就需要大家在面试的过程中和面试官进行交流。我们在这里对两种情况都进行讨论</p> 
      <h5><span class="mini-icon mini-icon-link"></span>保证数字的顺序</h5> 
      <p>等差数列是要求相邻两个元素之间的差是相同的。那我们可以记录下来数组中任意两个数的差，并且记录下来。对于数组A，记录A[j]-A[i]，其中 i&lt;j。这里采用hashmap来记录，key就是A[j]-A[i]，value是所有差等于的A[j]-A[i]的(i,j)位置对。构造 hashmap的过程是O(n^2)的。然后，遍历hashmap的每一个value，对位置对按照起始位置进行排序，再进行一次遍历就可以得到最长的等 差数列。如下面的数组：{5,4,3,4,7,8}</p> 
      <p>构造hashmap如下：</p> 
      <ul class=" list-paddingleft-2"> 
       <li><p>-1=&gt;(0,1)(1,2)</p></li> 
       <li><p>1=&gt;(2,3)(4,5)</p></li> 
       <li><p>3=&gt;(3,4)</p></li> 
      </ul> 
      <p>上面已经排好序，对于第一个，找到等差数列0,1,2对应数字诶5,4,3.第二个，3和4位置没有连起来，不够成等差数列。方法平均时间复杂度为O(n^2),空间复杂度为O(n^2).</p> 
      <h5><span class="mini-icon mini-icon-link"></span>无需保证数字的顺序</h5> 
      <p>不需要保证数字的顺序与原来数组一致，如何找到最长的等差数列呢？原来的数组是无序的，我们先对数组进行排序，最终的一定是排序之后序列的子序列。然后，我们采用动态规划的方法解决这个问题。</p> 
      <p>我们假设dp[i][j]表示以A[i]A[j]开始的数列的长度，dp[i][j]如何表示呢？dp[i][j]=dp[j][k]+1，当 A[j]-A[i]=A[k]-A[j],及A[k]+A[i]=2*A[j]。根据dp[i][j]的定义，我们知道dp[x][n-1]=2，也就是 最后一列是2，数列只有A[x]和A[n-1]两个元素。首先，j从n-2，开始向前遍历，对于每一个，找到i和k，满足 A[k]+A[i]=2*A[j]，则有dp[i][j]=dp[j][k]+1，若没有，则dp[i][j]就为2.</p> 
      <p>这里找i和k，有一个小技巧，如下：初始i=j-1,k=j+1，然后分别向两边遍历，如果A[k]+A[i]2*A[j]则i--。大家还是参考代码吧：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/167734/1.jpg" onerror="" /></p> 
      <p><br /></p> 
      <p>【分析完毕】<br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：缺失的数字；及找数字分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-09</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/170885/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：缺失的数字<br /></h3> 
      <p>给定一个无序的整数数组，怎么找到第一个大于0，并且不在此数组的整数。比如[1,2,0] 返回 3, [3,4,-1,1] 返回 2。最好能O(1)空间和O(n)时间。 <br /></p> 
      <p>=========================================================<br /></p> 
      <h3>找数字分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>数组A中，除了某一个数字x之外，其他数字都出现了三次，而x出现了一次。请给出最快的方法，找到x。</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>乍一看这个题目，不少同学立马给出了答案：异或。但举个例子，就会发现，异或是行不通的，一般的方法是利用异或的的如下特性：</p> 
      <ul class=" list-paddingleft-2"> 
       <li><p>A xor A = 0</p></li> 
       <li><p>A xor 0 = A</p></li> 
      </ul> 
      <p>但是这个题目中，数字都是奇数个的，直接采用之前类似题目的异或方法，已经不合适了。</p> 
      <p>除此之外，我们还可能想到如下的方法：</p> 
      <ul class=" list-paddingleft-2"> 
       <li><p>采用hashmap，时间复杂度O(n)，空间复杂度O(n)</p></li> 
       <li><p>对数组A进行排序，然后在遍历一次，时间复杂度O(nlogn)，空间复杂度O(1)</p></li> 
      </ul> 
      <p>是否还有一些效果更好的方法呢？这一类的题目，即使简单的异或不能解决，也可以从二进制位、位操作方面去考虑，总之这样的大方向是不会错的。</p> 
      <p>题目中，如果数组中的元素都是三个三个出现的，那么从二进制表示的角度，每个位上的1加起来，应该可以整除3。如果有一个数x只出现一次，会是什么情况呢？</p> 
      <ul class=" list-paddingleft-2"> 
       <li><p>如果某个特定位上的1加起来，可以被3整除，说明对应x的那位是0，因为如果是1，不可能被3整除</p></li> 
       <li><p>如果某个特定位上的1加起来，不可以被3整除，说明对应x的那位是1</p></li> 
      </ul> 
      <p>根据上面的描述，我们可以开辟一个大小为32的数组，第0个元素表示，A中所有元素的二进制表示的最低位的和，依次类推。最后，再转换为十进制数即可。这里要说明的是，用一个大小为32的整数数组表示，同样空间是O(1)的。</p> 
      <p><br /></p> 
      <p>不过这里申请了一个数组的空间，如果这个是不被允许的呢？请大家开动脑筋，我们会在后续的文章中分享。</p> 
      <p><br /></p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：找数字续；及缺失的数字分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-11</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/171831/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：找数字续</h3> 
      <p>一个数组A，数字出现的情况，只有以下三种：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>一些数字只出现一次</p></li> 
       <li><p>一些数字出现两次</p></li> 
       <li><p>只有一个数字出现三次</p></li> 
      </ol> 
      <p>请给出方法，找到出现三次的数字h<br /></p> 
      <h3>缺失的数字分析</h3> 
      <h4><span class="mini-icon mini-icon-link"></span>原题</h4> 
      <p>给定一个无序的整数数组，怎么找到第一个大于0，并且不在此数组的整数。比如[1,2,0] 返回 3, [3,4,-1,1] 返回 2。最好能O(1)空间和O(n)时间。</p> 
      <h4><span class="mini-icon mini-icon-link"></span>分析</h4> 
      <p>首先数组是无序的，找到第一个大于0且不在数组中的元素，就是要找到大于0且不在数组中的最小的整数。要怎么处理呢？要找到最小的，不妨尝试从小到 大排序，然后从1开始，查找是否在数组中，可以利用二分查找。这样整体的时间复杂度是O(nlogn)，空间复杂度是O(1)。</p> 
      <p>离题目的要求，还差一些。如何改进呢？针对排序好的数组，我们做如下的观察：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>当缺失的数字为1的时候，A[0]&lt;=0, A[1] != 1</p></li> 
       <li><p>当缺失的数字为2的时候，A[0]&lt;=0, A[1] = 1, A[2] != 2</p></li> 
       <li><p>当缺失的数字为3的时候，A[0]&lt;=0, A[1] = 1, A[2] = 2, A[3] != 3</p></li> 
      </ul> 
      <p>通过上面的观察，可以发现，其实并不需要整个数组是有序的，只需要让数组中的0&lt;A[i]&lt;n的，能够还原到A[i]的位 置，就像缺失3的时候，使得A[1] = 1, A[2] = 2，而且，这两个一定是这样的。后面的序就无需理会了。能够做到，不排序，就实现位置的还原么？且看如下的算法：</p> 
      <p>由后到前扫描数组：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>如果A[i]=n，则continue；</p></li> 
       <li><p>如果A[i]=A[A[i]]，则continue；</p></li> 
       <li><p>如果0&lt;A[i]&lt;n，那么可以还原，则swap(A[i], A[A[i]]),然后跳转到步骤2</p></li> 
      </ol> 
      <p>然后，数组中如果存在0&lt;A[i]&lt;n的，已经保证A[i]=i了。此时：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>从1开始遍历，如果A[i]!=i，则i就是要找的数</p></li> 
       <li><p>如果遍历完，没有找到，则说明i从[1,n-1]，都有A[i]=i，那么这个时候就看A[0]，如果A[0]是n，则返回n+1，如果A[0]不是n，则返回n，即可。</p></li> 
      </ul> 
      <p>上面算法的时间复杂度是O(n)么？有的同学会想，在swap之后，仍然到第2步，可能还会出现交换，所以时间复杂度要高于O(n)。但实际上，swap之后，是会发生再次的交换，但我们可以保证，每一次交换，都会使得一个数字还原，即A[i]=i，再一次交换，会让一个新的数字还原。 假设数组中，可以还原的数字个数为k，则需要交换k次，k最多为n-1。这里要很小心，因为总的交换次数是k，并不是对于每一个元素，都会产生k次交换。 如果是后者，总的时间复杂度就是O(kn)了，但因为总的交换次数是k，所以总的时间复杂度是O(n+k)，就是O(n)。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">Google前工程经理王忻：如何准备软件工程师的面试</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-13</span> <span class="activity-meta">王忻</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/174853/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>作者：王忻</p> 
      <p><br /></p> 
      <p>我在 Google（以前是微软）工作期间面试了不下 300人，其中某些应聘者确实表现非凡，但有些却显得准备不足。当然许多面试准备不足的人最后依然获得了录用通知，因为他们本身确实才华出众。但如果应聘 者能提前准备妥当，那么面试过程将更为保险和轻松。以下所列出的就是我根据多年经验总结得出的建议：</p> 
      <p><strong>1．使用相同的工具（如铅笔和纸张）和时间限制（例如半个小时）模拟面试训练</strong></p> 
      <p>Google 和微软都会让应聘者在白板上手工解答编程问题，但通常大部分的应聘者都是习惯于在电脑上利用编程工具系统编写程序。因此面试的时候，某些应聘者离开了熟悉 的电脑光标，站在白板前感觉手足无措不知该如何起行。又或者他们不习惯在编程之时旁边有人观看，这会让他们感到紧张而无法正常思考。</p> 
      <p>在现实生活中，如果你想要横渡英吉利海峡，自然不能总是在室内游泳池练习。你必须投身大海在波涛之中训练，在准备面试的时候也是如此。</p> 
      <p>在面试开始之前你最好向招聘单位询问面试形式和面试问题。如果招聘单位让你在某个房间考试且仅提供没有汇编程序的编辑器，那么就应该在家中按照这种 情景进行练习。如果招聘公司单位让你在白板上回答问题并会安排考官在旁监督，那么你就要找一位软件工程师来扮演考官配合你练习。即使找来的考官经验不如你 也没有关系，他们依然能帮助你消除在他人面前出错所带来的紧张感，这样可以让你适应有人在旁边盯着看的面试氛围。</p> 
      <p>如果你恰巧认识我并希望由我来帮你联系，那我的条件就是必须请我吃饭：如果你已经工作了就吃日本寿司大餐；如果你还是学生，那么吃比萨饼也可以。</p> 
      <p><strong>2．在面试过程中不要对细小错误耿耿于怀</strong></p> 
      <p>我曾不止一次的在面试过程中碰到这种情况：当应聘者知道编程问题后，他马上就想到了最佳的方案、确定了边界条件，然后开始编写程序。但在编写过程 中，应聘者犯了诸如首先检查是不是操作顺序错误或忘记设定某变量等无关大局的小错误，当我指出其错误之后，应聘者立刻变得十分紧张，这种焦虑情绪影响了他 在后面环节的正常发挥。</p> 
      <p>其实这种恐惧心理完全不必要。一名优秀的程序员在编程过程中出现错误也是很正常的，就像是小提琴手在演奏高难度的巴赫交响乐时也会偶尔失误。音乐会的听众可能会觉察到这些错误，但是听众绝对不会因为这种细小失误就把出色的小提琴手看作是门外汉。</p> 
      <p>即便应聘者彻底搞砸了某个编程问题，面试考官也可能会提出不同的问题并会容忍应聘者在某个问题上的失误。再退一步说，就算某次面试彻底失败，你也有机会在其它面试上补救。</p> 
      <p>我的一位同事（一个项目的技术负责人）最近面试了一个人，在开始面试时他觉得面试者的交流方式存在问题，因此开始表现的相当不友好。但经过了整个面 试过程后，面试者证明了自身的能力，而我的那位同事也成了那位面试者最坚定的支持者。在过去的一年中，我从未见过这位同事如此强烈的支持哪位面试者。</p> 
      <p>所以，因此就算面试进展不顺，也务必坚持到底不要放弃。</p> 
      <p><strong>3．在面试过程中不要失礼</strong></p> 
      <p>这似乎是不用说的问题，但在面试过程中我确实碰到过影响很不好的失礼行为。曾有一位前来应聘软件工程师的人看到我就说：“哇，我真不敢相信你这么年 轻！你看上去好小！！我觉得你才 18岁！”我看了他的简历才搞清楚原来是来应聘的，在开始的时候我却忍不住想：“这个人是来面试我的吧？！？！”</p> 
      <p>面试者的这种言行实在要不得。</p> 
      <p>面试者也要注意不要说出诸如此类的话：“哇，你真的就是考官吗？你看上去好老！”“哇，你真的是来面试我的，你看上去好胖！”（相信应该不会有人说这样的话）。</p> 
      <p>在我的另外一次面试中，应聘者的手机在面试开始 15 分钟之后就响了，她没有理会，手机连续响了20秒，这样不免会对面试造成影响。5分钟之后，她的手机又响了，她依然没有理会；5分钟之后，手机第三次响 起。最后她终于抓过手提包在里面翻出了手机。我想：“是时候关掉手机了，她在进来之前就应该把手机关掉。”但是她在手提包中拿出手机之后却旁若无人的打起 电话来，而且就在面试过程中间！</p> 
      <p>这种情况唯一可接受的理由就是他有什么非常紧急的事，但是即便情况如此，那么他也应该在面试开始之时就讲清楚，让面试官有所准备。</p> 
      <p><strong>4．不要在面试中喧宾夺主</strong></p> 
      <p>我曾经面试过几个应聘者，他们好像铁了心肠一定要告诉我他们最近的“超级项目”。当我开始发话他们就立刻打断：“我想让你了解我们近期处理的超级项目，10年之前当这个项目开始之时还默默无闻……”，然后接下来的5分钟时间都在那里滔滔不绝唾沫横飞。</p> 
      <p>有时应聘者好像打定主意要给每个考官详细描述其引以为豪的项目，然后一整天都在那里翻来覆去的说这个项目。</p> 
      <p>记住：面试官在面试过程中有具体的问题需要询问。但是如果应聘者喧宾夺主，那么考官就可能无法获得充分的信息来做出判断，同时这种行为也会让考官觉得应聘者很难共事。</p> 
      <p>如果你确实想谈论自己的项目，那么就应询问面试官：“我觉得最近的某某项目能充分体现我的能力，我能不能用 10分钟的时间来描述一下具体情况？”这样就会给面试官空间来调整面试过程，由此也避免毫无征兆就让面试离题万里。</p> 
      <p><strong>5．在回答需要具体答案的问题之时，记得首先要有总括性的发言</strong></p> 
      <p>有时我会问一个答案可以很简练的问题，例如：“在你的那个成功项目中总共有多少人参与？”但应聘者往往会就此打开话匣：“恩，张三参与了这个项目， 他负责 UI部分，当然我也会给他一些指导。李四也在项目中，她在宾州远程工作，负责后端服务器。两年之后我们又有新人王五加入……”</p> 
      <p>在应聘者滔滔不绝的讲了三分钟之后，我还是不知道这个项目到底有多少人参与。</p> 
      <p>因此首先要简练的回答问题，然后再展开描述：“在我接手项目时有三个人，但当我离开项目时人数已经增加到12人。”</p> 
      <p>当然如果能简练的回答问题，然后征询意见之后再展开论述那就更好了：“在我接手项目时有三个人，但当我离开项目时人数已经增加到 12 人。我可以讲一下各人在项目中的具体分工吗？”</p> 
      <p><strong>6．（不是特别重要）在面试中要衣着得体，舒适的商务便装是最佳的选择</strong></p> 
      <p>人们有时候会为衣着犯愁。但是最重要的是要让自己感觉舒适。如果需要具体的建议，那么我建议穿衬衫甚至T恤衫。对于某些公司（例如 Google），西装革履显然是太隆重了。</p> 
      <p>这条建议不必太看中，因为面试官不会管应聘者穿什么。最好应该询问人事招聘部门穿什么合适，因为不同国家有不同习俗，就算美国东海岸和西海岸的公司 着装文化也会有差别。像 Google 这样的公司在着装方面更加随意，因此如果你穿着“三件套”的经典西服去 Google 面试，考官可能会有异样的感觉。因此如果你真的具备软件工程的本领，穿什么其实并不重要。某个应聘者曾经穿着皱巴巴脏兮兮的T恤就跑来面试，他的T恤衫上 还有着许多破洞。但最后他还是拿到了录取通知（当然我绝不建议如此穿着）。</p> 
      <p><strong>最后的一个小故事</strong></p> 
      <p>最后我想讲一场极为尴尬的面试。在看完之后，我希望你能这样想：无论你的面试如何糟糕，你至少要比这位应聘者幸运。</p> 
      <p>以前我还在微软的时候，我们通常会为应聘者准备一些饮料，某位暂称其为 Jeff 的应聘者要了一听百事可乐。我们走进面试房间后，他就在桌前坐下了。接下来我们简要的谈了谈他的工作经历，然后他开始在白板上解答编程问题，此时他还没有打开他的可乐。</p> 
      <p>我们俩站在白板前，然后杰夫开始在上面写程序。在写程序之时他沉浸在对整体构架的思考中，下意识的退了一步来查看整个白板。在后退时他不小心碰到了桌子，放在桌上的百事可乐掉到了地上。</p> 
      <p>因为可乐还没有打开，因此当可乐罐落地的时候，可乐罐炸开了。</p> 
      <p>可乐罐在地上打转，泡沫喷的到处都是。你可以想象当时的场景，可乐喷到了墙上、书架还有我电脑的键盘上。我俩楞在那里，手都半伸着（根本来不及抓到可乐罐），眼睁睁的看着可乐弄得到处都是。</p> 
      <p>我们花了 5 分钟的时间用纸巾来清理现场（虽然我的书本自那天之后都粘页了，而墙壁也不再是干净的了）。</p> 
      <p>随后我们重新开始白板测试。杰夫此时已非常紧张（换了谁都会紧张吧？）。他写了几行程序，然后擦掉，然后再写。他是用自己的手擦拭白板而不是用板刷。他急得额头冒汗，然后他又用刚刚擦过白板的手擦汗。在面试过程结束之时，他的脸上布满了红色、绿色和蓝色的颜料。</p> 
      <p>我说：“你的手上粘了很多颜料，我带你去卫生间洗洗吧，”然后我把他领到洗手间让他从镜中看到了自己的尊容。</p> 
      <p><strong>原作者简介：</strong></p> 
      <p>王忻，出生于北京，五岁时跟随父母移居美国。中学期间跳了三级，十五岁进入了加州理工大学，加入 Google前曾在微软等公司工作。</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：括号匹配；及找数字续分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-14</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/175719/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：括号匹配</strong></h3> 
      <p>给定字符串，输出括号是否匹配，例如，</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>&quot;()&quot; yes；</p></li> 
       <li><p>&quot;)(&quot; no；</p></li> 
       <li><p>&quot;(abcd(e)&quot; no；</p></li> 
       <li><p>&quot;(a)(b)&quot; yes。</p></li> 
      </ol> 
      <p><br /></p> 
      <p>要求必须用递归写，整个实现不可以出现一个循环语句。</p> 
      <p>===========================================================<br /></p> 
      <h3><strong>找数字续分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>一个数组A，数字出现的情况，只有以下三种：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>一些数字只出现一次</p></li> 
       <li><p>一些数字出现两次</p></li> 
       <li><p>只有一个数字出现三次</p></li> 
      </ol> 
      <p>请给出方法，找到出现三次的数字。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目和“找数字”的题目比较相似，但是解法上类似么？之前的解法是检查某一位上的1的和，是否能够被3整除，因为整数是32位的，可以开辟一个 32位大小的数组，这也是常数空间的。那么这个题目可以用这个方法来解决么？因为有不确定个数的数字出现了一次，这样可以产生的余数的种类也就比较多了。 那该怎么处理呢？</p> 
      <p>hashmap的方法被称为万金油，在牺牲了空间的条件下，很好的达到了O(n)的时间复杂度。</p> 
      <p>如果要求常数空间的解法呢？之前的文章也有讨论，快排的时间复杂度是O(nlogn)，然后遍历一遍，找到连续三个相同的数字。后面这一遍遍历，可以省去，因为出现三次的数字只有一个。但总的时间复杂度仍是O(nlogn)。</p> 
      <p>是否还有其他的方法呢？有的同学给出了如下的方法：可以取得A中所有数字的乘积p，我们假设p没有溢出。这是遍历数组中的每一个元素A[i]，查看 是否p % (A[i] * A[i] * A[i]) == 0，但此时，A[i]并不是最终要找到的数字，还需要遍历数组A，查看A[i]是否出现了三次。但这个方法整体的时间复杂度为O(n^2)。</p> 
      <p>上面分析了几个思路，希望能够帮助大家开拓思路，这里留给大家一个思考题目：上面这个题目，能够在时间复杂度O(n)，空间复杂度O(1)的条件下完成么？如果不能怎么说明？</p> 
      <p>之前的“找数字”的题目，除了我们介绍的解法，尚有比较犀利，充满技巧的解法。那么这个题目呢？希望大家热烈的讨论，可以在微博上和我们互动。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：interleave字符串；及括号匹配分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-16</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/176473/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：interleave字符串</h3> 
      <p>3个字符串a，b，c。判断c是否是a和b的interleave，也就是c中应该有a，b中所有字 符，并且c中字符顺序和a，b中一样。比如，a = &quot;ef&quot; b = &quot;gh&quot; c = &quot;egfh&quot; return true；a = &quot;ef&quot; b = &quot;gh&quot; c = &quot;ehgf&quot; return false。 <br /><br /></p> 
      <p>===========================================================<br /></p> 
      <h3><strong>括号匹配分析<br /></strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>给定字符串，输出括号是否匹配，例如，</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>&quot;()&quot; yes；</p></li> 
       <li><p>&quot;)(&quot; no；</p></li> 
       <li><p>&quot;(abcd(e)&quot; no；</p></li> 
       <li><p>&quot;(a)(b)&quot; yes。</p></li> 
      </ol> 
      <p>要求必须用递归写，整个实现不可以出现一个循环语句。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目很多同学都见过了，如果没有后面的条件，会张口就说就来用栈来实现，时间复杂度O(n)，空间复杂度O(n)。这个是很好的一个解答，没有 问题的。但是我们在做面试题，准备面试的过程中，每一个题目都不应该仅仅局限于某一个方法。应该尝试更多的思路，尽管有些思路的时间、空间复杂度并不是很 好，但是可以带来变化，举一反三，这才是真正的收获。</p> 
      <p>这个题要求了，只目能使用递归并且不能出现循环语句。这个时候，我们应该如何处理呢？其实告诉了大家递归，就比较好想了：怎么定义好问题和子问题。</p> 
      <p>如果字符串中的括号是匹配的，则'('的数量和')'的数量是相等的，反之是不相等的。这样，在递归的过程中，可以保存一个变量，用来记录'('的 数量和')'的数量是否匹配。这样定义递归问题f(p,count)，表示当前字符p之前的字符串中'('的数量和')'的数量的匹配情况，p表示指向当 前字符的指针。初始的时候，f(p, 0)，递归的过程如下：</p> 
      <p><br /></p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>如果p为空，则考察count是否为0，如果为0，则匹配；如果不为0，则不匹配；</p></li> 
       <li><p>如果不为空，则考察当前字符p，如果p='('，则递归调用f(p++, count++);如果p=')'，则递归调用f(p++, count--)。如果p是其他的字符，并不是'('和')'，则递归调用f(p++, count)，count不变，继续考虑下一次字符。其中需要检查和保证count&gt;=0.</p><p><br /></p></li> 
      </ol> 
      <p>其实，递归的问题有的时候不是那么好像的，需要大家不断的练习。如果不采用count来记录括号匹配的情况，这个题目的递归也不好想。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：删除字符；及interleave字符串分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-17</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/177607/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：删除字符</h3> 
      <p>删除字符串中的“b”和“ac”，需要满足如下的条件：</p> 
      <p><br /></p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>字符串只能遍历一次</p></li> 
       <li><p>不能够实用额外的空间</p></li> 
      </ol> 
      <p>例如：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>acbac&nbsp;&nbsp; ==&gt;&nbsp; &quot;&quot;</p></li> 
       <li><p>aaac&nbsp;&nbsp;&nbsp; ==&gt;&nbsp; aa</p></li> 
       <li><p>ababac&nbsp; ==&gt;&nbsp;&nbsp; aa</p></li> 
       <li><p>bbbbd&nbsp;&nbsp; ==&gt;&nbsp;&nbsp; d</p></li> 
      </ol> 
      <p><br /></p> 
      <p>进一步思考：如何处理aaccac呢，需要做哪些改变呢？<br /></p> 
      <p>================================================= &nbsp; <br /></p> 
      <h3><strong>interleave字符串分析</strong></h3> 
      <h4><strong>原题</strong></h4> 
      <p>3个字符串a，b，c。判断c是否是a和b的interleave，也就是c中应该有a，b中所有字 符，并且c中字符顺序和a，b中一样。比如，</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>a = &quot;ef&quot; b = &quot;gh&quot; c = &quot;egfh&quot; return true；</p></li> 
       <li><p>a = &quot;ef&quot; b = &quot;gh&quot; c = &quot;ehgf&quot; return false。</p></li> 
      </ol> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目中，并没有说明a和b中是否有相同的字符，这个直接影响了最终的解法。所以，大家在面试的过程中，要和面试官进行交互，弄清楚之后再动手。我们这里对于是否有相同的字符都给予分析。希望对大家有所帮助。</p> 
      <h5><strong>a和b没有相同字符的情况</strong></h5> 
      <p>这个情况处理起来比较简单，逐个字符遍历c字符串，首先处理第一个字符，将其与a中的字符匹配，如果没有匹配，则与b中的字符逐个匹配，如果没有匹 配，则返回false；如果a中或者b中有一个字符和c的第一个字符匹配上了，则如上考虑第二个字符，与c的第一个字符匹配上的字符串，也考虑第二个字 符，依次类推。直到c遍历完，这时，如果a和b还有字符没有遍历，也返回false，都遍历完毕，返回true。代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/177607/1.jpg" onerror="" /></p> 
      <p>上面算法的时间复杂度是多少呢？我们只需要考虑a和b的遍历情况，要么a++，要么b++，所以算法的时间复杂度为O(m+n)，m和n分别为a和b的长度。a和b这两个字符串，各自遍历一遍即可。</p> 
      <h5><span class="mini-icon mini-icon-link"></span><strong>a和b有相同字符的情况</strong></h5> 
      <p>上面的算法，不能够处理a和b中有相同字符的情况，例如a=&quot;XXY&quot;，b=&quot;XXZ&quot;，c=&quot;XXZXXY&quot;。如果要处理，有相同字符的情况也是 比较直接的。有相同的出现，如果都匹配了c中的字符，则两种匹配分别都考虑，只要有一个返回true，整个算法就返回true。</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/177607/2.jpg" onerror="" /></p> 
      <p>注意后面是||，两种情况都要考虑的。</p> 
      <p>上面这个算法的时间复杂度，在最坏的情况下是指数级的。所以，下面介绍一个动态规划的解法。一个问题能够用动态规划来解的一个前提是：要有重复的子 问题。这样把子问题的解存储起来，后面重复利用才可以提高算法的效率。这个问题有子问题么？考虑一个极端的例 子:a=&quot;XXX&quot;，b=&quot;XXX&quot;，c=&quot;XXXXXX&quot;。子问题，显然存在。再不然，画出递归树，就很明了了。</p> 
      <p>我们采用二维表来存储子问题的结果，IL[i][j]如果为true，则表示c[0..i+j-1]是a[0..i-1]和b[0..j-1]的interleave字符串。算法实现的过程于上面的递归类似：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/177607/3.jpg" onerror="" /></p> 
      <p><br /></p> 
      <p>通过动态规划的方法改进，算法的时间复杂度O(mn),空间复杂度O(mn)。 <br /></p> 
      <p><br /></p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：回文分割；及删除字符分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-19</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/179722/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：回文分割</strong></h3> 
      <p>对一个字符串按照回文进行分割，例如aba|b|bbabb|a|b|aba就是字符串ababbbabbababa的一个回文分割，每一个字串都是一个回文。请找到可以分割的最少的字串数。例如：</p> 
      <p><br /></p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>ababbbabbababa最少4个字符串，分割三次：a|babbbab|b|ababa</p></li> 
       <li><p>如果字符串整体是回文，则需要0次分割，最少1个字符串</p></li> 
      </ol> 
      <p><br /></p> 
      <p>==========================================================<br /></p> 
      <h3><strong>删除字符分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>删除字符串中的“b”和“ac”，需要满足如下的条件：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>字符串只能遍历一次</p></li> 
       <li><p>不能够使用额外的空间</p></li> 
      </ol> 
      <p>例如：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>acbac &nbsp; ==&gt; &nbsp;&quot;&quot;</p></li> 
       <li><p>aaac &nbsp; &nbsp;==&gt; &nbsp;aa</p></li> 
       <li><p>ababac &nbsp;==&gt; &nbsp;aa</p></li> 
       <li><p>bbbbd &nbsp; ==&gt; &nbsp;d</p></li> 
      </ol> 
      <p>进一步思考：如何处理aaccac呢，需要做哪些改变呢？</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>首先要明白从字符串中删除某些字符该如何实现，显而易见我们可以把保留的字符拷贝新的字符串中来实现删除。但是题目要求不能使用额外的空间。那就是将要删除的字符全部交换到字符串的尾部，然后设置一个'\0'表示字符串的结尾。</p> 
      <p>其次，如果要删除的都是单个字符的字符串，就很直接：我们使用i和j两个变量遍历字符串，i表示不会删除的字符的位置，j从0开始，只要i所在位置 的字符不是要删除的字符，就str[j]=str[i]（str表示字符串），然后j++指向下一个位置。一次遍历即可，不需要额外申请空间，只需要两个 变量。</p> 
      <p>但是，现在删除的字符串中有多个字符的，如：“ac”。那要如何处理呢？这里介绍一个小技巧：状态机。这里，我们有两个状态：ONE和TWO。TWO表示，前一个字符时‘a’的状态，其他的都用ONE表示。还是采用前面所描述的遍历方法：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>如果当前状态为ONE，则拷贝：str[j]=str[i];但如果当前字符满足以下两种状态的任一个，则不进行拷贝：</p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p>当前字符是‘b’，因为我们要删除b</p></li> 
        <li><p>当前字符是‘a’，我们要考虑下一个字符是c</p></li> 
       </ol> 
       <li><p>如果当前状态为TWO：</p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p>当前字符不是‘c’，那么我们要先拷贝前一个字符‘a’</p></li> 
        <li><p>然后考虑当前字符，如果不是‘b’或者‘a’，则拷贝字符</p></li> 
       </ol> 
      </ol> 
      <p>状态转换非常简单，就是每次都检查，是前一个字符为‘a’。基本代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/179722/1.jpg" onerror="" /></p> 
      <p>下面进一步考虑: 根据上面的算法，我们考虑aaccac，最终得到ac。ac在题目中要求的也是要删除的。是否要删除这个ac，就需要和面试官进行交流了，无论如何，总是 要考虑这种情况。还是采用上面的算法，怎么解决删除之后还可以删除的情况？其实非常简单，只需要做很小的修改，我们在循环最后加上这个代码即可：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/179722/2.jpg" onerror="" /></p> 
      <p><br /></p> 
      <p>【分析完毕】<br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：最长回文子串；及回文分割分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-22</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/181884/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：</strong>最长回文子串</h3> 
      <p>给定字符串，找到它的最长回文子串，都有哪些思路呢？例如&quot;adaiziguizhongrenenrgnohziugiziadb&quot;,回文字串很多了，但最长的是&quot;daiziguizhongrenenrgnohziugiziad&quot;。</p> 
      <p>==========================================================<br /></p> 
      <h3><strong>回文分割分析</strong></h3> 
      <h4><strong>原题</strong></h4> 
      <p>对一个字符串按照回文进行分割，例如aba|b|bbabb|a|b|aba就是字符串ababbbabbababa的一个回文分割，每一个字串都是一个回文。请找到可以分割的最少的字串数。例如：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>ababbbabbababa最少4个字符串，分割三次：a|babbbab|b|ababa</p></li> 
       <li><p>如果字符串整体是回文，则需要0次分割，最少1个字符串</p></li> 
      </ol> 
      <h4><strong>分析</strong></h4> 
      <p>这个题目很多做过leetcode的同学都见过，所以很多同学直接回复了DP。不过还是建议大家动手写一写。熟能生巧的。那么该如何分析这个题目呢？</p> 
      <p>我们可以先不理会最少分割，从对字符串进行回文分割入手，对于回文字符串的判断是不可避免的。我们可以从字符串的第一个字符开始，找满足回文的字 串。假设str[0..k]是一个回文字串（包括0和k），问题可以分解为子问题了：假设count[i]表示从i开始、包括i的字符串的回文切割数（当 然是有很多可能的），如果str[0..k]是一个回文字符串，则count[i]=count[k+1] + 1。找到递归表达式，这里要注意，从0开始，可能会有多个回文子串，也正是因为如此，才有最少分割一说。</p> 
      <p>上面的算法中，每次要遍历一遍字符串，同时要判断子串是否是回文，这里显然是存在重复计算的。这给我们改进提供了可能。那么该如何更好的判断回文呢？我们设定P[i][j]：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>为true时，表示str[i..j]为回文</p></li> 
       <li><p>为false时，表示str[i..j]不是回文</p></li> 
      </ol> 
      <p>则，当：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>i==j时，P[i][j]=true</p></li> 
       <li><p>j==i+1时，P[i][j]=str[i]==str[i]</p></li> 
       <li><p>其他，P[i][j]=P[i+1][j-1]&amp;&amp;(str[i]==str[j])</p></li> 
      </ol> 
      <p>这个P该如何构建呢？根据其状态转移的方程，P[i][j]所代表的字符串，长度从1开始变化，逐渐到整个字符串，是这样的一个构建的过程，所以外层循环应该是所要判断的字串的长度。基本代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/181884/1.jpg" onerror="" /></p> 
      <p>回文字串判断完毕之后，改如何计算最少分割呢？我们可以根据P构建一棵树，然后宽度有限遍历，找到树的最小深度。上面判断回文的时间复杂度为 O(n^2)，构建树的时间复杂度为遍历一次P，时间复杂度也是O(n^2)，最后树的遍历，时间复杂度要小于O(n^2)，这样，整体的时间复杂度为 O(n^2)。</p> 
      <p>也可以不这样考虑，如同我们上面说的，我们用C[i]表示str[0..j]的最小分割数，然后变量k从1开始到n遍历，找到最少的分割。时间复杂度O(n^2)。</p> 
      <p>【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：翻译数字串；及最长回文子串分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-24</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/183586/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：翻译数字串</strong></h3> 
      <p>翻译数字串，类似于电话号码翻译：给一个数字串，比如12259，映射到字母数组，比如，1 -&gt; a， 2-&gt; b，... ， 12 -&gt; l ，... 26-&gt; z。那么，12259 -&gt; lyi 或 abbei 或 lbei 或 abyi。输入一个数字串，判断是否能转换成字符串，如果能，则打印所以有可能的转换成的字符串。动手写写吧。 <br />==========================================================<br /></p> 
      <h3><strong>最长回文子串分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>给定字符串，找到它的最长回文子串，都有哪些思路呢？例如&quot;adaiziguizhongrenenrgnohziugiziadb&quot;,回文字串很多了，但最长的是&quot;daiziguizhongrenenrgnohziugiziad&quot;。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这是一个十分经典的题目，方法也很多。下面我们在介绍的时候，不会每个方法都很详细的介绍，不过同学们在练习的时候需要每个方法都写一下，进而才能够举一反三。</p> 
      <p>第一个方法当然是暴力法，外面的两层循环找到所有子串，第三层循环判断子串是否是回文。方法的时间复杂度为O(n^3)，空间复杂度为O(1)。</p> 
      <p>第二个方法，大家是否记得上期的题目中，是如何判断子串是回文的么？采用的是动态规划的方法。开辟一个P[i][j]用来表示str[i..j]是否为回文，P[i][j]的状态转移方程如下：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>当i==j时，P[i][j]=true</p></li> 
       <li><p>当i+1==j时，P[i][j]=str[i]==str[j]</p></li> 
       <li><p>其他，P[i][j]=P[i+1][j-1]&amp;&amp;(str[i]==str[j])</p></li> 
      </ol> 
      <p>这样，这个方法的时间复杂度为O(n^2)，空间复杂度为O(n^2)。比暴力法有很大的改进。</p> 
      <p>第三个方法，可以从上面那个方法的状态转移方程获得启发，对于每一个回文子串可以先确定一个中心，然后向两边扩展，这样可以在时间复杂度O(n^2)，空间复杂度O(1)的情况下完成，需要注意的是，长度为奇数和偶数的中心的情况是不同的。示例代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/183586/1.jpg" onerror="" /></p> 
      <p>第四个方法采用后缀数组，将最长回文子串的问题转化为最长公共前缀的问题。具体的做法就是：将整个字符串翻转之后，拼接到原字符串后，注意用特殊字 符分开，这样问题就变成了新的字符串的某两个后缀的最长公共前缀的问题了。这个方法比较强大，很多字符串的问题都能够巧妙的解决。不过实现起来也相对比较 难，好的实现和差的实现时间复杂度相差很大。大家应该多多练习。</p> 
      <p>第五个方法叫做Manacher算法，是一种线性时间的方法，非常巧妙。首先，我们在上面的方法中个，都要考虑回文长度为奇数或者偶数的情况。这个 方法，引入一个技巧，使得奇数和偶数的情况统一处理了。具体做法如下：abba转换为#a#b#b#a#，也就是在每一个字符两边都加上一个特殊字符。</p> 
      <p>然后创建一个新的P[i]表示，以第i个字符为中心的回文字串的半径。例如上面的例子，对应的P如下,设S为原始字符串：</p> 
      <p><br /></p> 
      <table> 
       <tbody> 
        <tr> 
         <td><span style="background-color: rgb(216, 216, 216);">S</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">#</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">a</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">#</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">b</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">#</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">b</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">#</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">a</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">#</span></td> 
        </tr> 
        <tr> 
         <td><span style="background-color: rgb(216, 216, 216);">P</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">1</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">2</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">1</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">2</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">5</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">2</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">1</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">2</span></td> 
         <td><span style="background-color: rgb(216, 216, 216);">1</span></td> 
        </tr> 
       </tbody> 
      </table> 
      <p>通过观察上面的表，大家可以发现P[i]-1就是实际回文字串的长度。如果知道P，遍历一次就知道最长的回文子串。可以该如何计算P呢？这是这个算法最核心的部分。</p> 
      <p>下面的讨论基本转自博客：http://www.felix021.com/blog/read.php?2040 博客中对Manacher算法介绍得也非常好，向大家推荐。</p> 
      <p>算法引入两个变量id和mx，id表示最长回文子串的中心位置，mx表示最长回文字串的边界位置，即：mx=id+P[id]。</p> 
      <p>在这里有一个非常有用而且神奇的结论：如果mx &gt; i，那么P[i] &gt;= MIN(P[2 * id - i], mx - i) 分开理解就是：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>如果mx - i &gt; P[j], 则P[i]=P[j]</p></li> 
       <li><p>否则，P[i] &nbsp;= mx - i.</p></li> 
      </ol> 
      <p>这两个该如何理解呢？具体的解释请看下面的两个图。</p> 
      <p>当 mx - i &gt; P[j] 的时候，以S[j]为中心的回文子串包含在以S[id]为中心的回文子串中，由于 i 和 j 对称，以S[i]为中心的回文子串必然包含在以S[id]为中心的回文子串中，所以必有 P[i] = P[j]，见下图。</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/183586/2.jpg" onerror="" /></p> 
      <p>当 P[j] &gt;= mx - i 的时候，以S[j]为中心的回文子串不一定完全包含于以S[id]为中心的回文子串中，但是基于对称性可知，下图中两个绿框所包围的部分是相同的，也就是 说以S[i]为中心的回文子串，其向右至少会扩张到mx的位置，也就是说 P[i] &gt;= mx - i。至于mx之后的部分是否对称，就只能老老实实去匹配了。</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/183586/3.jpg" onerror="" /></p> 
      <p>对于 mx &lt;= i 的情况，无法对 P[i]做更多的假设，只能P[i] = 1，然后再去匹配了。</p> 
      <p>理解了上面的一点，就没有问题了。</p> 
      <p>【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：排列子串；及翻译字符串分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-29</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/187703/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：排列子串</strong></h3> 
      <p>给定两个字符串A和B，判断A中是否包含由B中字符重新排列成的新字符串。例如：A=abcdef, B=ba，结果应该返回true。因为ba的排列ab，是A的子串。</p> 
      <p>==========================================================<br /></p> 
      <h3><strong>翻译数字串分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>翻译数字串，类似于电话号码翻译：给一个数字串，比如12259，映射到字母数组，比如，1 -&gt; a， 2-&gt; b，... ， 12 -&gt; l ，... 26-&gt; z。那么，12259 -&gt; lyi 或 abbei 或 lbei 或 abyi。输入一个数字串，判断是否能转换成字符串，如果能，则打印所以有可能的转换成的字符串。动手写写吧。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>转自@lxhgww 的一条微博<em>“special thanks to @陈利人，找工作准备过程中，翻完你的3600多条微博，而且看完了所有的评论，收到了Microsoft和Google总部的offer，最终签约Google Mountain View”</em></p> 
      <p><br /></p> 
      <p>首先要恭喜这位同学，我们能够帮助到这位同学，是我们莫大的荣幸，也是对我们待字闺中的最大的鼓励。我们会再接再厉，和同学们分享更多的题目。也希望同学们能够积极的参与进来，踊跃的讨论，各种思路进行碰撞。我们相信，不仅仅会对找工作有很大的帮助，对日常的工作也会有很大的促进的。</p> 
      <p>再一次恭喜这位同学！</p> 
      <p><br /></p> 
      <p>开始今天的分析。这个题目是一个比较直接，比较简单的题目。面试官会出这样的题目，一般都是考察大家的coding的功力的。这个实话实说，真的没有捷径。就是多写、多练，也可以阅读优秀的代码，不断的体会思路。</p> 
      <p>我们这里来分析一下这个题目的分析思路。看完这个描述，我们应该注意到一下的细节：</p> 
      <ul class=" list-paddingleft-2" style="list-style-type: disc;"> 
       <li><p>映射是在[1,26]这个范围内数字</p></li> 
       <li><p>输入的字符串是否包括0或者负数？</p></li> 
      </ul> 
      <p>这些细节要注意，不明确的要咨询面试官，要不然，很容易让你的程序出现漏洞。面试官也比较在意这个交互的过程。</p> 
      <p>充分理解题目的含义、目的之后，很直接的就可以想到这个题目可以用递归解决。如原题中的例子：12259，它有两个递归的子问题，（1）2259和（12）259，前面的括号表示是否能够通过映射表翻译。同理每一个子问题，都会表示为这样的两个子问题。</p> 
      <p>接下来，我们考虑（1）2259的两个子问题：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>（12）259</p></li> 
       <li><p>（122）59</p></li> 
      </ol> 
      <p>大家有注意到，第一个和12259的一个子问题重复了。大家是否对这个似曾相识呢？当大家把递归过程的树形结构画出来，会发现更多的重复子问题，这就给了我们改进的空间，只需要取消这些重复计算就可以了。</p> 
      <p>第一个方法就是记忆法，将计算过的结果缓存起来，这样可以后续接着使用。但是更近一步，我们是可以采用动态规划的方法的。很多同学也都直接的想到了。</p> 
      <p>上面的过程，是为初学者指的路，希望能对大家有所帮助。但还有一个细节，大家要注意，这个题目不仅仅是判断是否可以，还需要打印出来所有的情况。这个细节要在编程的时候注意。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：子串查找；及排列子串分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-09-30</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/189341/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：子串查找</strong></h3> 
      <p>从一个长字符串中查找包含给定字符集合的最短子串。例如，长串为“aaaaaaaaaacbebbbbbdddddddcccccc”，字符集为{abcd}，那么最短子串是“acbebbbbbd”。如果将条件改为“包含且只包含给定字符集合”，你的算法和实现又将如何改动。 <br />========================================================<br /></p> 
      <h3><strong>排列</strong><strong>子串分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>给定两个字符串A和B，判断A中是否包含由B中字符重新排列成的新字符串。例如：A=abcdef, B=ba，结果应该返回true。因为ba的排列ab，是A的子串。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>我们假设A字符串的长度为m，B字符串的长度为n。首先，如果B的长度大于A了，则肯定返回的是false。所以，我们下面的讨论都是m&gt;=n的情况。</p> 
      <p>最直接的，我们可以计算出B的所有排列字符串，然后逐个去A中匹配。B的所有排列字符串有n!个，每一个匹配，复杂度较高。</p> 
      <p>那么如何改进呢？是否可以减少匹配的次数呢？我们首先对B进行排序，采用快排，时间复杂度O(nlogn)，得到D。然后在A中，从头开始，长度为 n的子串进C行排序，然后判断与C与D是否相同。在A中，一共有m-n+1个长度为n的子串，每一个子串进行排序，时间复杂度为O(nlogn)，总的时 间复杂度为O((m-n+1)nlogn),O(mnlogn)。但其实，在A中，只有第一个C的排序时O(nlogn)的，其他的都是去掉第一个字符， 然后插入下一个字符，排序时间复杂度为O(n)，这样整体的时间复杂度为O(mn)。下面举个例子：</p> 
      <p>设定A=fedcba, B=ab，则m=6，n=2</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>排序B，D=ab</p></li> 
       <li><p>在A中，第一个长度为2的子串C=fe，排序之后为ef，与D不匹配，则从C中删除第一个字符f，加入下一个字符c，此时C=ec。再重复排序的过程。直到A遍历完毕。</p></li> 
      </ol> 
      <p>明显第一个C需要快排，其他的只需要插入即可。</p> 
      <p>还有其他的方法，可以用hashmap存储B中的字符，和A中的每一个长度为n的字串进行判断是否匹配。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">让你的简历熠熠生辉的动词</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-01</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/189340/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p style="line-height: 1em;">1. Accelerated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp; </span>35. Empowered<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;69. Motivated</p> 
      <p style="">2. Accomplished<span class="Apple-tab-span" style="white-space: pre;">&nbsp;&nbsp; </span>36. Enabled<span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>70. Negotiated</p> 
      <p style="">3. Achieved<span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 37. Encouraged<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;71. Obtained</p> 
      <p style="">4. Acted<span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp;<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 38. Engineered<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;72. Operated</p> 
      <p style="">5. Adapted<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>39. Enhanced<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp; 73. Orchestrated</p> 
      <p style="">6. Administered<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp; </span>40. Enlisted<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 74. Organized</p> 
      <p style="">7. Allocated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 41. Established<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp; 75. Originated</p> 
      <p style="">8. Analyzed<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 42. Evaluated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>76. Overhauled</p> 
      <p style="">9. Approved<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 43. Examined<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;77. Oversaw</p> 
      <p style="">10. Assembled<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>44. Executed<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span>78. Performed</p> 
      <p style="">11. Attained<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45. Expedited<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;79. Pinpointed</p> 
      <p style="">12. Boosted<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>46. Focused<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 80. Planned</p> 
      <p style="">13. Budgeted<span class="Apple-tab-span" style="white-space: pre;"> </span><span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>47. Forecasted<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>81. Prepared</p> 
      <p style="">14. Built<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>48. Formulated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</span>82. Prioritized</p> 
      <p style="">15. Calculated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>49. Founded<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 83. Processed</p> 
      <p style="">16. Catalogued<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp; &nbsp; </span>50. Generated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;84. Produced</p> 
      <p style="">17. Chaired<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 51. Guided<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;85. Reconciled</p> 
      <p style="">18. Coached<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 52. Harnessed<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp; 86. Repaired <br /></p> 
      <p style="">19. Collaborated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp; </span>53. Identified<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 87. Researched</p> 
      <p style="">20. Communicated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;</span>54. Illustrated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 88. Revitalized</p> 
      <p style="">21. Compiled<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 55. Implemented<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;</span><span class="Apple-tab-span" style="white-space: pre;">&nbsp; </span>89. Selected</p> 
      <p style="">22. Consolidated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp; </span>56. Improved<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;90. Solved</p> 
      <p style="">23. Coordinated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>57. Increased<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;</span><span class="Apple-tab-span" style="white-space: pre;"> &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp; 91. Spearheaded</p> 
      <p style="">24. Created<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 58. Initiated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>92. Stimulated</p> 
      <p style="">25. Cultivated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>59. Instituted<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;93. Strengthened</p> 
      <p style="">26. Decreased<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>60. Integrated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp; 94. Succeeded</p> 
      <p style="">27. Demonstrated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;</span><span class="Apple-tab-span" style="white-space: pre;">&nbsp; </span>61. Introduced<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;95. Surpassed</p> 
      <p style="">28. Designed<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 62. Invented<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 96. Synergized</p> 
      <p style="">29. Developed<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>63. Launched<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp; 97. Troubleshot</p> 
      <p style="">30. Diagnosed<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>64. Led<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 98. Uncovered</p> 
      <p style="">31. Directed<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; 65. Maintained<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; </span>&nbsp;&nbsp;&nbsp;&nbsp;99. Upgraded</p> 
      <p style="">32. Documented<span class="Apple-tab-span" style="white-space: pre;"> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span>66. Managed<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;100. Utilized</p> 
      <p style="">33. Doubled<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;&nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 67. Mastered<span class="Apple-tab-span" style="white-space: pre;"> </span></p> 
      <p style="">34. Educated<span class="Apple-tab-span" style="white-space: pre;"> &nbsp; &nbsp;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 68. Mediated<span class="Apple-tab-span" style="white-space: pre;"> </span></p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">系统工程师面经</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-03</span> <span class="activity-meta">BBS未名空间站</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/190415/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>直接开始吧！<br /></p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">中国人:</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">我Resume上的Semaphore是如何实现的，写下来。<wbr />我写了一半，有一点忘记了</span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">问了spinlock使用的问题。</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">智力题：小明一家过河</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       </ol> 
       <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">Hiring manager白人：</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">一张七道题关于C语言的卷子！！！其它再无交流空间，给试卷做，<wbr />当时就闷了！</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">题目有：str[]和*str的区别；</span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">数组指针大小；</span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"><wbr />包含不同类型变量的struct大小；</span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">实现</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">一个程序能查看自身的内存占用情况；还有三题记不得了</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       </ol> 
       <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">阿三带吃饭：</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       <p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">问了我一些基本概念，学校学习情况。然后开始说：我们边吃边想，<wbr />思考。</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">一个程序题目吧。你别停啊，多吃。题目倒是不难，两个string表示的二进制，一</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">个是32位，一个8位。里面都是1和0。<wbr />问怎么判断B是A的substring？我答了两种：第一</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">种最简单的，从左往右历，O(m*n)。第二种: 我们用一个8位的mask把A罩起来，然后</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">和B做XOR，如果结果是0，那么就是substring，<wbr />如果不是，那么继续shift再找。这人</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">电话面试也问我substring，<wbr />不过当时是int找substring。。。<wbr />真是对substring情有独</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">钟。</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p> 
       <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">白人：</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">conceptual：<wbr />一个process通过CPU调用内存给I/O设备，结果I/<wbr />O收到的是junk，</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">请问有什么可能原因？我的答案：1。物理原因，内存坏区，<wbr />或者虚拟内存磁盘坏区。2</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"> I/O端和系统端的内存识别不对称（<wbr />他觉得这个问题不太可能发生）。3。虚拟内存在</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">做replacement algorithm时候正好把要发送的page给swap了，<wbr />导致I/O收到了不正确的</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">内存块。修改意见可以是改变algorithm 4。还有就是kernel可能已经控制了整块内存</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">，而不让process自行allocate内存。（<wbr />不知道对不对）</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">写个双向链表，要实现add, delete, seek.我只写到add结束，时间来不及了</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">。代码写的不好，没有check malloc伯克利男很伤心，然后add时候有一处忘了更新头</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">尾指针。</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       </ol> 
       <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">白人：</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">问问你用什么debugger啊？<wbr />kdb和gdb用起来感觉有什么不一样啊？还有别的</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">debugger吗？遇到kernel panic你会怎么办啊？kernel怎么debug啊？</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">写一个hexToInt()方法，把十六进制转化成十进制。</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       </ol> 
       <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">白人偏硬件：</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">你觉得你的研究生生活怎样？是你想学的东西吗？为什么改行？</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">代码题：一个int，我有个scanner每次找两个bit，<wbr />要求1打头就记录下来返回</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">这两个bits和位置到global variable。</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       </ol> 
       <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">像是墨西哥人又像印度人:</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">直入主题编程题。我是一个货运公司，我有1到n台卡车，<wbr />每台运费也是1到n。</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">我一旦有货就用最便宜的卡车运走。在未知时间内，卡车会回来。<wbr />写两个方法，一个发</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">车，一个回车，更新我的卡车列表。<wbr />不考虑synchronization</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">a是很简单就能实现，用一个index数组就行了。然后，<wbr />加难度，把卡车列表写</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">成二进制管理形式，你要更新单独的bit。<wbr />这就考到了00001000，怎么搞出单独1来。注</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">意：他要求最实际化，右移补零，左移情况未知！这就十分蛋疼了，<wbr />我只能右移，不能</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">左移。然后就考验你的bit manipulation的水平了。我提供的方法是+1法：00000111+1</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">=00001000。他说还有更多精彩方法请google。<wbr />对我表示不屑。。。</span></p></li> 
        <li><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">来了来了，synchronization！怎么处理？<wbr />哪里要处理？我的建议，spinlock</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">，mutex都行。他说，放哪里？<wbr />我放在了最后update卡车列表值时，他说不对，然后我</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">改错说放在while loop是不好的。这要非常消耗CPU。之后我发现在while loop之前有</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">一个传递变量，把他lock起来就行了。他表示满意。</span></p><p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"></span></p></li> 
       </ol> 
      </ol> 
      <p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">【全部完】</span></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：糖果；及子串查找分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-04</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/191407/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3>今日面试题：糖果</h3> 
      <p>N个孩子站成一排，每个人分给一个权重。按照如下的规则分配糖果：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>每个孩子至少有一个糖果</p></li> 
       <li><p>所分配权重较高的孩子，会比他的邻居获得更多的糖果</p></li> 
      </ol> 
      <p>问题是，最少需要多少个糖果？</p> 
      <p>==================================================<br /></p> 
      <h3><strong>子串查找分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>从一个长字符串中查找包含给定字符集合的最短子串。例如，长串为“aaaaaaaaaacbebbbbbdddddddcccccc”，字符集为 {abcd}，那么最短子串是“acbebbbbbd”。如果将条件改为“包含且只包含给定字符集合”，你的算法和实现又将如何改动。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>本期的题目与上期的题目颇类似。上期我们在分析完之后，提到还可以利用hashmap来实现。这样可以进一步的减小时间复杂度。具体的思路与上期的方法也类似，只是在判断是否出现的时候，不是采用排序的方法，而是hashmap的方法。具体方法如下：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>遍历一边字符集合，将集合中的字符都加到hashmap中</p></li> 
       <li><p>然后遍历长串，记录遍历开始pBegin和结束pEnd的位置，直到hashmap中的字符都出现过，则不断移动pBegin，查看是否能够满足 所有字符集和中的字符都出现了，如果出现：则不断更新最小长度；如果没有出现，则停止移动pBegin，开始移动pEnd。依次类推，像一个可以伸缩的窗 口在长串上遍历。</p></li> 
      </ol> 
      <p>示例代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/191407/1.jpg" onerror="" /></p> 
      <p>这个代码是《编程之美》中求解最短摘要的代码，其实本题，也是最短摘要的一个变化，字符集和就相当于查询了。</p> 
      <p>这里有一个小小的技巧，在移动pBegin的时候，怎么判断是否字符集合中的字符都出现了呢？可以采用给另外一个hashmap用来记录字符集中字 符出现的次数，当pBegin指向的字符，出现在hashmap中，则其对应出现次数减1，如果次数为0了，则要停止pBegin，开始移动pEnd。</p> 
      <p>这个方法的时间复杂度为O(2*n + m)，空间复杂度为O(n)。</p> 
      <p>【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">Google、Facebook、Rocket&nbsp;fuel面试经验总结</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-05</span> <span class="activity-meta">未名空间站</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/191822/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">找工作期间在本版潜水两个月，收益良多，<wbr />发一下最近面经和经验作为回馈。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">本人背景：美国不错学校电子PHD即将毕业，<wbr />专业是EDA做电路设计算法优化。因为EDA</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">已经是一个很稳定的工业，没什么太大的前景，<wbr />随想转到前沿的tech公司。本专业只投</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">了一家现在最大的公司，拿到offer。别的投了Google, Facebook, Rocket fuel, </span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">Twitter, Linkedin, Yahoo, Amazon, Box, Oracle. 除了box别的都找人refer了， 在</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">此感谢板上大哥们的热情帮忙. 除了GFR别的都没理我，可能背景差太大了。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">因为之前是学算法的，mit算法书以前就看过两遍，基础还可以，<wbr />前期8月份刷了遍</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">leetcode。然后9月初投出简历。两个星期刷Career cup 150， 最后面试期间一直查缺</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">补漏。到现在尘埃落定大概两个月。 最后GFR全挂，总结下惨痛经历：</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">1. Facebook电面</span></p> 
      <p><br /></p> 
      <p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">面试官做distributed cache infrastructure的，先问我最难的project，<wbr />没怎么好好</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">准备过behavior，胡乱说了一通。<wbr />但是因为做的是电路相关，非行内人士很难明白，讲</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">的也比较乱。最后估计起到了反效果。<wbr />感觉如果不是有特别好的经历和体会的话（特别</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">对于fresh在校内没什么好相关项目经历的）<wbr />这种最好长话短说想办法一笔带过，不然</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">可能起到反效果。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">浪费了大几分钟开始第一题，leetcode原题，Valid Panlindrome</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"> &quot;A man, a plan, a canal: Panama&quot; is a palindrome.</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">这题之前做过，也很简单，但当时太紧张出了一个很sb的bug，<wbr />还是在面试官提示下找</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">到的。15行的代码出bug实在是不能犯的错误。<wbr />另外在判断一个char是否letter的时候</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">没有另用函数把一堆&amp;&amp;写了两次，被批评不够简洁。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">第二题，将1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;6-&gt;7 变成 1-&gt;7-&gt;2-&gt;6-&gt;3-&gt;5-&gt;4，不能用额外空间</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">第一遍用了recursive很快解决，<wbr />被指出用了stack额外空间，开始改iterative，最后</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">因为第一题浪费时间手忙脚乱没改完。说了一下大概思路草草收场，<wbr />面完就知道不妙。</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">4天后被通知挂了。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">总结： facebook非常重视coding的clean和bugfr<wbr />ee。 这两题都没什么算法但是如果</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">coding不过硬第一遍很容易有bug，<wbr />我感觉从这点上来讲面试官出题水品很高，死的心</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">服口服。 另外他家感觉比较看背景，phd onsite会有jedi面试问项目经验什么的，专</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">业差太大估计要超级牛才容易过。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">2. Google电面</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">上来直接上题，题目有些绕。CSS里面表示颜色用</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">#abcdef (eg 0x1F2A3B) 这种形式， 每个字母代表四个bit (hex)，两个字母代表一种</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">原色</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">比如 ab = R, cd = G, ef = B</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">现在需要压缩空间改#abcdef 为 #xyz</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">实际上#xyz = #xxyyzz,所以减小一半，问怎么找到最好的压缩让</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">（ab-xx）^2 + (cd - yy)^2 + (ef - z)^2 最小</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">这题其实数学上很简单因为三个维度是分开的，其实就是找#<wbr />ab到#xx的压缩。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">我当时的面试官是个asian可能是韩国人或abc，<wbr />有点bitchy。我最开始说让我想一想，</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">才过了5秒钟他说不知道我在想什么让我在google doc上打，然后我就在上面打example</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">试图观察一下规律，他又阻止我说不用什么都打出来。<wbr />完了我说了我的观察： a的权重</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">更大， x应该很接近a， 实际上 x = a, a - 1 , or a + 1。 然后他不置可否。可能</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">我说的不是很清楚，他又开始和我纠结我的变量名用得不好。<wbr />因为他一直和我纠结这些</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">细节，我也没法安心思考，直接就开始写code，<wbr />又拿不准函数input和output应该用什</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">么样的type和形式。这就是这种模糊提很麻烦的一个地方。<wbr />面试官还是不给提示，我就</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">开始写但是code写的很乱。中途面试官没有任何提示。<wbr />完了我说想move on到下一题他</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">说没时间了要我找bug。整个code写的很糟，<wbr />因为没有分情况按 a &gt; b 时 x = a, a- 1</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">， a &lt; b时 x = a, a + 1这样来考虑所以变成了for loop非常乱。还剩5分钟时万念俱</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">灰面试官问我还可以怎么optimize已经没心思回答了跟他说<wbr />”如果你想让我检查代码我</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">就看吧“开始有点顶撞他的意思。<wbr />我电面这么多次第一次和面试官搞得这么僵心情非常</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">沮丧。最后草草收尾。3天后通知被挂。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">心得体会：google电面其实是很松的，很容易过。<wbr />电面没过打击很大，除了运气不好碰</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">到面试经验不丰富的面试官和模糊题外主要问题还在自己。<wbr />因为题目并不难，就算和面</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">试官不和拍也应该避免干扰仔细思考认真写代码。<wbr />特别是到后面十分钟我有点破罐子破</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">摔，这样给面试官映像肯定非常糟糕。<wbr />因为面试的一个目的就是考验你是rise against</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"> challenge还是crash under pressure。这点上我表现的非常失败。<wbr />因为google家比较</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">看中算法算是我的强项，所以没能去成onsite非常可惜。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">3. Rocket Fuel</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">网上交简历，当天收到hr回信，<wbr />过两天和hr电话chat半个小时，主要问问背景和看你是</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">不是serious applicant。完了发来online test 5hour。我做的auto racer。没有</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">follow他的hints选了最优算法但是由于编不出bala<wbr />nced avl tree有个test case没过</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">，还是个给了电面，面试官是三哥，电面是之前有人贴过的ad query题，给出了大家讨</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">论的最优答案，又拓展到分布式系统。<wbr />才说了半个小时面试官突然说时间到了问我有没</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">什么问题，我看他很急就说没问题就bye了。<wbr />本来以为肯定挂了因为预定要一个小时，</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">结果过了两天recruiter说feedback very positive让我去onsite有点莫名其妙。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">onsite中午和一个cmu毕业的topcoder 2000+的nb phd吃饭闲聊了一下，下午面了四个</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">人，三个三哥一个asian。两个big data infrastucture（最后端）的， 两个serving </span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">infrastrucre（中后端）的。<wbr />所有题目在之前rocket fuel的帖子里或者leetcode都能</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">找到，除了一道挺有意思的题</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">给定一个n*n的board里面是0或1.<wbr />算出里面独立0group的数量。比如</span></p> 
      <p><br /></p> 
      <p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">0 0 1 1 1</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">0 1 1 1 0</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">1 1 1 1 0</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">1 0 1 1 1</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">1 1 1 1 1</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">答案是3个group。我瞬间给出了一个BFS的O(n^2)<wbr />答案，被指出需要visited数组的额外</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">空间。然后给了一个逐行扫描的算法相当tricky，<wbr />我经过提示才想出来。面试完后第二</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">天被告知挂了。其实自我感觉还不错除了java multithreading答的不好。recruiter给</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">的反馈是总体还不错但有人指出我coding a bit messy。说另外还有一个不错的</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">candidate选了另外那个人，说我是pretty close。我自己猜测如果不是因为另外一个</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">人是三哥或美国人这种原因还是死在coding quality上，另外背景实在差的有点远。他</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">家要求最好一遍写出clean code。另外在onsite是建议code不要写太长，<wbr />如果要超过一</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">黑板最好把里面主要部件都先用函数代替写出主要流程向面试官说明<wbr />之后补充即可。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">心得： onsite时因为很多题都见过经常迅速讲一下思路就开始cod<wbr />ing，感觉交流不够</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">。面试的时候交流还是第一位的，<wbr />如果跑上来就写代码写的再好面试官对你印象也未必</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">好（可能还会觉得你是练过的），<wbr />因为他会把你当成未来的coworker所以交流的融洽是</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">很重要的。rf家的big data infrastructure全部是三哥，<wbr />我觉得这也是我挂的一个原</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">因，建议申请ai optimization那些核心组，那才是他们家的精髓所在。<wbr />rf没有之前提</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">的那些帖子那么乱但感觉还是不够正规，面试的时候不是很舒服，<wbr />连schedule都不给你</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">,说好的面试官经常换人。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">总体心得：coding不过硬会导致必然的失败。<wbr />我之前就是觉得自己算法底子不错忽视了</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">coding，其实本末倒置。工作中coding才是最重要的，<wbr />而且看了很多牛人的coding之后</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">才发现这个事情真的不是搬砖那么简单，<wbr />同一个内容的程序coding好不好能差很多（再</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">加上clear和readability的考虑）。<wbr />顶尖it公司要的不是average coder而是top coder</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">，<wbr />所以以前仗着算法不错就满足于average的coding水品<wbr />实在是很幼稚，以后一定会在</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">这方面加强锻炼。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">个人还有些算法和advanced data structure的重点觉得没有在leetcode里面很好体<wbr />现</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">的，总结如下:</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">1. 很多recursive容易的算法也要考虑iterative方<wbr />法。因为掌握iterative代表你对问</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">题结构理解上升了一个高度。e.g. reverse linked list， tree traversal</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">2. i) top k (kth) elements: heap O(n+klogn), quickselect O(n) average O(n^2)</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"> worst, median of medians O(n) worst. cons and pros.</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">Extension: what if all data can not fit into memory. heap size of k O(nlogk)</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif"> for single machine, many machines see 3.</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">ii) get median in data stream: max heap + min heap</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">3. kth element in many m machines: binary search, pick a pivot and see how </span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">many less and larger among all machines, then discard halves accordingly (</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">distributed quickselect)</span></p> 
      <p><br /></p> 
      <p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">if sorted in single machine: find smallest (k/m)th element among all&nbsp;</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">machines and discard the less partition.</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">4. stack support O(1) getMin</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">&nbsp;&nbsp; queue support O(1) getMin</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">e.g. k sliding window, most frequently clicked url in past 12 months.</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">5. reservoir sampling for infinite stream, generate random(1-7) with random(</span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">1-5), card shuffle, string permute in place</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">6. data structure with O(1) insert, delete, getRandom, get: hashmap + array</span></p> 
      <p><br /></p> 
      <p><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">LRU data structure: hashmap + doublelikedlist.</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">binary search tree with rank() (position of inserted or queried data)</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">(add treesize attribute for each node)</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">7. bit operation and bitset.</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">e.g. find missing number in large data, reverse binary number,&nbsp;</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">8. java multi-threading, blocking queue, nonblocking queue, H20, philosophy </span><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">dining, deadlock checking. 现在是个公司都问concurrency，一定要好好准备。</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">9. OOP: elevator design, parking lot design</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">distributed: large log file design, social network design, distributed cache</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">design ....</span><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><span style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif">本人已挂等待明年满血复活，祝各位job hunting顺利。</span></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：拷贝链表；及糖果分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-06</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/192355/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：拷贝链表</strong></h3> 
      <p>有一个链表，每一个节点除了next指针指向一下节点以外，又多出了一个指针random，指向链表中的任何一个节点，包括null。请给出方法完成链表的深拷贝。</p> 
      <p>===============================================<br /></p> 
      <h3><strong>糖果分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>N个孩子站成一排，每个人分给一个权重。按照如下的规则分配糖果：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>每个孩子至少有一个糖果</p></li> 
       <li><p>所分配权重较高的孩子，会比他的邻居获得更多的糖果</p></li> 
      </ol> 
      <p>问题是，最少需要多少个糖果？</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目是要求找到最少需要多少个糖果。最少的糖果是存在的，体现在哪里呢？权重较高的孩子，会比他的邻居们获得更多的糖果，那么多多少呢？可以是 1个，2个，或者更多个，但显然，当多一个的时候。总的糖果的数量是最少的，除此之外呢？当某一个孩子的邻居的权重都比他大，那他应该获得多少个糖果呢？ 只有一个——每个孩子至少要得到一个。</p> 
      <p>所以根据上面的分析，我们可以想办法找到权重数组A中的波谷（也就是权重小于邻居们的孩子），很显然这些孩子每人只可以分得一个糖果。我们开辟一个 新的数组B，表示每个孩子可以得到的最少的糖果数。扫描一遍A，得到所有的波谷的孩子，然后将对应的B的值设置为1.对于第一个和最后一个权重，只要 A[0]&lt;A[1]，以及A[n-1]&lt;A[n-2]，就认为A[0]和A[n-1]是波谷，这里假设数组A的元素个数为n。</p> 
      <p>然后该如何确定其他孩子的糖果数呢？我们看一个具体的例子，来更加形象的说明如何求得。如下表：</p> 
      <table> 
       <tbody> 
        <tr> 
         <td><span style="background-color: rgb(191, 191, 191);">A</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">1</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">2</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">3</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">4</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">2</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">6</span></td> 
        </tr> 
        <tr> 
         <td><span style="background-color: rgb(191, 191, 191);">B</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">1</span></td> 
         <td><br /></td> 
         <td><br /></td> 
         <td><br /></td> 
         <td><span style="background-color: rgb(191, 191, 191);">1</span></td> 
         <td><br /></td> 
        </tr> 
       </tbody> 
      </table> 
      <p>现在已经确定B中两个孩子的最少糖果数，然后：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>B[0]=1，那么B[1]=2,B[2]=3,B[3]=4，是一定的。原因是要满足题目中的第2个条件。</p></li> 
       <li><p>同理，B[5]=2。</p></li> 
       <li><p>上面的是按照数据的正向看的，如果逆向，则B[3]=2,因为B[4]=1。这时，出现了冲突，要满足最少的糖果数，似乎要取B[3]=2，但是不满足条件2.所以遇到这个情况，则选取较大的。得到表格如下：</p></li> 
      </ol> 
      <table> 
       <tbody> 
        <tr> 
         <td><span style="background-color: rgb(191, 191, 191);">A</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">1</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">2</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">3</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">4</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">2</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">6</span></td> 
        </tr> 
        <tr> 
         <td><span style="background-color: rgb(191, 191, 191);">B</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">1</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">2</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">3</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">4</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">1</span></td> 
         <td><span style="background-color: rgb(191, 191, 191);">2</span></td> 
        </tr> 
       </tbody> 
      </table> 
      <p>则最少糖果数为(1+2+3+4+1+2) = 13个。</p> 
      <p>总结算法步骤如下：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>找到数组的波谷，将波谷的孩子的糖果数设置为1.此步：时间复杂度O(n)，空间复杂度O(n)</p></li> 
       <li><p>从左到右遍历数组，从每一个1开始，其后的孩子的糖果比前一个孩子多1个，直到波峰。此步：时间复杂度O(n)</p></li> 
       <li><p>从右向左遍历数组，从每一个1开始，其后的孩子的糖果比前一个孩子多1个。波峰的孩子，与2步中的相比，取最大的糖果个数。</p></li> 
       <li><p>B数组每一个元素求和，即可得到最少需要的糖果数。</p></li> 
      </ol> 
      <p>整体算法的时间复杂度为O(n)，空间复杂度为O(n)。进一步优化，可以将找波谷的一次循环省略。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">Y!&nbsp;onsite新鲜面经</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-07</span> <span class="activity-meta">未名空间站</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/192930/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>没签NDA， 我就说说了。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />一共四轮。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />第一轮：&nbsp;<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />..behavior questions. Most difficult part in your project.<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />1. BFS.... 我先用了两个queue， 被要求改成一个， 再被要求在node的结构里加一个isMarked的property来做， 感觉有点无聊<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />2. String compression, 比如 ACCCDD 变成A3C2D<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />第二轮：<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />设计一个lexicon使得可以支持wild card。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />比如lexicon里面有单词“apple”， 那么query = &quot;apple&quot;, &quot;a?ple&quot; 或者 “a*”都返回true。 “apble”, &quot;a?ble&quot;, &quot;a*l&quot; 返回false。 其中 ‘？’表示任意字符出现一次； ‘*’表示任意字符出现0或多次<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />第三轮：<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />这轮是大佬architect来面的， 自然是system design。。。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />用户在每次完成一个task之后， 都会得到一个分数， 设计系统使得用户可以立刻知道他总分的排名， 并且可以选择在过去3天/7天/一个月的排名， 要求从security, scalability 等方面分析<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />第四轮：<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />用户在做某个task的时候会不断向server发出quest<wbr />， 这个quest包含了userid和taskid， 都是unit类型的。 设计实现可以得到daily active user 和 last 30 day active user的数量的方法。 设计要求兼顾速度和节省存储空间。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />最后讨论如果要把每天的信息serialize到一个local file， 应该怎么做才能节省空间。</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：加油站；及拷贝链表分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-08</span> <span class="activity-meta">待字闺中</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/192929/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：加油站</strong></h3> 
      <p>城市的环形路有n个加油站，第i个加油站的油量用gas[i]来表示，你有如下的一辆车：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>它的油缸是无限量的，初始是空的</p></li> 
       <li><p>它从第i个加油站到第i+1个加油站消耗油量为cost[i]</p></li> 
      </ol> 
      <p>现在你可以从任意加油站开始，路过加油站可以不断的加油，问是否能够走完环形路。如果可以返回开始加油站的编号，如果不可以返回-1。注意，解决方案保证是唯一的。</p> 
      <p>================================================<br /></p> 
      <h3><strong>拷贝链表分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>有一个链表，每一个节点除了next指针指向一下节点以外，又多出了一个指针random，指向链表中的任何一个节点，包括null。请给出方法完成链表的深拷贝。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个问题的关键就在于random指针如何完成拷贝，next指针一次遍历就完成了，random指针拷贝的关键在于，如何找到random指向的 节点对应的新的节点。一般来讲，大家会想到用map来保存旧的节点到新的节点的映射，这样得到的方法的时间复杂度为O(n)，空间复杂度为O(n)。下面 是一个可行的方法：oldlist为原始链表，copylist为新的链表，oldnode为oldlist中的节点，copynode为 copylist中的节点：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>根据oldlist，创建copylist，只拷贝next指针</p></li> 
       <li><p>保存oldnode到oldnode.next的映射</p></li> 
       <li><p>将oldlist中的oldnode的next指针指向copylist中对应的copynode</p></li> 
       <li><p>将copylist中的copynode的random指针指向oldlist中对应的oldnode</p></li> 
       <li><p>对于copylist中的每一个节点：copynode.random=copynode.random.random.next</p></li> 
       <li><p>根据第2步，建立的映射，恢复oldlist</p></li> 
      </ol> 
      <p>上面这个方法，需要额外的映射。下面介绍一个巧妙的方法，可以省去映射的部分</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>对oldlist中的节点，依次作如下的操作：对于第i个节点oldnode[i]，生成拷贝节点copynode[i]，并且插入在oldnode[i]和oldnode[i+1]之间，最后一个节点直接附加到oldlist后面即可。</p></li> 
       <li><p>处理每一个copynode的random拷贝，及对每一个copynode=oldnode.next, oldnode.next.random=oldnode.random.next 后面的next确保是copynode。</p></li> 
       <li><p>通过如下的操作，恢复oldlist，以及生成copylist 1) oldnode.next = oldnode.next.next 2) copynode.next = copynode.next.next 这里要注意，oldnode的最后一个节点，next是null</p></li> 
      </ol> 
      <p>注意题目中的random可能指向null，在上面第2步的时候处理一下就可以了。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">狗家面经</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-09</span> <span class="activity-meta">未名空间站</span>  <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/193741/0.jpg" onerror="" /> 
     </div> 
     <div class="text">
       还不知道结果，披个马甲攒人品吧 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /> 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />1. 二叉树的序列化和反序列化，节点的value是String类型 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />2. 找两个排好序的list的共同元素 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />&nbsp;&nbsp;&nbsp; 5 -&gt; 6 -&gt; 6 -&gt;8 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />&nbsp;&nbsp;&nbsp; 4 -&gt; 4-&gt; 6 -&gt; 6 -&gt; 8 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />答案是 6 -&gt;&nbsp; 6 -&gt; 8 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />两个list长度差不多是怎么做？ 长度相差非常大时如何做？ 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />3. 有一个字典因为某种原因每个字符都被替换成一个别的字符了（ 
      <wbr />但还是一一对应)，但是单词的顺序没有改变，比如 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />cat 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />coffee 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />common 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />变成了 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />dkc 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />dbhhzz 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />dbllbq 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />让找出的这个替换的规则（guaranteed to have a unique one) 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />4. 二叉树找中序后继 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />设计一个算法， 
      <wbr />在分布式系统中拷贝某一个节点上的某一个文件到其他所有的节点上 
      <wbr />，要考虑时间代价和fault tolerance 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />5. 给定两个list of integer，问是否他们是否互相是对方的一个从排列 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />follow up: 如果不停的有新的list of integer过来，问是否这一列数以前出现过。&nbsp; 
      <br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />怎么存储？怎么查询？复杂度？ 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：最新版本；及加油站分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-10</span> <span class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/195462/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：最新版本</strong></h3> 
      <p>给定软件的版本号的表示方式，以及一些版本号，请找出最新的版本。例如：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>1.2，2.2 最新的是2.2</p></li> 
       <li><p>3.1, 3.1.3 最新的是3.1.3</p></li> 
      </ol> 
      <p>上面的版本号，都是用字符串表示的。</p> 
      <p>=================================================<br /></p> 
      <h3><strong>加油站分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>城市的环形路有n个加油站，第i个加油站的油量用gas[i]来表示，你有如下的一辆车：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>它的油缸是无限量的，初始是空的</p></li> 
       <li><p>它从第i个加油站到第i+1个加油站消耗油量为cost[i]</p></li> 
      </ol> 
      <p>现在你可以从任意加油站开始，路过加油站可以不断的加油，问是否能够走完环形路。如果可以返回开始加油站的编号，如果不可以返回-1。注意，解决方案保证是唯一的。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目其实比较简单，只要充分的理解，我相信大家都能够解决的。你的这辆车的油缸是无限量的，所以每个加油站的油都可以加到车里，但是关键是你得 保证，你在第i站的时候，油缸中有的油量，可以支撑你到第i+1站，对于每一站都要如此，所以，并不是总的油量大于消耗量就可以了。要保证每一站都有足够 的油可以走到下一站，到每一站，你的车的油量都大于等于0就可以了。</p> 
      <p>经过上面的分析，很显然，暴力一点，我们每个站都试一下呗，然后找到每一站的油量都大于等于0的那个走法，返回开始的加油站；没有就返回-1。这个解法是O(n^2)的时间复杂度。</p> 
      <p>我们通过观察上面的暴力方法的步骤，可以发现有很大的改进空间。当我们从第0个加油站开始，判断是否可以走完，然后从第1个加油站开始，进行判断的 时候，其实中间的计算已经做过了。反过来，我们如果计算好了从第1个加油开始，到某一个站时，油量为tank，此时考虑从第0个开始时，到该加油站的油量 就是gas[i]-cost[i] + tank。这时隐约觉得，解决方案的时间复杂度可以是O(n)的时间复杂度。</p> 
      <p>事实上确实可以，具体的方法如下：tank表示当前车的油缸里的油量</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>从第0个站开始，tank += gas[0] - cost[0]，只要tank&gt;=0，我们就继续到下一个加油站</p></li> 
       <li><p>当不满足tank&gt;=0，顺着环路试验从前一个站开始，比如，n-1: tank += gas[n-1] - cost[n-1]，如果还小于0，继续试验再前一个。</p></li> 
       <li><p>直到满足 tank&gt;=0，再进行第1步，依次类推</p></li> 
       <li><p>当一前一后这两个相遇了，算法也就结束了，tank&gt;=0，就成功，返回相遇的位置；否则，失败，返回-1</p></li> 
      </ol> 
      <p>上面这个方法的时间复杂度是多少呢？O(n)的，很简单，我们作为一个整体来看，每一个节点都只走了一次。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">新鲜面经</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-11</span> <span class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/196930/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>周四面的，具体哪个公司就不说了，说是周一周二给结果，但愿好运了。<br /><br />分享一下面试题目，也refresh一下我的memory<br /><br /><br />1 给一堆整数，所有数都是偶数次，只有一个出现奇数次，如何求出这个数；<br /><br />给一堆整数，求出所有出现奇数次的整数；<br /><br />两个鸡蛋，100层楼，求出哪儿破，我说我听说过了，没有继续问了。<br /><br />然后又问了一个，给定两个date，如何判断差别是否less than one month；great than one month； exactly one month；<br /><br />都要写code，最后一个没有写完，不过对方说，不要紧，本来就是extra question，可能他想问我鸡蛋题，我说听说过了，他改问了这个。<br /><br />2 给一个tree，定义height是根节点到叶子节点的距离中最短的一个，如何求出这个距离； 后来又问了bfs和dfs的区别<br /><br />给一个array of int，要求实现power set，设计一个class，1）判断是否有下一个subset；2）如果又，给出下一个subset。不管你什么标准输出subset，要求不重复；<br /><br /></p> 
      <p>都要求写code</p> 
      <p><br /></p> 
      <p>如果project deadline 无法meet，你会如何做？</p> 
      <p><br />3 问了我是否工作过程中有主动要求改进什么？问我inheritance和composite有什么区别；设计一个网上会议室预约系统；设计一个路口的红绿灯系统；<br /><br />4 为什么要换工作，当前为什么不好，如果给你足够的条件，你愿意留么？ 给一个全是整数的文件，如何判断是否有重复，返回true和false；如果整个文件不能被load到memory，怎么办？我说通过hash，cut成很小的一份一份，他后来问这个一份一份可能有的很大，有的很小，怎么办？这个地方我不知道他要问的point在哪儿，大家指教一下。<br /><br />问我工作的project；又继续问，给一个系统，如何改进系统频繁访问数据库形成的瓶颈，我说cache和distributed，然后问我如何cache，如何distributed，这题大家也指教一下。</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：最大乘积；及最新版本分析</h1> 
      <p class="activity-info"> <span id="post-date" class="activity-meta no-extra">2013-10-12</span> <span class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a> </p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/197280/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：最大乘积</strong></h3> 
      <p>一根绳子，长度为n米。将其切成几段，每一段的长度都是整数。请给出一种切法，使得切成的各段绳子之间的乘积是最大的。注意，最少要切一下的。</p> 
      <p>==========================================================<br /></p> 
      <h3><strong>最新版本分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>给定软件的版本号的表示方式，以及一些版本号，请找出最新的版本。例如：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>1.2，2.2 最新的是2.2</p></li> 
       <li><p>3.1, 3.1.3 最新的是3.1.3</p></li> 
      </ol> 
      <p>上面的版本号，都是用字符串表示的。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目比较简单，可以用来考察同学们字符串的处理，因为这里强调了版本信息都是用字符串的方式存储的，但其实处理起来也比较简单，java、c++等语言已经提供了很好的API。如果不允许调用，则遍历字符串，按“.”分割，并且将字符转化诶正数即可，后面这个也有不少面试考察，大家可以找一个OJ，练练代码。那么，这个题目都有哪些方法呢？我们简单介绍两个。</p> 
      <p>如果是一个java或者c++的程序员，第一个想到的方法可能是重写比较操作符，然后对字符串整体进行快速排序，比较的方式就是我们自定义的比较操 作符，一个方法，在比较的时候，可以将字符串进行按“.”划分，对应的部分比较数字的大小。假设有n个版本号，每个版本号的长度为k，则整体的时间复杂度 为O(knlogn)，其中，划分并且逐位比较的时间复杂度为O(k)。</p> 
      <p>是否有更加高效的方法呢？因为我们要找的最新的版本（可以理解为最大的），一般来讲，我们给定一个数组，找到最大的元素，O(n)的时间复杂度就可以的。同样，在这里我们仍旧可以这样处理：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>用对每一个版本号进行划分，保存为正数的list</p></li> 
       <li><p>遍历每一个list的第一个元素，找到的最大的数字，也许会有多个</p></li> 
       <li><p>对于第一个数字最大的一些版本，处理第二个数字，同样找到最大的数字，缩小进一步查找的范围</p></li> 
       <li><p>依次类推。</p></li> 
      </ol> 
      <p>这个方法的时间复杂度为O(kn)。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"> <a href="javascript:report_article();" class="page-imform">举报</a> </p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">一些面经</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-13</span> <span class="activity-meta">未名空间站</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/198212/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <p>因为我这个人面试得有点乱七八糟，</p> 
      <wbr /> 
      <p>从stat到SDE到PM到DS都有，就一路想到哪里贴到哪里了，抱歉抱歉。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />有意义的题不多，基本上都是设计题性质，给一个case让我做，</p> 
      <wbr /> 
      <p>多半还是open case。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />先贴题目，反正答案我自己忘记的差不多了。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q0：讲讲你最得意的一个project。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q1：有一组数据，很长，有ID，经纬度，时间4个变量。</p> 
      <wbr /> 
      <p>怎么找出两人是否有一面之缘。怎么找出所有relationship（</p> 
      <wbr /> 
      <p>定义是在100米范围内一起度过1小时以上）。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q2：有一组以往marketing campaign的数据，包括使用的关键词集合，目录集合，还有成功率。怎么决定下次campaign使用哪些关键词。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q3：怎么找出竞争对手购买了哪些搜索关键词。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q4：怎么判断两个TB级别的文本是否雷同，是否近似。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q5：怎么用C实现SQL的join功能。只是思路（hash）</p> 
      <wbr /> 
      <p>，没让code。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q6：三个按钮对应隔壁房间的三盏灯，只能到隔壁房间一次，</p> 
      <wbr /> 
      <p>怎么判断哪个对应哪个。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q7：怎么用两个正方体（共12面）显示一个月的所有日期。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q8：怎么最快的在一个大文本里面搜索字符串。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q9：为什么有时候K means算法不能converge？<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q10：沙滩上有两个一模一样的冰激凌店，由两兄弟经营。</p> 
      <wbr /> 
      <p>为了竞争顾客，他们会把店开到哪里？<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q11：纽约有多少出租车？他们年收入大概多少？<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q12：某公司在各种marketing channel投入资金，请问怎么计算投资回报？怎么决定最佳投资方案？<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q13：（唯一的一个code题）计算斐波那契数列。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q14：怎么设计recommending system，怎么解决cold start 问题。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q15：假设你既卖toyota又卖lexus，</p> 
      <wbr /> 
      <p>请问应该如何定价？<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q16：怎么解决marketing data里面selection bias问题（从impression到click到purchase，每次都只有少数人进入下一步）。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q17：使用decision tree的时候，假设y应该随着x递增，</p> 
      <wbr /> 
      <p>但是cart算法得出的结果有spike，即某处出现y随着x递减的现象。怎么解决？<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q18：</p> 
      <wbr /> 
      <p>怎么判断sample是否符合预设的population 分布。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q19：假设盒子里有1000条鞋带，每次拿出两个头系起来，</p> 
      <wbr /> 
      <p>如果形成一个loop就拿出来，否则放回去。请问预期最后有几个环。<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />Q20：有一个人口调查问题是家里有几口人，</p> 
      <wbr /> 
      <p>显然最后的结果会有重复，因为4口之家每个人都会说4。怎么解决？<br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" /><br style="line-height:22px;font-size:14px;font-family:Geneva,Arial,Helvetica,sans-serif" />想起来再加。</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：分词问题；及最大乘积分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-14</span> <span class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/198975/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：分词问题</strong></h3> 
      <p>给定字符串，以及一个字典，判断字符串是否能够拆分为字段中的单词。例如，字段为{hello，world}，字符串为hellohelloworld，则可以拆分为hello,hello,world，都是字典中的单词。</p> 
      <p>==================================================<br /></p> 
      <h3><strong>最大乘积分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>一根绳子，长度为n米。将其切成几段，每一段的长度都是整数。请给出一种切法，使得切成的各段绳子之间的乘积是最大的。注意，最少要切一下的。</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目如何一步一步的分析呢？不管切几段，总有第一段，第二段…等等。第一段的长度有哪些选择呢？可以是1、2、3...一直到n-1（至少要切一下），我们用max_prod(n)表示长度为n的绳子的切法中，乘积最大的值。那么：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>当第一段长度为1时，最大的乘积为：max(1&times;max_prod(n-1), 1&times;(n-1))</p></li> 
       <li><p>当第一段长度为2时，最大的乘积为：max(2&times;max_prod(n-2), 2&times;(n-2))</p></li> 
       <li><p>…</p></li> 
       <li><p>当第一段长度为n-1时，最大的乘积为：(n-1)*1=n-1</p></li> 
      </ol> 
      <p>上面为什么是取max呢？注意，题目中的要求，至少是要切一下的。这样，从上面的分析中得出，递归的表达式，设第一段绳子的长度为i，取 值范围为[1,n-1]，则，对于每一个i，有最大乘积为:max(i&times;(n-i),i&times;max_prod(n-i))。然后对所有的i，求的最大值，就 是最终的答案。</p> 
      <p>这个题目到这里完了么？看过我们以前分析的同学，很快就能想到，进而查看，这些子问题中是否有重复的，如果有，则可以采用动态规划的方法进行算法改 进。而查看是否有重复递归子问题，一个比较好的方法，就是在纸上画出递归树，然后是否有重复的递归子问题。就一目了然了。这个题目是比较明显的，同学们可 以尝试自己在纸上画画，练习一下。</p> 
      <p>既然，我们已经明确了重复的递归子问题，然后呢？相信专门学习过动态规划专题的同学，都会记得这样的一句话：“自顶向下的分析问题，自底向上的解决 问题”，大概类似，可能并不是原话。自底向上解决问题的意思就是先解决小问题，然后依据这些小问题的结果，再解决一批问题，依次直至解决整个问题：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>当绳子的长度为1的时候，忽略，不能切</p></li> 
       <li><p>当绳子的长度为2的时候，切一刀，max_prod[2]=1&times;1</p></li> 
       <li><p>当绳子的长度为3的时候，切一刀，max_prod[3]=1&times;2</p></li> 
       <li><p>当绳子的长度为4的时候，依赖前面每一个长度的切法，并且，第一个长度从2开始。</p></li> 
       <li><p>…</p></li> 
      </ol> 
      <p>这个，状态转移方程可以表示为:max_prod[i]=max((i-j)&times;j, j&times;max_prod[i-j])，其中j的范围是[1,i/2]。显然，动态规划方法的时间复杂度为O(n^2)，空间复杂度为O(n)。</p> 
      <p>这个问题，到这里，已经挺不错的。不过，还没完，这个题目是有更加巧妙的方法的。在微博上，有的同学给出了如下的方法：只需要将长度n表示为 3x+2y=n，并且3尽可能的多，这样的3^x+2^y是最大的。不得不赞叹，这确实是一个很巧妙的方法。大家可以通过例子，验证几个。为什么只有3和 2呢？长度为4的，就是2&times;2，5以上的，都可以分解为3x+2y，并且3^x+2^y&gt;5以上的数字。这个题目要求是整数，如果取消这个限制呢？ 拓展思路，举一反三，请大家多多思考。</p> 
      <p>【分析完毕】</p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：最少插入字符；及分词问题分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-15</span> <span class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/200032/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h4><strong>今日面试题：最少插入字符</strong></h4> 
      <p>给定字符串，可以通过插入字符，使其变为回文。求最少插入字符的数量。例如：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>ab最少插入1个字符，变为<strong>b</strong>ab</p></li> 
       <li><p>aa最少插入0个字符</p></li> 
       <li><p>abcd最少插入3个字符，<strong>dcb</strong>abcd</p></li> 
      </ol> 
      <p><br /></p> 
      <p>============================================================<br /></p> 
      <h4><strong>分词问题分析</strong><br /></h4> 
      <h4><strong><span class="mini-icon mini-icon-link"></span>原题</strong></h4> 
      <p>给定字符串，以及一个字典，判断字符串是否能够拆分为字段中的单词。例如，字段为{hello，world}，字符串为hellohelloworld，则可以拆分为hello,hello,world，都是字典中的单词。</p> 
      <h4><strong><span class="mini-icon mini-icon-link"></span>分析</strong></h4> 
      <p>这个题目唤作“分词问题”，略显宽泛。只是想提及这个问题，这是在自然语言处理，搜索引擎等等领域中，非常基础的一个问题，解决的方法也比较多，相对比较成熟，不过这仍旧是一个值得进一步探索的问题。那我们先从这个简单的题目入手，看看如何处理题目中这个问题。 最直接的思路就是递归，很简单。我们考虑每一个前缀，是否在字典中？如果在，则递归处理剩下的字串，如果不在；则考虑其他前缀。示例代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/200032/1.jpg" onerror="" /></p> 
      <p>在上面的代码中：每一种情况都要处理substr，程序的耗时比较长，如果在OJ上提交，干脆超时的，那么如何改进呢？</p> 
      <p>这个题目的处理，上期的题目是很相似的。在递归子问题中，找重复的子问题。也非常明显，如下图(图片来自GeeksforGeeks)所示：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/200032/2.jpg" onerror="" /></p> 
      <p><br /></p> 
      <p>所以，通过动态规划的方法，可以通过有较大幅度的提升，同样，这个题目与前面的每一个状态都有关系的，所以，是一个二重循环，时间复杂度为O(n^2)。示例代码如下：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/200032/3.jpg" onerror="" /></p> 
      <p>除此之外，这个问题的方法是非常多的，大家还有什么思路呢？欢迎大家展开思路，在微博上互动讨论。</p> 
      <p>经过上一期的问题，还有这一期的，我想对于这类问题，递归以及动态规划方法的改进，童鞋们应该有比较好的体会了。希望大家能多做写联系，比如在OJ上，熟能生巧，提升代码功力。</p> 
      <p>【分析完毕】<br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：LIS问题；及最少插入字符分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-18</span> <span class="activity-meta">GFG</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/202680/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：LIS问题</strong></h3> 
      <p>这个LIS问题，可不是Longest Increasing Subsequence，而是Largest Independent Set，含义如下：给定一棵二叉树，找到满足如下条件的最大节点集合：<strong><em>集合中的任意两个节点之间，都没有边。</em></strong>如下图：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/202680/1.jpg" onerror="" /><br /></p> 
      <p>LIS大小为5，为{10,40,60,70,80}.</p> 
      <p><br /></p> 
      <p>================================================</p> 
      <h3><strong>最少插入字符分析</strong></h3> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>原题</strong></h4> 
      <p>给定字符串，可以通过插入字符，使其变为回文。求最少插入字符的数量。例如：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>ab最少插入1个字符，变为*b*ab</p></li> 
       <li><p>aa最少插入0个字符</p></li> 
       <li><p>abcd最少插入3个字符，*dcb*abcd</p></li> 
      </ol> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目的分析思路，和前面两期是非常相似的：给出递归的解法，发现重复的子问题，改进为动态规划的解法，这是一个分析的过程，待同学们比较熟悉时候，可以直接给出动态规划的解决方案，就很好了。</p> 
      <p>这个题目，递归该如何解呢？给定一个字符串str，长度为n，怎么插入最少的字符，是的字符串变为回文呢？插入最少的字符，就是要尽量利用原来的字符，在原字符串str中，尽量利用更多能够匹配的字符。怎么对这个问题进行分解呢？考虑str字符串整体：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>如果str[0]==str[n-1]，则问题转变为求str[1,n-2]，插入最少字符，得到回文</p></li> 
       <li><p>如果str[0]!=str[n-1]，则需要插入一个字符要么和str[0]相同，要么和str[n-1]相同，</p></li> 
       <ol class=" list-paddingleft-2" style="list-style-type: lower-alpha;"> 
        <li><p>如果和str[0]，则转变为str[1,n-1]，插入最少字符，得到回文</p></li> 
        <li><p>如果和str[n-1]，则转变为str[0,n-2]，插入最少字符，得到回文</p></li> 
       </ol> 
      </ol> 
      <p>上面的第2种情况中，需要取两个值最小值。则完成了问题的分解，并且，基本情况也分析完全，则有递归式为：</p> 
      <p><strong><em>fmi(str, l, h) = (str[l] == str[h]) ? fmi(str, l+1, h-1) : (min(fmi(str, i+1, h), fmi(str,l, h-1))+1)</em></strong></p> 
      <p>通过上面的式子，有经验的、熟练的同学，很直接的就能看出来，存在重复的子问题，这就意味着，我们可以讲子问题的解缓存使用。如果，没有直接能够看出来的同学们，还是可以按照我们之前的方法，把递归树画出来吧，那样更加一目了然。</p> 
      <p>那么，这个题目该如何用动态规划的解决呢？如何重复利用子问题的解呢？似乎有些不那么直接。但其实也是于规律可循的。上面的递归式，是从字符串的两 边，想中间移动递归，根据动态规划解决问题的思想，我们先解决子问题，再重复利用子问题，就是要从内向外解决，大家还记得回文子串判断的那个题目么，动态 规划解法的外层循环是子串的长度，这个题目也是类似的。示例代码如下：</p> 
      <p><br /></p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/202680/2.jpg" onerror="" /></p> 
      <p><br /></p> 
      <p>这个题目在使用动态规划解的时候，略有点儿绕，不太好想到如何利用子问题的解。这个没有更好的方法，就是多多积累，遇到问题勤于思考，举一反三。</p> 
      <p>【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
   <div id="essay-body"> 
    <div class="page-bizinfo"> 
     <div class="essay-header"> 
      <h1 id="activity-name">今日面试题：数对数目；及LIS问题分析</h1> 
      <p class="activity-info"><span id="post-date" class="activity-meta no-extra">2013-10-23</span> <span class="activity-meta">待字闺中</span> <a href="/account/daiziguizhongren" id="post-user" class="activity-meta"><span class="text-ellipsis">待字闺中</span><i class="icon_link_arrow"></i></a></p> 
     </div> 
    </div> 
    <div class="page-content"> 
     <div class="media" id="media"> 
      <img src="http://chuansongme.com/static/img/essay/689/207436/0.jpg" onerror="" /> 
     </div> 
     <div class="text"> 
      <h3><strong>今日面试题：数对数目</strong></h3> 
      <p>给定两个数组X和Y，元素都是正数。请找出满足如下条件的数对的数目：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>x^y &gt; y^x，即x的y次方&gt;y的x次方<br /></p></li> 
       <li><p>x来自X数组，y来自Y数组<br /></p></li> 
      </ol> 
      <p>=================================================<br /></p> 
      <h3><strong>LIS问题分析</strong></h3> 
      <h4><strong>原题</strong></h4> 
      <p>这个LIS问题，可不是Longest Increasing Subsequence，而是Largest Independent Set，含义如下：给定一棵二叉树，找到满足如下条件的最大节点集合：集合中的任意两个节点之间，都没有边。如下图：</p> 
      <p><img src="http://chuansongme.com/static/img/essay/689/207436/1.jpg" onerror="" /></p> 
      <p>LIS大小为5，为{10,40,60,70,80}.</p> 
      <h4><span class="mini-icon mini-icon-link"></span><strong>分析</strong></h4> 
      <p>这个题目与前几期的题目颇有类似，而且，一个二叉树的问题。通常来讲，树的问题一般都是可以通过递归来解决的。递归是自顶向下的分析问题，分析原问 题是否能够分解为子问题。那么LIS问题呢？我们从LIS集合大小入手，设f(x)为以x为根的数的LIS的大小，根据题目中的定义：</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>当x不在LIS中时，f(x)=sum(所有儿子节点的f(儿子))</p></li> 
       <li><p>当x在LIS中的时候，则x的儿子节点肯定不在LIS中，考虑孙子节点，则f(x)=sum(所有孙子节点的f(孙子)) + 1，后面的1是x本身。</p></li> 
      </ol> 
      <p>上面的描述，转换为代码，很简单。但是效率确实很低，是指数级的。而且，上面的递归过程中，子问题重复的比较多。最明显的就是，x的儿子 节点x的父节点的孙子节点，几乎都要重复计算，所以改进空间很大。改进的方法，最直接的就是采用缓存将计算过的子问题，缓存起来，待后面直接使用，很简 单，却又是非常实用的。</p> 
      <p>那么动态规划如何解呢？动态规划是自底向上解决问题，对于上面的递归过程，如何表示x是否在LIS中呢？微博上@曹鹏博士 给出的解法是非常好的:</p> 
      <ol class=" list-paddingleft-2" style="list-style-type: decimal;"> 
       <li><p>dp[0,1][x]表示以节点x为根的子树不取或取x的结果，第一维取0，表示x不在LIS中，第一维取1，表示x在LIS中；</p></li> 
       <li><p>dp[0][leaf]=0，dp[1][leaf]=value of the leaf</p></li> 
       <li><p>dp[0][x]=max of max dp[t=0,1][y is son of x], dp[1][x]=sum of dp[0][y is son of x] + value of x.</p></li> 
       <li><p>最后取max(dp[0][root],dp[1][root])</p></li> 
      </ol> 
      <p>这里比较有意思的是第一维来表示第二维的节点，作为根节点，是否在LIS中。上面的过程在，前序或者后序的基础之上进行都可以，原则就是一点，有儿子的，就先计算完儿子，再计算父节点。</p> 
      <p>【分析完毕】</p> 
      <p><br /></p> 
     </div> 
     <p class="page-toolbar"><a href="javascript:report_article();" class="page-imform">举报</a></p> 
    </div> 
   </div>
  </div>  
 </body>
</html>